******************************************************************************
*                                S Y N T A X
*-----------------------------------------------------------------------------
*   Copyright (C) 1972-2023 INRIA (Institut National de Recherche en
*   Informatique et Automatique)
*-----------------------------------------------------------------------------
*   URL: http://sourcesup.renater.fr/projects/syntax
*-----------------------------------------------------------------------------
*   The source code of SYNTAX is distributed with two different licenses,
*   depending on the files:
*   - The recursive content of src/ and incl/ and the non-recursive content
*     of SYNTAX's root directory are distributed under the CeCILL-C license
*   - The recursive content of all other repertories is distributed under
*     the CeCILL license
*   All code produced by SYNTAX must be considered as being under the
*   CeCILL-C license. Information about the CeCILL and CeCILL-C licenses
*   can be found at, e.g., http://www.cecill.info
*****************************************************************************

*
* This grammar of FORTRAN 77 is based upon the ANSI standard syntax charts
* Annex F of https://nvlpubs.nist.gov/nistpubs/Legacy/FIPS/fipspub69-1.pdf
*
* Il contains a few usual extensions, marked with the word "EXTENSION"

*******************************************************************************

<0:F77>		= ~COL(7)~ <1a:executable_program_list> ~COL(1)~ ;

*------------------------------------------------------------------------------

* ENTRY POINT USED BY THE LOOK-AHEAD MECANISM

*<0:F77>	= !DO  =  <78:int_real_dp_expr> , ;
* (pb) : changed by
<0:F77>		= !DO  <110b:label_ref>  <99:symbolic_name>  =  <40b:do_parameters> ;

*------------------------------------------------------------------------------

* ENTRY POINT USED BY THE LOOK-AHEAD MECANISM

* EXTENSION (loop without label)

<0:F77>		= !DO  <99:symbolic_name>  =  <40b:do_parameters> ;

*------------------------------------------------------------------------------

* ENTRY POINT USED BY THE LOOK-AHEAD MECANISM

<0:F77>		= !FORMAT <59:format_specification> ;

*******************************************************************************

* An executable program must contain one and only one main program.
* An executable program may contain external procedures specified
* by means other than FORTAN.

<1:executable_program>
		= <2:main_program> %EOL ;

*------------------------------------------------------------------------------

<1:executable_program>
		= <3:function_subprogram> %EOL ;

*------------------------------------------------------------------------------

<1:executable_program>
		= <4:subroutine_subprogram> %EOL ;

*------------------------------------------------------------------------------

<1:executable_program>
		= <5:block_data_subprogram> %EOL ;

*******************************************************************************

<1a:executable_program_list>
		= <1a:executable_program_list>
		  <1:executable_program> ;

*------------------------------------------------------------------------------

<1a:executable_program_list>
		= <1:executable_program> ;

*******************************************************************************

* A main program may not contain an ENTRY or RETURN statement.

<2:main_program>
		= <8:program_statement> %EOL
		  <2a:end_statement> ;

*------------------------------------------------------------------------------

<2:main_program>
		= <2a:end_statement> ;

*------------------------------------------------------------------------------

<2:main_program>
		= <8:program_statement> %EOL
		  <2c:statement_list>
		  <2a:end_statement> ;

*------------------------------------------------------------------------------

<2:main_program>
		= <2c:statement_list>
		  <2a:end_statement> ;

*******************************************************************************

* An END statement is also an executable statement and must appear as the
* last statement of a program unit.

<2a:end_statement>
		= ~COL(1)~ <110:label> ~MARGIN~ END
		  ~COL(1)~ ;

*------------------------------------------------------------------------------

<2a:end_statement>
		= END
		  ~COL(1)~ ;

*******************************************************************************

<2c:statement_list>
		= <2c:statement_list>
		  <2d:labeled_statement> %EOL ;

*------------------------------------------------------------------------------

<2c:statement_list>
		= <2d:labeled_statement> %EOL ;

*******************************************************************************

<2d:labeled_statement>
		= ~COL(1)~ <110:label> ~MARGIN~ <2e:statement> ;

*------------------------------------------------------------------------------

<2d:labeled_statement>
		= ~COL(1)~ <110:label> ~MARGIN~ <58:format_statement> ;

*------------------------------------------------------------------------------

<2d:labeled_statement>
		= <2e:statement> ;

*******************************************************************************

<2e:statement>	= <6:other_specification_statement> ;

*------------------------------------------------------------------------------

<2e:statement>	= <7:executable_statement> ;

*------------------------------------------------------------------------------

<2e:statement>	= <7a:other_executable_statement> ;

*------------------------------------------------------------------------------

<2e:statement>	= <9:entry_statement> ;

*------------------------------------------------------------------------------

<2e:statement>	= <21:implicit_statement> ;

*------------------------------------------------------------------------------

<2e:statement>	= <23:parameter_statement> ;

*------------------------------------------------------------------------------

<2e:statement>	= <27:data_statement> ;

*------------------------------------------------------------------------------

<2e:statement>	= <70:statement_function_statement> ;

*******************************************************************************

<3:function_subprogram>
		= <10:function_statement> %EOL
		  <2a:end_statement> ;

*------------------------------------------------------------------------------

<3:function_subprogram>
		= <10:function_statement> %EOL
		  <2c:statement_list>
		  <2a:end_statement> ;

*******************************************************************************

<4:subroutine_subprogram>
		= <12:subroutine_statement> %EOL
		  <2a:end_statement> ;

*------------------------------------------------------------------------------

<4:subroutine_subprogram>
		= <12:subroutine_statement> %EOL
		  <2c:statement_list>
		  <2a:end_statement> ;

*******************************************************************************

* A block data subprogram may contain only BLOCK DATA, IMPLICIT, PARAMETER,
* DIMENSION, COMMON, SAVE, EQUIVALENCE, DATA, END, and type_statements.

<5:block_data_subprogram>
		= <14:block_data_statement> %EOL
		  <2a:end_statement> ;

*------------------------------------------------------------------------------

<5:block_data_subprogram>
		= <14:block_data_statement> %EOL
		  <2c:statement_list>
		  <2a:end_statement> ;

*******************************************************************************

<6:other_specification_statement>
		= <15:dimension_statement> ;

*------------------------------------------------------------------------------

<6:other_specification_statement>
		= <17:equivalence_statement> ;

*------------------------------------------------------------------------------

<6:other_specification_statement>
		= <19:common_statement> ;

*------------------------------------------------------------------------------

<6:other_specification_statement>
		= <20:type_statement> ;

*------------------------------------------------------------------------------

<6:other_specification_statement>
		= <24:external_statement> ;

*------------------------------------------------------------------------------

<6:other_specification_statement>
		= <25:intrinsic_statement> ;

*------------------------------------------------------------------------------

<6:other_specification_statement>
		= <26:save_statement> ;

*******************************************************************************

<7:executable_statement>
		= <29:assignment_statement> ;

*------------------------------------------------------------------------------

<7:executable_statement>
		= <30:goto_statement> ;

*------------------------------------------------------------------------------

<7:executable_statement>
		= <34:arithmetic_if_statement> ;

*------------------------------------------------------------------------------

<7:executable_statement>
		= <41:continue_statement> ;

*------------------------------------------------------------------------------

<7:executable_statement>
		= <42:stop_statement> ;

*------------------------------------------------------------------------------

<7:executable_statement>
		= <43:pause_statement> ;

*------------------------------------------------------------------------------

<7:executable_statement>
		= <44:write_statement> ;

*------------------------------------------------------------------------------

<7:executable_statement>
		= <45:read_statement> ;

*------------------------------------------------------------------------------

<7:executable_statement>
		= <46:print_statement> ;

*------------------------------------------------------------------------------

<7:executable_statement>
		= <55:rewind_statement> ;

*------------------------------------------------------------------------------

<7:executable_statement>
		= <53:backspace_statement> ;

*------------------------------------------------------------------------------

<7:executable_statement>
		= <54:endfile_statement> ;

*------------------------------------------------------------------------------

<7:executable_statement>
		= <50:open_statement> ;

*------------------------------------------------------------------------------

<7:executable_statement>
		= <51:close_statement> ;

*------------------------------------------------------------------------------

<7:executable_statement>
		= <52:inquire_statement> ;

*------------------------------------------------------------------------------

<7:executable_statement>
		= <71:call_statement> ;

*------------------------------------------------------------------------------

<7:executable_statement>
		= <72:return_statement> ;

*******************************************************************************

* Used in a structured way from <35:logical_if_statement>
*<7a:other_executable_statement>
*		= <37:else_if_statement> ;
*<7a:other_executable_statement>
*		= <38:else_statement> ;
*<7a:other_executable_statement>
*		= <39:end_if_statement> ;

<7a:other_executable_statement>
		= <35:logical_if_statement> ;

*------------------------------------------------------------------------------

<7a:other_executable_statement>
		= <36:block_if_statement> ;

*------------------------------------------------------------------------------

<7a:other_executable_statement>
		= <40a:do_loop> ;

*******************************************************************************

<8:program_statement>
		= PROGRAM  <99:symbolic_name> ;

*******************************************************************************

<9:entry_statement>
		= <13:function_or_subroutine_entry> ;

*******************************************************************************

<10:function_statement>
		= <10a:type>  FUNCTION  <10d:function_header> ;

*------------------------------------------------------------------------------

<10:function_statement>
		= FUNCTION  <10d:function_header> ;

*******************************************************************************

<10a:type>	= <10b:scalar_type> ;
* Non standard ANSI

*------------------------------------------------------------------------------

<10a:type>	= <10b:scalar_type> * @0 <22:len_specification> ;

*------------------------------------------------------------------------------

<10a:type>	= CHARACTER ;

*------------------------------------------------------------------------------

<10a:type>	= CHARACTER  * <22:len_specification> ;

*******************************************************************************

<10b:scalar_type>
		= INTEGER ;

*------------------------------------------------------------------------------

<10b:scalar_type>
		= REAL ;

*------------------------------------------------------------------------------

<10b:scalar_type>
		= DOUBLE  PRECISION ;

*------------------------------------------------------------------------------

<10b:scalar_type>
		= COMPLEX ;

*------------------------------------------------------------------------------

<10b:scalar_type>
		= LOGICAL ;

*******************************************************************************

<10d:function_header>
		= <99:symbolic_name>  ( ) ;

*------------------------------------------------------------------------------

<10d:function_header>
		= <99:symbolic_name>  ( <99a:symbolic_name_list> ) ;

*******************************************************************************

* Covered by <13:function_or_subroutine_entry>
*<11:function_entry>
*		= ENTRY  <99:symbolic_name> ;
*<11:function_entry>
*
*		= ENTRY  <99:symbolic_name>  ( ) ;
*<11:function_entry>
*		= ENTRY  <99:symbolic_name>  ( <99a:symbolic_name_list> ) ;

*******************************************************************************

<12:subroutine_statement>
		= SUBROUTINE  <12a:subroutine_header> ;

*******************************************************************************

<12a:subroutine_header>
		= <99:symbolic_name> ;

*------------------------------------------------------------------------------

<12a:subroutine_header>
		= <99:symbolic_name>  ( ) ;

*------------------------------------------------------------------------------

<12a:subroutine_header>
		= <99:symbolic_name>  ( <12b:subroutine_parameter_list> ) ;

*******************************************************************************

<12b:subroutine_parameter_list>
		= <12b:subroutine_parameter_list> ,  <12c:subroutine_parameter> ;

*------------------------------------------------------------------------------

<12b:subroutine_parameter_list>
		= <12c:subroutine_parameter> ;

*******************************************************************************

<12c:subroutine_parameter>
		= <99:symbolic_name> ;

*------------------------------------------------------------------------------

<12c:subroutine_parameter>
		= * ;

*******************************************************************************

<13:function_or_subroutine_entry>
		= ENTRY  <12a:subroutine_header> ;

*******************************************************************************

<14:block_data_statement>
		= BLOCK  DATA ;

*------------------------------------------------------------------------------

<14:block_data_statement>
		= BLOCK  DATA  <99:symbolic_name> ;

*******************************************************************************

<15:dimension_statement>
		= DIMENSION  <16a:array_declarator_list> ;

*******************************************************************************

* Only a dummy array declarator (5.1.2.2) may contain an asterik.

<16:array_declarator>
		= <99:symbolic_name>  ( <16b:dimension_declarator_list> ) ;

*******************************************************************************

<16a:array_declarator_list>
		= <16a:array_declarator_list> ,  <16:array_declarator> ;

*------------------------------------------------------------------------------

<16a:array_declarator_list>
		= <16:array_declarator> ;

*******************************************************************************

* The maximum number of dimensions is seven.

<16b:dimension_declarator_list>
		= <16c:dimension_declarator> ,  <16b:dimension_declarator_list> ;

*------------------------------------------------------------------------------

<16b:dimension_declarator_list>
		= <16d:last_dimension_declarator> ;

*******************************************************************************

<16c:dimension_declarator>
		= <81:dim_bound_expr>  :  <81:dim_bound_expr> ;

*------------------------------------------------------------------------------

<16c:dimension_declarator>
		= <81:dim_bound_expr> ;

*******************************************************************************

<16d:last_dimension_declarator>
		= <81:dim_bound_expr>  :  <16e:last_upper_dimension_bound> ;

*------------------------------------------------------------------------------

<16d:last_dimension_declarator>
		= <16e:last_upper_dimension_bound> ;

*******************************************************************************

<16e:last_upper_dimension_bound>
		= <81:dim_bound_expr> ;

*------------------------------------------------------------------------------

<16e:last_upper_dimension_bound>
		= * ;

*******************************************************************************

<17:equivalence_statement>
		= EQUIVALENCE  <18a:equiv_list> ;

*******************************************************************************

* A subscript or substring expression in an EQUIVALENCE statement must be an
* integer constant expression.

<18:equiv_entity>
		= <99:symbolic_name> ;

*------------------------------------------------------------------------------

<18:equiv_entity>
		= <88b:function_reference_or_array_element_name> ;

*------------------------------------------------------------------------------

<18:equiv_entity>
		= <89:substring_name> ;

*******************************************************************************

<18a:equiv_list>
		= <18a:equiv_list> ,  <18b:equiv> ;

*------------------------------------------------------------------------------

<18a:equiv_list>
		= <18b:equiv> ;

*******************************************************************************

<18b:equiv>	= ( <18c:equiv_entity_list> ) ;

*******************************************************************************

<18c:equiv_entity_list>
		= <18c:equiv_entity_list> ,  <18:equiv_entity> ;

*------------------------------------------------------------------------------

<18c:equiv_entity_list>
		= <18:equiv_entity> ;

*******************************************************************************

<19:common_statement>
		= COMMON   <19a:common_body_list> ;

*******************************************************************************

*<19a:common_body_list>
*		= <19a:common_body_list> ,  <19b:common_part> ;
*<19a:common_body_list>
*		= <19b:common_part> ;
*<19a:common_body_list>
*		= <20a:scalar_name_list> ;

<19a:common_body_list>
		= <19a:common_body_list>  <,common_body> ;

*------------------------------------------------------------------------------

<19a:common_body_list>
		= <common_body> ;

*******************************************************************************

<,common_body>	= ,  <common_body> ;

*------------------------------------------------------------------------------

* Optional ',' in the <19b:common_part> case

<,common_body>	= <19b:common_part> ;

*******************************************************************************

<common_body>	= <19b:common_part> ;

*------------------------------------------------------------------------------

<common_body>	= <20b:scalar_name> ;

*******************************************************************************

*<19b:common_part>
*		= / <99:symbolic_name> /  <20a:scalar_name_list> , ;
*<19b:common_part>
*		= / <99:symbolic_name> /  <20a:scalar_name_list> ;
*<19b:common_part>
*		= / /  <20a:scalar_name_list> , ;
*<19b:common_part>
*		= / /  <20a:scalar_name_list> ;

<19b:common_part>
		= / <99:symbolic_name> /  <20b:scalar_name> ;

*------------------------------------------------------------------------------

* Voir ci-dessous le commentaire de la regle <60f:/:>. La situation est
* similaire ici. On a mis '//' à la place de '/'  '/' car on peut ne pas 
* avoir de <99:symbolic_name>.

<19b:common_part>
		= // <20b:scalar_name> ;

*******************************************************************************

<20:type_statement>
		= <10b:scalar_type>  <20a:scalar_name_list> ;
* Non standard ANSI

*------------------------------------------------------------------------------

<20:type_statement>
		= <10b:scalar_type> * @0 <22:len_specification>  <20a:scalar_name_list> ;
* Non standard ANSI

*------------------------------------------------------------------------------

<20:type_statement>
		= <10b:scalar_type> * @0 <22:len_specification> ,  <20a:scalar_name_list> ;

*------------------------------------------------------------------------------

<20:type_statement>
		= CHARACTER  <20c:character_name_list> ;

*------------------------------------------------------------------------------

<20:type_statement>
		= CHARACTER * <22:len_specification>  <20c:character_name_list> ;

*------------------------------------------------------------------------------

<20:type_statement>
		= CHARACTER * <22:len_specification> ,  <20c:character_name_list> ;

*******************************************************************************

<20a:scalar_name_list>
		= <20a:scalar_name_list> ,  <20b:scalar_name> ;

*------------------------------------------------------------------------------

<20a:scalar_name_list>
		= <20b:scalar_name> ;

*******************************************************************************

<20b:scalar_name>
		= <16:array_declarator> ;

*------------------------------------------------------------------------------

<20b:scalar_name>
		= <99:symbolic_name> ;

*******************************************************************************

<20c:character_name_list>
		= <20c:character_name_list> ,  <20d:character_name> ;

*------------------------------------------------------------------------------

<20c:character_name_list>
		= <20d:character_name> ;

*******************************************************************************

<20d:character_name>
		= <20b:scalar_name> * <22:len_specification> ;

*------------------------------------------------------------------------------

<20d:character_name>
		= <20b:scalar_name> ;

*******************************************************************************

<21:implicit_statement>
		= IMPLICIT  <21a:implicit_body_list> ;

*******************************************************************************

<21a:implicit_body_list>
		= <21a:implicit_body_list> ,  <21b:implicit_body> ;

*------------------------------------------------------------------------------

<21a:implicit_body_list>
		= <21b:implicit_body> ;

*******************************************************************************

<21b:implicit_body>
		= <10a:type>  ( <21c:implicit_elem_list> ) ;

*******************************************************************************

<21c:implicit_elem_list>
		= <21c:implicit_elem_list> ,  <21d:implicit_elem> ;

*------------------------------------------------------------------------------

<21c:implicit_elem_list>
		= <21d:implicit_elem> ;

*******************************************************************************

<21d:implicit_elem>
		= <99:symbolic_name> ;

*------------------------------------------------------------------------------

<21d:implicit_elem>
		= <99:symbolic_name> - <99:symbolic_name> ;

*******************************************************************************

<22:len_specification>
		= ( * ) ;

*------------------------------------------------------------------------------

<22:len_specification>
		= <103:nonzero_unsigned_int_constant> ;

*------------------------------------------------------------------------------

<22:len_specification>
		= %int_id ;

*------------------------------------------------------------------------------

<22:len_specification>
		= ( <80:int_constant_expr> ) ;

*******************************************************************************

<23:parameter_statement>
		= PARAMETER  ( <23a:assign_list> ) ;

*******************************************************************************

<23a:assign_list>
		= <23a:assign_list> ,  <23b:assign> ;

*------------------------------------------------------------------------------

<23a:assign_list>
		= <23b:assign> ;

*******************************************************************************

<23b:assign>	= <99:symbolic_name>  =  <75:constant_expr> ;

*******************************************************************************

<24:external_statement>
		= EXTERNAL  <99a:symbolic_name_list> ;

*******************************************************************************

<25:intrinsic_statement>
		= INTRINSIC  <99a:symbolic_name_list> ;

*******************************************************************************

<26:save_statement>
		= SAVE ;

*------------------------------------------------------------------------------

<26:save_statement>
		= SAVE  <26a:save_statement_name_list> ;

*******************************************************************************

<26a:save_statement_name_list>
		= <26a:save_statement_name_list> ,  <26b:save_statement_name> ;

*------------------------------------------------------------------------------

<26a:save_statement_name_list>
		= <26b:save_statement_name> ;

*******************************************************************************

<26b:save_statement_name>
		= <99:symbolic_name> ;

*------------------------------------------------------------------------------

<26b:save_statement_name>
		= / <99:symbolic_name> / ;

*******************************************************************************

<27:data_statement>
		= DATA  <27a:data_statement_body_list> ;

*******************************************************************************

<27a:data_statement_body_list>
		= <27a:data_statement_body_list> ,  <27b:data_statement_body> ;

*------------------------------------------------------------------------------

<27a:data_statement_body_list>
		= <27a:data_statement_body_list> <27b:data_statement_body> ;

*------------------------------------------------------------------------------

<27a:data_statement_body_list>
		= <27b:data_statement_body> ;

*******************************************************************************

<27b:data_statement_body>
		= <27c:data_statement_name_list>  / <27e:data_statement_constant_list> / ;

*******************************************************************************

<27c:data_statement_name_list>
		= <27c:data_statement_name_list> ,  <27d:data_statement_name> ;

*------------------------------------------------------------------------------

<27c:data_statement_name_list>
		= <27d:data_statement_name> ;

*******************************************************************************

<27d:data_statement_name>
		= <99:symbolic_name> ;

*------------------------------------------------------------------------------

<27d:data_statement_name>
		= <88b:function_reference_or_array_element_name> ;

*------------------------------------------------------------------------------

<27d:data_statement_name>
		= <89:substring_name> ;

*------------------------------------------------------------------------------

<27d:data_statement_name>
		= <28:data_imply_do_list> ;

*******************************************************************************

<27e:data_statement_constant_list>
		= <27e:data_statement_constant_list> ,  <27f:data_statement_constant> ;

*------------------------------------------------------------------------------

<27e:data_statement_constant_list>
		= <27f:data_statement_constant>;

*******************************************************************************

<27f:data_statement_constant>
		= <99:symbolic_name> ;

*------------------------------------------------------------------------------

<27f:data_statement_constant>
		= <100:constant> ;

*------------------------------------------------------------------------------

<27f:data_statement_constant>
		= <103:nonzero_unsigned_int_constant>  *  <100:constant> ;

*------------------------------------------------------------------------------

<27f:data_statement_constant>
		= <103:nonzero_unsigned_int_constant>  *  <99:symbolic_name> ;

*------------------------------------------------------------------------------

<27f:data_statement_constant>
		= <99:symbolic_name>  *  <100:constant> ;

*------------------------------------------------------------------------------

<27f:data_statement_constant>
		= <99:symbolic_name>  *  <99:symbolic_name> ;

*******************************************************************************

<28:data_imply_do_list>
		= ( <28a:data_imply_do_list_head_list>  =  <80:int_constant_expr> ,  <80:int_constant_expr> ) ;

*------------------------------------------------------------------------------

<28:data_imply_do_list>
		= ( <28a:data_imply_do_list_head_list>  =  <80:int_constant_expr> ,  <80:int_constant_expr> ,  <80:int_constant_expr> ) ;

*******************************************************************************

<28a:data_imply_do_list_head_list>
		= <28b:data_imply_do_list_head> ,  <28a:data_imply_do_list_head_list> ;

*------------------------------------------------------------------------------

<28a:data_imply_do_list_head_list>
		= <28b:data_imply_do_list_head> ,  <99:symbolic_name> ;

*******************************************************************************

<28b:data_imply_do_list_head>
		= <88b:function_reference_or_array_element_name> ;

*------------------------------------------------------------------------------

<28b:data_imply_do_list_head>
		= <28:data_imply_do_list> ;

*******************************************************************************

<29:assignment_statement>
		= <29a:left_hand_side>  =  <74:expression> ;

*------------------------------------------------------------------------------

<29:assignment_statement>
		= ASSIGN  <110b:label_ref>  TO  <99:symbolic_name> ;

*******************************************************************************

<29a:left_hand_side>
		= <99:symbolic_name> ;

*------------------------------------------------------------------------------

<29a:left_hand_side>
		= <88:array_element_name> ;

*------------------------------------------------------------------------------

<29a:left_hand_side>
		= <89:substring_name> ;

*******************************************************************************

<30:goto_statement>
		= <31:unconditional_goto> ;

*------------------------------------------------------------------------------

<30:goto_statement>
		= <32:computed_goto> ;

*------------------------------------------------------------------------------

<30:goto_statement>
		= <33:assigned_goto> ;

*******************************************************************************

<31:unconditional_goto>
		= GO  TO  <110b:label_ref> ;

*******************************************************************************

<32:computed_goto>
		= GO  TO  ( <110a:label_ref_list> ) ,  <77:integer_expr> ;

*------------------------------------------------------------------------------

<32:computed_goto>
		= GO  TO  ( <110a:label_ref_list> )  <77:integer_expr> ;

*******************************************************************************

<33:assigned_goto>
		= GO  TO  <99:symbolic_name> ,  ( <110a:label_ref_list> ) ;

*------------------------------------------------------------------------------

<33:assigned_goto>
		= GO  TO  <99:symbolic_name>  ( <110a:label_ref_list> ) ;

*------------------------------------------------------------------------------

<33:assigned_goto>
		= GO  TO  <99:symbolic_name> ;

*******************************************************************************

* <78:int_real_dp_expr> is covered by <74:expression>

<34:arithmetic_if_statement>
		= IF  ( <74:expression> )  <110b:label_ref> ,  <110b:label_ref> ,  <110b:label_ref> ;

*******************************************************************************

*The executable statement contained in a logical IF statement must not be
* a DO, block IF, ELSE IF, ELSE, END IF, END, or another logical IF statement.

<35:logical_if_statement>
		= IF  ( <74:expression> )  <7:executable_statement> ;

*******************************************************************************

*<36:block_if_statement>
*		= IF  ( <74:expression> )  THEN %EOL
*		     <2c:statement_list>
*		  <36a:else_blocks> ;

* A (dummy) empty statement is allowed as a <2c:statement_list>

<36:block_if_statement>
		= IF  ( <74:expression> )  THEN %EOL
		     <2c:statement_list>
		  <36a:else_blocks> ;

*------------------------------------------------------------------------------

<36:block_if_statement>
		= IF  ( <74:expression> )  THEN %EOL
		  <36a:else_blocks> ;

*******************************************************************************

*<36a:else_blocks>
*		= <39:end_if_statement> ;
*<36a:else_blocks>
*		= <38:else_statement>
*		     <2c:statement_list>
*		  <39:end_if_statement> ;
*<36a:else_blocks>
*		= <37:else_if_statement>
*		     <2c:statement_list>
*		  <36a:else_blocks> ;

<36a:else_blocks>
		= <39:end_if_statement> ;

*------------------------------------------------------------------------------

<36a:else_blocks>
		= <38:else_statement>
		     <2c:statement_list>
		  <39:end_if_statement> ;

*------------------------------------------------------------------------------

<36a:else_blocks>
		= <38:else_statement>
		  <39:end_if_statement> ;

*------------------------------------------------------------------------------

<36a:else_blocks>
		= <37:else_if_statement>
		     <2c:statement_list>
		  <36a:else_blocks> ;

*------------------------------------------------------------------------------

<36a:else_blocks>
		= <37:else_if_statement>
		  <36a:else_blocks> ;

*******************************************************************************

<37:else_if_statement>
		= ELSE  IF  ( <74:expression> )  THEN %EOL ;

*------------------------------------------------------------------------------

<37:else_if_statement>
		= ~COL(1)~ <110:label> ~MARGIN~ ELSE  IF  ( <74:expression> )  THEN %EOL ;

*******************************************************************************

<38:else_statement>
		= ELSE %EOL ;

*------------------------------------------------------------------------------

<38:else_statement>
		= ~COL(1)~ <110:label> ~MARGIN~ ELSE %EOL ;

*******************************************************************************

<39:end_if_statement>
		= END  IF ;

*------------------------------------------------------------------------------

<39:end_if_statement>
		= ~COL(1)~ <110:label> ~MARGIN~ END  IF ;

*******************************************************************************

* EXTENSION
* On introduit la notion de bloc <40a:do_loop> avec un header <40:do_statement>,
* un corps <2c:statement_list> et une fin de bloc %ENDDO.
* Ce %ENDDO est un dummy terminal zombie (voir f77.lecl) generique (il 
* commence par un "%"). Zombie signifie qu'il a un code (comme n'importe quel 
* terminal) mais qu'aucune sous-chaine d'un programme source ne pourra être
* reconnue comme étant %ENDDO. Les %ENDDO sont injectes dans la chaine de
* tokens, non par le scanner, mais par une post-action lexicale (@0) associee
* a la reconnaissance de %label.
*
* Considerant le programme suivant, ou les labi sont des labels (nombres entiers)
* ...
*       DO lab0 ...
*         DO lab1 ...
*           ...
*                 DO labn ...
*                   ...
* lab0              CONTINUE
*       ...
*
* après la reconnaissance lexicale de lab0 en position etiquette, la 
* post-action lexicale @3 va generer n+1 tokens de type %ENDDO, qui vont donc
* fermer les n+1 DO ouverts.
*
* Cette description permet d'exclure syntaxiquement la presence de blocs 
* imbriques. L'indentation du programme par le paragrapheur ppf77 va être
* correcte et revenir a la position occupee avant le premier DO.
*
* De plus, si, ayant associe' au terminal generique %ENDDO un texte vide 
* (string_table_entry == EMPTY_STE), aucun texte parasite ne sera produit par 
* ppf77 lorsqu'il traversera les noeuds associes aux %ENDDO dans l'arbre
* d'analyse.

<40a:do_loop>	= <40:do_statement>
		     <2c:statement_list> %ENDDO ;

*------------------------------------------------------------------------------

* EXTENSION. Ci-apres, on a un vrai "do_block" se terminant par un vrai END DO 
* qui va aussi fermer tous les <40:do_statement> ouverts dans le "do_block".

<40a:do_loop>	= DO  <99:symbolic_name>  =  <40b:do_parameters> %EOL
		     <2c:statement_list>
                  <40c:end_do> ;

*******************************************************************************

<40:do_statement>
		= DO  <110b:label_ref> ,  <99:symbolic_name>  =  <40b:do_parameters> %EOL ;

*------------------------------------------------------------------------------

<40:do_statement>
		= DO  <110b:label_ref>  <99:symbolic_name>  =  <40b:do_parameters> %EOL ;

*******************************************************************************

* EXTENSION
<40c:end_do>    = END  DO ;

*------------------------------------------------------------------------------

<40c:end_do>    = ~COL(1)~ <110:label> ~MARGIN~ END  DO ;

*******************************************************************************

<40b:do_parameters>
		= <78:int_real_dp_expr> ,  <78:int_real_dp_expr> ,  <78:int_real_dp_expr> ;

*------------------------------------------------------------------------------

<40b:do_parameters>
		= <78:int_real_dp_expr> ,  <78:int_real_dp_expr> ;

*******************************************************************************

<41:continue_statement>
		= CONTINUE ;

*******************************************************************************

* The <102:unsigned_int_constant> in a <42:stop_statement> or in a
* <43:pause_statement> must contains at most 5 digits (not tested).

<42:stop_statement>
		= STOP ;

*------------------------------------------------------------------------------

<42:stop_statement>
		= STOP  <102:unsigned_int_constant> ;

*------------------------------------------------------------------------------

<42:stop_statement>
		= STOP  <109:character_constant> ;

*******************************************************************************

<43:pause_statement>
		= PAUSE  ;

*------------------------------------------------------------------------------

<43:pause_statement>
		= PAUSE  <102:unsigned_int_constant> ;

*------------------------------------------------------------------------------

<43:pause_statement>
		= PAUSE  <109:character_constant> ;

*******************************************************************************

<44:write_statement>
		= WRITE  ( <47:control_info_list> )  <48:io_list> ;

*------------------------------------------------------------------------------

<44:write_statement>
		= WRITE  ( <47:control_info_list> ) ;

*******************************************************************************

* READ introduces a read statement with control info list, READkw a format identifier.
* READkw is chosen when the next token is not a '(' or when a balanced structure
* is followed by ',' or '//'; otherwise READ is chosen

<45:read_statement>
		= READ  ( <47:control_info_list> )  <48:io_list> ;

*------------------------------------------------------------------------------

<45:read_statement>
		= READ  ( <47:control_info_list> ) ;

*------------------------------------------------------------------------------

<45:read_statement>
		= READkw  <57:format_identifier> ,  <48:io_list> ;

*------------------------------------------------------------------------------

<45:read_statement>
		= READkw  <57:format_identifier> ;

*******************************************************************************

<46:print_statement>
		= PRINT  <57:format_identifier> ,  <48:io_list> ;

*------------------------------------------------------------------------------

<46:print_statement>
		= PRINT  <57:format_identifier> ;

*******************************************************************************

* A control info list must contain exactly one unit_identifier.
* An END = specifier must not appear in a WRITE statement.
* Each info_elem must appear at most one time.

<47:control_info_list>
		= <56:unit_identifier> ;

*------------------------------------------------------------------------------

<47:control_info_list>
		= <47b:control_info_elem_list> ;

*******************************************************************************

<47b:control_info_elem_list>
		= <47b:control_info_elem_list> ,  <47a:control_info_elem> ;

*------------------------------------------------------------------------------

<47b:control_info_elem_list>
		= <56:unit_identifier> ,  <57:format_identifier> ;

*------------------------------------------------------------------------------

<47b:control_info_elem_list>
		= <56:unit_identifier> ,  <47a:control_info_elem> ;

*------------------------------------------------------------------------------

<47b:control_info_elem_list>
		= <47a:control_info_elem> ;

*******************************************************************************

<47a:control_info_elem>
		= FMT  =  <57:format_identifier> ;

*------------------------------------------------------------------------------

<47a:control_info_elem>
		= UNIT  =  <56:unit_identifier> ;

*------------------------------------------------------------------------------

<47a:control_info_elem>
		= REC  =  <77:integer_expr> ;

*------------------------------------------------------------------------------

<47a:control_info_elem>
		= END  =  <110b:label_ref> ;

*------------------------------------------------------------------------------

<47a:control_info_elem>
		= ERR  =  <110b:label_ref> ;

*------------------------------------------------------------------------------

<47a:control_info_elem>
		= IOSTAT  =  <88a:variable_or_array_element_name> ;

*******************************************************************************

* &1 Check that the "," is not the one inside a <107:complex_constant>
* Is LALR (4) instead (checked by V4.0).
* The look-ahead in the <107:complex_constant> case is : 
* "," ["+"|"-"] ("<102:unsigned_int_constant>"|"<105:unsigned_real_constant>") ")"

<48:io_list>	= <48:io_list> , &1  <74:expression> ;

*------------------------------------------------------------------------------

<48:io_list>	= <48:io_list> , &1  <49:io_imply_do_list> ;

*------------------------------------------------------------------------------

<48:io_list>	= <74:expression> ;

*------------------------------------------------------------------------------

<48:io_list>	= <49:io_imply_do_list> ;

*******************************************************************************

<49:io_imply_do_list>
		= ( <48:io_list> , &1  <99:symbolic_name>  =  <78:int_real_dp_expr> ,  <78:int_real_dp_expr> ,  <78:int_real_dp_expr> ) ;

*------------------------------------------------------------------------------

<49:io_imply_do_list>
		= ( <48:io_list> , &1  <99:symbolic_name>  =  <78:int_real_dp_expr> ,  <78:int_real_dp_expr> ) ;

*******************************************************************************

* A open info list must contain exactly one unit_identifier.
* Each info_elem must appear at most one time.

<50:open_statement>
		= OPEN  ( <50a:open_info_elem_list> ) ;

*******************************************************************************

<50a:open_info_elem_list>
		= <50a:open_info_elem_list> ,  <50b:open_info_elem> ;

*------------------------------------------------------------------------------

<50a:open_info_elem_list>
		= <56:unit_identifier> ;

*------------------------------------------------------------------------------

<50a:open_info_elem_list>
		= <50b:open_info_elem> ;

*******************************************************************************

<50b:open_info_elem>
		= UNIT  =  <56:unit_identifier> ;

*------------------------------------------------------------------------------

<50b:open_info_elem>
		= ERR  =  <110b:label_ref> ;

*------------------------------------------------------------------------------

<50b:open_info_elem>
		= FILE  =  <82a:character_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<50b:open_info_elem>
		= STATUS  =  <82a:character_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<50b:open_info_elem>
		= ACCESS  =  <82a:character_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<50b:open_info_elem>
		= FORM  =  <82a:character_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<50b:open_info_elem>
		= RECL  =  <77:integer_expr> ;

*------------------------------------------------------------------------------

<50b:open_info_elem>
		= BLANK  =  <82a:character_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<50b:open_info_elem>
		= IOSTAT  =  <88a:variable_or_array_element_name> ;

*******************************************************************************

* A close info list must contain exactly one unit_identifier.
* Each info_elem must appear at most one time.

<51:close_statement>
		= CLOSE  ( <51a:close_info_elem_list> ) ;

*******************************************************************************

<51a:close_info_elem_list>
		= <51a:close_info_elem_list> ,  <51b:close_info_elem> ;

*------------------------------------------------------------------------------

<51a:close_info_elem_list>
		= <56:unit_identifier> ;

*------------------------------------------------------------------------------

<51a:close_info_elem_list>
		= <51b:close_info_elem> ;

*******************************************************************************

<51b:close_info_elem>
		= UNIT  =  <56:unit_identifier> ;

*------------------------------------------------------------------------------

<51b:close_info_elem>
		= ERR  =  <110b:label_ref> ;

*------------------------------------------------------------------------------

<51b:close_info_elem>
		= STATUS  =  <82a:character_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<51b:close_info_elem>
		= IOSTAT  =  <88a:variable_or_array_element_name> ;

*******************************************************************************

* A inquire info list must contain exactly one unit_identifier.
* Each info_elem must appear at most one time.

<52:inquire_statement>
		= INQUIRE  ( <52a:inquire_info_elem_list> ) ;

*******************************************************************************

<52a:inquire_info_elem_list>
		= <52a:inquire_info_elem_list> ,  <52b:inquire_info_elem> ;

*------------------------------------------------------------------------------

<52a:inquire_info_elem_list>
		= <56:unit_identifier> ;

*------------------------------------------------------------------------------

<52a:inquire_info_elem_list>
		= <52b:inquire_info_elem> ;

*******************************************************************************

<52b:inquire_info_elem>
		= UNIT =   <56:unit_identifier> ;

*------------------------------------------------------------------------------

<52b:inquire_info_elem>
		= FILE  =  <82a:character_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<52b:inquire_info_elem>
		= ERR  =  <110b:label_ref> ;

*------------------------------------------------------------------------------

<52b:inquire_info_elem>
		= <52c:inquire_info_key>  =  <88a:variable_or_array_element_name> ;

*******************************************************************************

<52c:inquire_info_key>
		= IOSTAT ;

*------------------------------------------------------------------------------

<52c:inquire_info_key>
		= EXIST ;

*------------------------------------------------------------------------------

<52c:inquire_info_key>
		= OPENED ;

*------------------------------------------------------------------------------

<52c:inquire_info_key>
		= NUMBER ;

*------------------------------------------------------------------------------

<52c:inquire_info_key>
		= NAMED ;

*------------------------------------------------------------------------------

<52c:inquire_info_key>
		= NAME ;

*------------------------------------------------------------------------------

<52c:inquire_info_key>
		= ACCESS ;

*------------------------------------------------------------------------------

<52c:inquire_info_key>
		= SEQUENTIAL ;

*------------------------------------------------------------------------------

<52c:inquire_info_key>
		= DIRECT ;

*------------------------------------------------------------------------------

<52c:inquire_info_key>
		= FORM ;

*------------------------------------------------------------------------------

<52c:inquire_info_key>
		= FORMATTED ;

*------------------------------------------------------------------------------

<52c:inquire_info_key>
		= UNFORMATTED ;

*------------------------------------------------------------------------------

<52c:inquire_info_key>
		= RECL ;

*------------------------------------------------------------------------------

<52c:inquire_info_key>
		= NEXTREC ;

*------------------------------------------------------------------------------

<52c:inquire_info_key>
		= BLANK ;

*******************************************************************************

* BACKSPACE statement must contain a unit identifier.
* Each backspace_or_endfile_or_rewind_info_elem must appear at most one time.
* Each keyword BACKSPACE, ENDFILE, or REWIND is BACKSPACEkw, ENDFILEkw, or REWINDkw
* if it is not followed by a well-balanced expression followed by EOL.

<53:backspace_statement>
		= BACKSPACEkw  <56:unit_identifier> ;

*------------------------------------------------------------------------------

<53:backspace_statement>
		= BACKSPACE  ( <53a:backspace_or_endfile_or_rewind_info_elem_list> ) ;

*******************************************************************************

<53a:backspace_or_endfile_or_rewind_info_elem_list>
		= <53a:backspace_or_endfile_or_rewind_info_elem_list> ,  <53b:backspace_or_endfile_or_rewind_info_elem> ;

*------------------------------------------------------------------------------

<53a:backspace_or_endfile_or_rewind_info_elem_list>
		= <56:unit_identifier> ;

*------------------------------------------------------------------------------

<53a:backspace_or_endfile_or_rewind_info_elem_list>
		= <53b:backspace_or_endfile_or_rewind_info_elem> ;

*******************************************************************************

<53b:backspace_or_endfile_or_rewind_info_elem>
		= UNIT  =  <56:unit_identifier> ;

*------------------------------------------------------------------------------

<53b:backspace_or_endfile_or_rewind_info_elem>
		= ERR  =  <110b:label_ref> ;

*------------------------------------------------------------------------------

<53b:backspace_or_endfile_or_rewind_info_elem>
		= IOSTAT  =  <88a:variable_or_array_element_name> ;

*******************************************************************************

* ENDFILE statement must contain a unit identifier.

<54:endfile_statement>
		= ENDFILEkw  <56:unit_identifier> ;

*------------------------------------------------------------------------------

<54:endfile_statement>
		= ENDFILE  ( <53a:backspace_or_endfile_or_rewind_info_elem_list> ) ;

*******************************************************************************

* REWIND statement must contain a unit identifier.

<55:rewind_statement>
		= REWINDkw  <56:unit_identifier> ;

*------------------------------------------------------------------------------

<55:rewind_statement>
		= REWIND  ( <53a:backspace_or_endfile_or_rewind_info_elem_list> ) ;

*******************************************************************************

* <77:integer_expr> covers <91:variable_name>, <92:array_name> and <88:array_element_name>

<56:unit_identifier>
		= <77:integer_expr> ;

*------------------------------------------------------------------------------

<56:unit_identifier>
		= <89:substring_name> ;

*------------------------------------------------------------------------------

<56:unit_identifier>
		= * ;

*******************************************************************************

* A format identifier that is a variable name or array name must be of
* type integer or character.
* Covered by <76:arithmetic_expression>

<57:format_identifier>
		= <110b:label_ref> ;

*------------------------------------------------------------------------------

* (to be tested) Covers both <99:symbolic_name> and <82:character_expression>

<57:format_identifier>
		= <82a:character_or_non_typed_expression> ;

*------------------------------------------------------------------------------

*<57:format_identifier>
*		= <99:symbolic_name> ;
*<57:format_identifier>
*		= <82:character_expression> ;

<57:format_identifier>
		= * ;

*******************************************************************************

<58:format_statement>
		= FORMAT  <59:format_specification> ;

*******************************************************************************

<59:format_specification>
		= ( ) ;

*------------------------------------------------------------------------------

<59:format_specification>
		= ( <60:fmt_specification> ) ;

*******************************************************************************

<60:fmt_specification>
		= <60a:fmt_spec_list> ;

*------------------------------------------------------------------------------

<60:fmt_specification>
		= <60b:fmt_spec_list_/:> ;

*******************************************************************************

<60a:fmt_spec_list>
		= <60a:fmt_spec_list> ,  <60c:fmt_spec> ;

*------------------------------------------------------------------------------

<60a:fmt_spec_list>
		= <60b:fmt_spec_list_/:> <60c:fmt_spec> ;

*------------------------------------------------------------------------------

<60a:fmt_spec_list>
		= <60b:fmt_spec_list_/:> ,  <60c:fmt_spec> ;

*------------------------------------------------------------------------------

<60a:fmt_spec_list>
		= <60c:fmt_spec> ;

*******************************************************************************

<60b:fmt_spec_list_/:>
		= <60b:fmt_spec_list_/:> <60d:fmt_spec_/:> ;

*------------------------------------------------------------------------------

<60b:fmt_spec_list_/:>
		= <60b:fmt_spec_list_/:> ,  <60d:fmt_spec_/:> ;

*------------------------------------------------------------------------------

<60b:fmt_spec_list_/:>
		= <60a:fmt_spec_list> ,  <60d:fmt_spec_/:> ;

*------------------------------------------------------------------------------

<60b:fmt_spec_list_/:>
		= <60d:fmt_spec_/:> ;

*******************************************************************************

<60c:fmt_spec>	= <61a:[repeat_spec]> <60e:repeatable_edit_descriptor> ;

*------------------------------------------------------------------------------

<60c:fmt_spec>	= <60h:nonrepeatable_edit_descriptor> ;

*******************************************************************************

<60d:fmt_spec_/:>
		= <61a:[repeat_spec]> <60e:repeatable_edit_descriptor> <60f:/:> ;

*------------------------------------------------------------------------------

<60d:fmt_spec_/:>
		= <60h:nonrepeatable_edit_descriptor> <60f:/:> ;

*------------------------------------------------------------------------------

<60d:fmt_spec_/:>
		= <60f:/:> ;

*******************************************************************************

<60e:repeatable_edit_descriptor>
		= ( <60:fmt_specification> ) ;

*------------------------------------------------------------------------------

<60e:repeatable_edit_descriptor>
		= I <62:w> ;

*------------------------------------------------------------------------------

<60e:repeatable_edit_descriptor>
		= I <62:w> . <67:m> ;

*------------------------------------------------------------------------------

<60e:repeatable_edit_descriptor>
		= A ;

*------------------------------------------------------------------------------

<60e:repeatable_edit_descriptor>
		= A <62:w> ;

*------------------------------------------------------------------------------

<60e:repeatable_edit_descriptor>
		= L <62:w> ;

*------------------------------------------------------------------------------

<60e:repeatable_edit_descriptor>
		= <60g:float_editing> ;

*******************************************************************************

<60h:nonrepeatable_edit_descriptor>
		= <68:k> P ;

*------------------------------------------------------------------------------

<60h:nonrepeatable_edit_descriptor>
		= <68:k> P <61a:[repeat_spec]> <60g:float_editing> ;

*------------------------------------------------------------------------------

<60h:nonrepeatable_edit_descriptor>
		= P ;

*------------------------------------------------------------------------------

<60h:nonrepeatable_edit_descriptor>
		= P <61a:[repeat_spec]> <60g:float_editing> ;

*------------------------------------------------------------------------------

<60h:nonrepeatable_edit_descriptor>
		= <109:character_constant> ;

*------------------------------------------------------------------------------

<60h:nonrepeatable_edit_descriptor>
		= T <65:c> ;

*------------------------------------------------------------------------------

<60h:nonrepeatable_edit_descriptor>
		= T L <65:c> ;

*------------------------------------------------------------------------------

<60h:nonrepeatable_edit_descriptor>
		= T R <65:c> ;

*------------------------------------------------------------------------------

<60h:nonrepeatable_edit_descriptor>
		= <64:n> X ;

*------------------------------------------------------------------------------

<60h:nonrepeatable_edit_descriptor>
		= S ;

*------------------------------------------------------------------------------

<60h:nonrepeatable_edit_descriptor>
		= S P ;

*------------------------------------------------------------------------------

<60h:nonrepeatable_edit_descriptor>
		= S S ;

*------------------------------------------------------------------------------

<60h:nonrepeatable_edit_descriptor>
		= B N ;

*------------------------------------------------------------------------------

<60h:nonrepeatable_edit_descriptor>
		= B Z ;

*******************************************************************************

<60f:/:>	= / ;

*------------------------------------------------------------------------------

* En Fortran, il y a deux terminaux '/' et '//'.  Malheureusement, dans le cas 
* <19b:common_part>, un source peut comporter une sequence '/' '/' ou meme,
* dans le cas <60b:fmt_spec_list_/:>, une séquence de '/' ... '/' de longueur 
* indeterminee. Comme les blancs ne jouent aucun role, le scanner peut se
* retrouver avec des sequences de slashs de longueur quelconque. 
* L'interpretation choisie assure qu'un slash rend '/', que deux slashs
* rendent '//' et, plus generalement 2n(+1) slashs rendent n '//' suivis de
* '/'. La grammaire BNF a donc ete modifiee pour accepter le token '//'
* (plutot que '/' '/'). Noter que, lors de l'analyse du texte source '//', le
* scanner retourne '//' (et non pas '/' '/') car f77.lecl contient la regle :
*    "/" = -"/" ; Priority Shift > Reduce;

<60f:/:>	= // ;

*------------------------------------------------------------------------------

<60f:/:>	= : ;

*******************************************************************************

<60g:float_editing>
		= F <62:w> . <66:d> ;

*------------------------------------------------------------------------------

<60g:float_editing>
		= D <62:w> . <66:d> ;

*------------------------------------------------------------------------------

<60g:float_editing>
		= E <62:w> . <66:d> ;

*------------------------------------------------------------------------------

<60g:float_editing>
		= E <62:w> . <66:d> E <63:e> ;

*------------------------------------------------------------------------------

<60g:float_editing>
		= G <62:w> . <66:d> ;

*------------------------------------------------------------------------------

<60g:float_editing>
		= G <62:w> . <66:d> E <63:e> ;

*******************************************************************************

*<61:repeat_spec>
*		= <103:nonzero_unsigned_int_constant> ;

*------------------------------------------------------------------------------

<61:repeat_spec>
		= %repeat_spec ;

*******************************************************************************

<61a:[repeat_spec]>
		= ;

*------------------------------------------------------------------------------

<61a:[repeat_spec]>
		= <61:repeat_spec> ;

*******************************************************************************

*<62:w>		= <103:nonzero_unsigned_int_constant> ;

<62:w>		= %repeat_spec ;

*******************************************************************************

*<63:e>		= <103:nonzero_unsigned_int_constant> ;

<63:e>		= %repeat_spec ;

*******************************************************************************

*<64:n>		= <103:nonzero_unsigned_int_constant> ;

<64:n>		= %repeat_spec ;

*******************************************************************************

*<65:c>		= <103:nonzero_unsigned_int_constant> ;

<65:c>		= %repeat_spec ;

*******************************************************************************

*<66:d>		= <102:unsigned_int_constant> ;

<66:d>		= %repeat_spec ;

*******************************************************************************

*<67:m>		= <102:unsigned_int_constant> ;

<67:m>		= %repeat_spec ;

*******************************************************************************

*<68:k>		= <104:integer_constant> ;

<68:k>		= %repeat_spec ;

*------------------------------------------------------------------------------

<68:k>		= <114:sign> %repeat_spec ;

*******************************************************************************

*<69:h>		= <111:processor_character> ;

*******************************************************************************

<70:statement_function_statement>
		= <99:symbolic_name>  ( )  =  <74:expression> ;

*------------------------------------------------------------------------------

* Covered by <29:assignment_statement>
*<70:statement_function_statement>
*		= <99:symbolic_name>  ( <99a:symbolic_name_list> )  =  <74:expression> ;

*******************************************************************************

<71:call_statement>
		= CALL  <99:symbolic_name> ;

*------------------------------------------------------------------------------

<71:call_statement>
		= CALL  <99:symbolic_name>  ( ) ;

*------------------------------------------------------------------------------

<71:call_statement>
		= CALL  <99:symbolic_name>  ( <71a:actual_argument_list> ) ;

*******************************************************************************

<71a:actual_argument_list>
		= <71a:actual_argument_list> ,  <71b:actual_argument> ;

*------------------------------------------------------------------------------

<71a:actual_argument_list>
		= <71b:actual_argument> ;

*******************************************************************************

<71b:actual_argument>
		= <74:expression> ;

*------------------------------------------------------------------------------

* Subsumed by <74:expression>
*<71b:actual_argument>
*		= <99:symbolic_name> ;

*------------------------------------------------------------------------------

<71b:actual_argument>
		= * <110b:label_ref> ;

*******************************************************************************

* An alternate return is not allowed in a function subprogram.

<72:return_statement>
		= RETURN ;

*------------------------------------------------------------------------------

<72:return_statement>
		= RETURN  <77:integer_expr> ;

*******************************************************************************

* Covered by <88b:function_reference_or_array_element_name>
*<73:function_reference>
*		= <98:function_name>  ( [<74:expression> {, <74:expression>}] ) ;

*******************************************************************************

<74:expression>	= <76:arithmetic_expression> ;

*------------------------------------------------------------------------------

<74:expression>	= <82:character_expression> ;

*------------------------------------------------------------------------------

<74:expression>	= <84:logical_expression> ;

*------------------------------------------------------------------------------

<74:expression>	= <74a:non_typed_expression> ;

*******************************************************************************

<74a:non_typed_expression>
		= <99:symbolic_name> ;

*------------------------------------------------------------------------------

<74a:non_typed_expression>
		= <88b:function_reference_or_array_element_name> ;

*------------------------------------------------------------------------------

<74a:non_typed_expression>
		= ( <74a:non_typed_expression> ) ;

*******************************************************************************

<74b:expression_list>
		= <74b:expression_list> ,  <74:expression> ;

*------------------------------------------------------------------------------

<74b:expression_list>
		= <74:expression> ;

*******************************************************************************

<75:constant_expr>
		= <79:arithmetic_const_expr> ;

*------------------------------------------------------------------------------

<75:constant_expr>
		= <83:character_const_expr> ;

*------------------------------------------------------------------------------

<75:constant_expr>
		= <85:logical_const_expr> ;

*------------------------------------------------------------------------------

<75:constant_expr>
		= <75a:non_typed_const_expr> ;

*******************************************************************************

<75a:non_typed_const_expr>
		= <99:symbolic_name> ;

*------------------------------------------------------------------------------

<75a:non_typed_const_expr>
		=  ( <75a:non_typed_const_expr> ) ;

*******************************************************************************

* A constant name, variable name, array element name, or function reference in an
* arithmetic expression must be of type integer, real, double precision, or complex.
* Tables 2 and 3 (6.1.4) list prohibited combinations involving operand of type complex.

<76:arithmetic_expression>
		= <114:sign> <76b:arithmetic_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<76:arithmetic_expression>
		= <76a:arithmetic_expression> ;

*******************************************************************************

<76a:arithmetic_expression>
		= <76b:arithmetic_or_non_typed_expression> + <76b:arithmetic_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<76a:arithmetic_expression>
		= <76b:arithmetic_or_non_typed_expression> - <76b:arithmetic_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<76a:arithmetic_expression>
		= <76b:arithmetic_or_non_typed_expression> * <76b:arithmetic_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<76a:arithmetic_expression>
		= <76b:arithmetic_or_non_typed_expression> / <76b:arithmetic_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<76a:arithmetic_expression>
		= <76b:arithmetic_or_non_typed_expression> ** <76b:arithmetic_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<76a:arithmetic_expression>
		= <101:unsigned_arithmetic_constant> ;

*------------------------------------------------------------------------------

<76a:arithmetic_expression>
		= ( <76:arithmetic_expression> ) ;

*******************************************************************************

<76b:arithmetic_or_non_typed_expression>
		= <76a:arithmetic_expression> ;

*------------------------------------------------------------------------------

<76b:arithmetic_or_non_typed_expression>
		= <74a:non_typed_expression> ;

*******************************************************************************

* An integer expression is an arithmetic expression of type integer.

<77:integer_expr>
		= <76:arithmetic_expression> ;

*------------------------------------------------------------------------------

<77:integer_expr>
		= <74a:non_typed_expression> ;

*******************************************************************************

<77a:integer_const_expr>
		= <79:arithmetic_const_expr> ;

*------------------------------------------------------------------------------

<77a:integer_const_expr>
		= <75a:non_typed_const_expr> ;

*******************************************************************************

<77b:[integer_expr]>
		= <77:integer_expr> ;

*------------------------------------------------------------------------------

<77b:[integer_expr]>
		= ;

*******************************************************************************

* An int_real_dp_expression is an arithmetic expression of type integer,
* real, or double precision.

<78:int_real_dp_expr>
		= <77:integer_expr> ;

*******************************************************************************

* A constant name in an arithmetic constant expression must be of type integer,
* real, or complex.
* Tables 2 and 3 (6.1.4) list prohibited combinations involving operand of type complex.
* The right hand operand (the exponent) of the ** operator must be of type integer.

<79:arithmetic_const_expr>
		= <114:sign> <79b:arithmetic_or_non_typed_const_expr> ;

*------------------------------------------------------------------------------

<79:arithmetic_const_expr>
		= <79a:arithmetic_const_expr> ;

*******************************************************************************

<79a:arithmetic_const_expr>
		= <79b:arithmetic_or_non_typed_const_expr> + <79b:arithmetic_or_non_typed_const_expr> ;

*------------------------------------------------------------------------------

<79a:arithmetic_const_expr>
		= <79b:arithmetic_or_non_typed_const_expr> - <79b:arithmetic_or_non_typed_const_expr> ;

*------------------------------------------------------------------------------

<79a:arithmetic_const_expr>
		= <79b:arithmetic_or_non_typed_const_expr> * <79b:arithmetic_or_non_typed_const_expr> ;

*------------------------------------------------------------------------------

<79a:arithmetic_const_expr>
		= <79b:arithmetic_or_non_typed_const_expr> / <79b:arithmetic_or_non_typed_const_expr> ;

*------------------------------------------------------------------------------

<79a:arithmetic_const_expr>
		= <79b:arithmetic_or_non_typed_const_expr> ** <79b:arithmetic_or_non_typed_const_expr> ;

*------------------------------------------------------------------------------

<79a:arithmetic_const_expr>
		= <101:unsigned_arithmetic_constant> ;

*------------------------------------------------------------------------------

<79a:arithmetic_const_expr>
		= ( <79:arithmetic_const_expr> ) ;

*******************************************************************************

<79b:arithmetic_or_non_typed_const_expr>
		= <79a:arithmetic_const_expr> ;

*------------------------------------------------------------------------------

<79b:arithmetic_or_non_typed_const_expr>
		= <75a:non_typed_const_expr> ;

*******************************************************************************

* A constant name in an integer constant expression must be of type integer.

<80:int_constant_expr>
		= <114:sign> <80a:int_constant_expr> ;

*------------------------------------------------------------------------------

<80:int_constant_expr>
		= <80a:int_constant_expr> ;

*******************************************************************************

<80a:int_constant_expr>
		= <80a:int_constant_expr> + <80a:int_constant_expr> ;

*------------------------------------------------------------------------------

<80a:int_constant_expr>
		= <80a:int_constant_expr> - <80a:int_constant_expr> ;

*------------------------------------------------------------------------------

<80a:int_constant_expr>
		= <80a:int_constant_expr> * <80a:int_constant_expr> ;

*------------------------------------------------------------------------------

<80a:int_constant_expr>
		= <80a:int_constant_expr> / <80a:int_constant_expr> ;

*------------------------------------------------------------------------------

<80a:int_constant_expr>
		= <80a:int_constant_expr> ** <80a:int_constant_expr> ;

*------------------------------------------------------------------------------

<80a:int_constant_expr>
		= <102:unsigned_int_constant> ;

*------------------------------------------------------------------------------

<80a:int_constant_expr>
		= <99:symbolic_name> ;

*------------------------------------------------------------------------------

<80a:int_constant_expr>
		= ( <80:int_constant_expr> ) ;

*******************************************************************************

* Each variable name in a dimension bound expression must be of type integer and
* must be a dummy argument or in a common block.

<81:dim_bound_expr>
		= <80:int_constant_expr> ;

*------------------------------------------------------------------------------

*<81:dim_bound_expr>
*		= <114:sign> <81a:dim_bound_expr> ;

*------------------------------------------------------------------------------

*<81:dim_bound_expr>
*		= <81a:dim_bound_expr> ;

*******************************************************************************

*<81a:dim_bound_expr>
*		= <81a:dim_bound_expr> + <81a:dim_bound_expr> ;
*<81a:dim_bound_expr>
*		= <81a:dim_bound_expr> - <81a:dim_bound_expr> ;
*<81a:dim_bound_expr>
*		= <81a:dim_bound_expr> * <81a:dim_bound_expr> ;
*<81a:dim_bound_expr>
*		= <81a:dim_bound_expr> / <81a:dim_bound_expr> ;
*<81a:dim_bound_expr>
*		= <81a:dim_bound_expr> ** <81a:dim_bound_expr> ;
*<81a:dim_bound_expr>
*		= <102:unsigned_int_constant> ;
*<81a:dim_bound_expr>
*		= <99:symbolic_name> ;
*<81a:dim_bound_expr>
*		= ( <81:dim_bound_expr> ) ;

*******************************************************************************

* A constant name, variable name, array element name, or function reference
* must be of type character in a character expression.

<82:character_expression>
		= <82a:character_or_non_typed_expression> // <82a:character_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<82:character_expression>
		= <109:character_constant> ;

*------------------------------------------------------------------------------

<82:character_expression>
		= <89:substring_name> ;

*------------------------------------------------------------------------------

<82:character_expression>
		= ( <82:character_expression> ) ;

*******************************************************************************

<82a:character_or_non_typed_expression>
		= <82:character_expression> ;

*------------------------------------------------------------------------------

<82a:character_or_non_typed_expression>
		= <74a:non_typed_expression> ;

*******************************************************************************

* A constant name must be of type character in a character constant expression.

<83:character_const_expr>
		= <83:character_const_expr> // <83:character_const_expr> ;

*------------------------------------------------------------------------------

<83:character_const_expr>
		= <109:character_constant> ;

*------------------------------------------------------------------------------

* Done by the outside world
*<83:character_const_expr>
*		= <99:symbolic_name> ;

*------------------------------------------------------------------------------

<83:character_const_expr>
		= ( <83:character_const_expr> ) ;

*******************************************************************************

* A constant name, variable name, array element name, or function reference
* must be of type logical in a logical expression.

<84:logical_expression>
		= <84b:logical_or_non_typed_expression>  .AND.  <84b:logical_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<84:logical_expression>
		= <84b:logical_or_non_typed_expression>  .OR.  <84b:logical_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<84:logical_expression>
		= <84b:logical_or_non_typed_expression>  .EQV.  <84b:logical_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<84:logical_expression>
		= <84b:logical_or_non_typed_expression>  .NEQV.  <84b:logical_or_non_typed_expression> ;

*------------------------------------------------------------------------------

<84:logical_expression>
		= <84c:logical_factor> ;

*******************************************************************************

<84c:logical_factor>
		= <84d:logical_primary> ;

*------------------------------------------------------------------------------

<84c:logical_factor>
		= .NOT.  <84e:logical_or_non_typed_primary> ;

*******************************************************************************

<84d:logical_primary>
		= <108:logical_constant> ;

*------------------------------------------------------------------------------

<84d:logical_primary>
		= <86:relational_expression> ;

*------------------------------------------------------------------------------

<84d:logical_primary>
		= ( <84:logical_expression> ) ;

*******************************************************************************

<84b:logical_or_non_typed_expression>
		= <84:logical_expression> ;

*------------------------------------------------------------------------------

<84b:logical_or_non_typed_expression>
		= <74a:non_typed_expression> ;

*******************************************************************************

<84e:logical_or_non_typed_primary>
		= <84d:logical_primary> ;

*------------------------------------------------------------------------------

<84e:logical_or_non_typed_primary>
		= <74a:non_typed_expression> ;

*******************************************************************************

* A constant name must be of type logical in a logical constant expression.
* Also, each primary in the relational expression must be a constant expression

<85:logical_const_expr>
		= <85b:logical_or_non_typed_const_expr>  .AND.  <85b:logical_or_non_typed_const_expr> ;

*------------------------------------------------------------------------------

<85:logical_const_expr>
		= <85b:logical_or_non_typed_const_expr>  .OR.  <85b:logical_or_non_typed_const_expr> ;

*------------------------------------------------------------------------------

<85:logical_const_expr>
		= <85b:logical_or_non_typed_const_expr>  .EQV.  <85b:logical_or_non_typed_const_expr> ;

*------------------------------------------------------------------------------

<85:logical_const_expr>
		= <85b:logical_or_non_typed_const_expr>  .NEQV.  <85b:logical_or_non_typed_const_expr> ;

*------------------------------------------------------------------------------

<85:logical_const_expr>
		= <85c:logical_const_fact> ;

*******************************************************************************

<85c:logical_const_fact>
		= <85d:logical_const_prim> ;

*------------------------------------------------------------------------------

<85c:logical_const_fact>
		= .NOT. <85e:logical_or_non_typed_const_prim> ;

*******************************************************************************

<85d:logical_const_prim>
		= <108:logical_constant> ;

*------------------------------------------------------------------------------

<85d:logical_const_prim>
		= <86a:relational_const_expr> ;

*------------------------------------------------------------------------------

<85d:logical_const_prim>
		= ( <85:logical_const_expr> ) ;

*******************************************************************************

<85b:logical_or_non_typed_const_expr>
		= <85:logical_const_expr> ;

*------------------------------------------------------------------------------

<85b:logical_or_non_typed_const_expr>
		= <75a:non_typed_const_expr> ;

*******************************************************************************

<85e:logical_or_non_typed_const_prim>
		= <85d:logical_const_prim> ;

*------------------------------------------------------------------------------

<85e:logical_or_non_typed_const_prim>
		= <75a:non_typed_const_expr> ;

*******************************************************************************

* An arithmetic expression of type complex is permitted only when the relational
* operator id .EQ. or .NE.

<86:relational_expression>
		= <86b:arithmetic_or_character_expression>  <87:rel_op>  <86b:arithmetic_or_character_expression> ;

*------------------------------------------------------------------------------

*<86:relational_expression>
*		= <76:arithmetic_expression> <87:rel_op> <76:arithmetic_expression> ;
*<86:relational_expression>
*		= <76:arithmetic_expression> <87:rel_op> <74a:non_typed_expression> ;
*<86:relational_expression>
*		= <82:character_expression> <87:rel_op> <82:character_expression> ;
*<86:relational_expression>
*		= <82:character_expression> <87:rel_op> <74a:non_typed_expression> ;
*<86:relational_expression>
*		= <74a:non_typed_expression> <87:rel_op> <76:arithmetic_expression> ;
*<86:relational_expression>
*		= <74a:non_typed_expression> <87:rel_op> <74a:non_typed_expression> ;
*<86:relational_expression>
*		= <74a:non_typed_expression> <87:rel_op> <82:character_expression> ;

*******************************************************************************

<86a:relational_const_expr>
		= <86c:arithmetic_or_character_const_expr> <87:rel_op> <86c:arithmetic_or_character_const_expr> ;

*------------------------------------------------------------------------------

*<86a:relational_const_expr>
*		= <79:arithmetic_const_expr> <87:rel_op> <79:arithmetic_const_expr> ;
*<86a:relational_const_expr>
*		= <79:arithmetic_const_expr> <87:rel_op> <75a:non_typed_const_expr> ;
*<86a:relational_const_expr>
*		= <83:character_const_expr> <87:rel_op> <83:character_const_expr> ;
*<86a:relational_const_expr>
*		= <83:character_const_expr> <87:rel_op> <75a:non_typed_const_expr> ;
*<86a:relational_const_expr>
*		= <75a:non_typed_const_expr> <87:rel_op> <79:arithmetic_const_expr> ;
*<86a:relational_const_expr>
*		= <75a:non_typed_const_expr> <87:rel_op> <75a:non_typed_const_expr> ;
*<86a:relational_const_expr>
*		= <75a:non_typed_const_expr> <87:rel_op> <83:character_const_expr> ;

*******************************************************************************

<86b:arithmetic_or_character_expression>
		= <77:integer_expr> ;

*------------------------------------------------------------------------------

<86b:arithmetic_or_character_expression>
		= <82:character_expression> ;

*******************************************************************************

<86c:arithmetic_or_character_const_expr>
		= <77a:integer_const_expr> ;

*------------------------------------------------------------------------------

<86c:arithmetic_or_character_const_expr>
		= <83:character_const_expr> ;

*******************************************************************************

<87:rel_op>	= .LT. ;

*------------------------------------------------------------------------------

<87:rel_op>	= .LE. ;

*------------------------------------------------------------------------------

<87:rel_op>	= .EQ. ;

*------------------------------------------------------------------------------

<87:rel_op>	= .NE. ;

*------------------------------------------------------------------------------

<87:rel_op>	= .GT. ;

*------------------------------------------------------------------------------

<87:rel_op>	= .GE. ;

*******************************************************************************

* At most 7 integer_expr are allowed as indexes

<88:array_element_name>
		= <99:symbolic_name>  ( <74b:expression_list> ) ;

*******************************************************************************

<88b:function_reference_or_array_element_name>
		= <88:array_element_name> ;

*------------------------------------------------------------------------------

<88b:function_reference_or_array_element_name>
		= <99:symbolic_name>  ( ) ;

*******************************************************************************

<88a:variable_or_array_element_name>
		= <99:symbolic_name> ;

*------------------------------------------------------------------------------

<88a:variable_or_array_element_name>
		= <88b:function_reference_or_array_element_name> ;

*******************************************************************************

* The lower bound <77b:[integer_expr]> is covered by <74:expression>

<89:substring_name>
		= <99:symbolic_name>  ( <74:expression>  :  <77b:[integer_expr]> ) ;

*------------------------------------------------------------------------------

<89:substring_name>
		= <99:symbolic_name>  ( :  <77b:[integer_expr]> ) ;

*------------------------------------------------------------------------------

<89:substring_name>
		= <88b:function_reference_or_array_element_name>  ( <77b:[integer_expr]>  :  <77b:[integer_expr]> ) ;

*******************************************************************************

*<90:constant_name>
*		= <99:symbolic_name> ;
*<91:variable_name>
*		= <99:symbolic_name> ;
*<92:array_name>
*		= <99:symbolic_name> ;
*<93:common_block_name>
*		= <99:symbolic_name> ;
*<94:program_name>
*		= <99:symbolic_name> ;
*<95:block_data_subprogram_name>
*		= <99:symbolic_name> ;
*<96:procedure_name>
*		= <97:subroutine_name> ;
*<96:procedure_name>
*		= <98:function_name> ;
*<97:subroutine_name>
*		= <99:symbolic_name> ;
*<98:function_name>
*		= <99:symbolic_name> ;

*******************************************************************************

<99:symbolic_name> 
		= %symbolic_name ;

*------------------------------------------------------------------------------

<99:symbolic_name> 
		= THEN ;

*******************************************************************************

<99a:symbolic_name_list>
		= <99a:symbolic_name_list> ,  <99:symbolic_name> ;

*------------------------------------------------------------------------------

<99a:symbolic_name_list>
		= <99:symbolic_name> ;

*******************************************************************************

<100:constant>	= <101:unsigned_arithmetic_constant> ;

*------------------------------------------------------------------------------

<100:constant>	= <114:sign> <101:unsigned_arithmetic_constant> ;

*------------------------------------------------------------------------------

<100:constant>	= <109:character_constant> ;

*------------------------------------------------------------------------------

<100:constant>	= <108:logical_constant> ;

*******************************************************************************

<101:unsigned_arithmetic_constant>
		= <102:unsigned_int_constant> ;

*------------------------------------------------------------------------------

<101:unsigned_arithmetic_constant>
		= <105:unsigned_real_constant> ;

*------------------------------------------------------------------------------

<101:unsigned_arithmetic_constant>
		= <106:unsigned_dp_constant> ;

*------------------------------------------------------------------------------

<101:unsigned_arithmetic_constant>
		= <107:complex_constant> ;

*******************************************************************************

<102:unsigned_int_constant>
		= %unsigned_int_constant ;

*******************************************************************************

<103:nonzero_unsigned_int_constant>
		= %unsigned_int_constant ;

*******************************************************************************

*<104:integer_constant>
*		= <114:sign> %unsigned_int_constant ;
*<104:integer_constant>
*		= %unsigned_int_constant ;

*******************************************************************************

<105:unsigned_real_constant>
		= %unsigned_real_constant ;

*******************************************************************************

<106:unsigned_dp_constant>
		= %unsigned_dp_constant ;

*******************************************************************************

<107:complex_constant>
		= ( <107a:real_part> ,  <107b:complex_part> ) ;

*******************************************************************************

<107a:real_part>
		= <105:unsigned_real_constant> ;

*------------------------------------------------------------------------------

<107a:real_part>
		= <102:unsigned_int_constant> ;

*------------------------------------------------------------------------------

<107a:real_part>
		= <114:sign> <105:unsigned_real_constant> ;

*------------------------------------------------------------------------------

<107a:real_part>
		= <114:sign> <102:unsigned_int_constant> ;

*******************************************************************************

<107b:complex_part>
		= <107a:real_part> ;

*******************************************************************************

<108:logical_constant>
		= .TRUE. ;

*------------------------------------------------------------------------------

<108:logical_constant>
		= .FALSE. ;

*******************************************************************************

<109:character_constant>
		= %character_constant ;

*******************************************************************************

* At most 5 digits are allowed in a label or in a label_ref
<110:label>	= %label ;

*******************************************************************************

<110a:label_ref_list>
		= <110a:label_ref_list> ,  <110b:label_ref> ;

*------------------------------------------------------------------------------

<110a:label_ref_list>
		= <110b:label_ref> ;

*******************************************************************************

<110b:label_ref>
		= %unsigned_int_constant ;

*******************************************************************************

*<111:processor_character>
*		= <112:apostrophe> ;
*<111:processor_character>
*		= <113:nonapostrophe_character> ;

*******************************************************************************

*<112:apostrophe>
*		= ' ;

*******************************************************************************

*<113:nonapostrophe_character>
*		= <114:sign> ;
*<113:nonapostrophe_character>
*		= <115:digit> ;
*<113:nonapostrophe_character>
*		= <116:letter> ;
*<113:nonapostrophe_character>
*		= * ;
*<113:nonapostrophe_character>
*		= / ;
*<113:nonapostrophe_character>
*		= ( ;
*<113:nonapostrophe_character>
*		= ) ;
*<113:nonapostrophe_character>
*		= , ;
*<113:nonapostrophe_character>
*		= . ;
*<113:nonapostrophe_character>
*		= : ;
*<113:nonapostrophe_character>
*		= + ;
*<113:nonapostrophe_character>
*		= $ ;
*<113:nonapostrophe_character>
*		= " " ;

*******************************************************************************

<114:sign>	= + ;

*------------------------------------------------------------------------------

<114:sign>	= - ;

*******************************************************************************

*<115:digit>	= 0 ;
*<115:digit>	= 1 ;
*<115:digit>	= 2 ;
*<115:digit>	= 3 ;
*<115:digit>	= 4 ;
*<115:digit>	= 5 ;
*<115:digit>	= 6 ;
*<115:digit>	= 7 ;
*<115:digit>	= 8 ;
*<115:digit>	= 9 ;

*******************************************************************************

*<116:letter>	= A ;
*<116:letter>	= B ;
*<116:letter>	= C ;
*<116:letter>	= D ;
*<116:letter>	= E ;
*<116:letter>	= F ;
*<116:letter>	= G ;
*<116:letter>	= H ;
*<116:letter>	= I ;
*<116:letter>	= J ;
*<116:letter>	= K ;
*<116:letter>	= L ;
*<116:letter>	= M ;
*<116:letter>	= N ;
*<116:letter>	= O ;
*<116:letter>	= P ;
*<116:letter>	= Q ;
*<116:letter>	= R ;
*<116:letter>	= S ;
*<116:letter>	= T ;
*<116:letter>	= U ;
*<116:letter>	= V ;
*<116:letter>	= W ;
*<116:letter>	= X ;
*<116:letter>	= Y ;
*<116:letter>	= Z ;

*******************************************************************************

