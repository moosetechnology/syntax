/******************************************************************************
 *                                S Y N T A X
 *-----------------------------------------------------------------------------
 *   Copyright (C) 1972-2023 INRIA (Institut National de Recherche en
 *   Informatique et Automatique)
 *-----------------------------------------------------------------------------
 *   URL: http://sourcesup.renater.fr/projects/syntax
 *-----------------------------------------------------------------------------
 *   The source code of SYNTAX is distributed with two different licenses,
 *   depending on the files:
 *   - The recursive content of src/ and incl/ and the non-recursive content
 *     of SYNTAX's root directory are distributed under the CeCILL-C license
 *   - The recursive content of all other repertories is distributed under
 *     the CeCILL license
 *   All code produced by SYNTAX must be considered as being under the
 *   CeCILL-C license. Information about the CeCILL and CeCILL-C licenses
 *   can be found at, e.g., http://www.cecill.info
 *****************************************************************************/

/*** THIS FILE IS NOT PART OF THE SYNTAX LIBRARY libsx.a ***/ 

/* Main module for "make_tdef" a SYNTAX module similar to tdef which accepts the
   same input as tdef.
   It must be used instead of tdef when the input BNF is "huge".
   In that case the ".bt" tables are not generated (and thus tdef cannot work at all).
   This module must be [re]compiled for each new LC_TABLES_H (which are the GG.h C data)
   generated by
   bnf -nsc -nls -h GG.bnf > ../incl/GG.h
*/

static char	ME [] = "make_tdef_main";

/*   I N C L U D E S   */

#include "sxversion.h"
#include "sxunix.h"
#include "fsa.h"

char WHAT_TDEFMAKETDEFMAIN[] = "@(#)SYNTAX - $Id: make_tdef_main.c 4349 2024-09-19 14:16:45Z garavel $" WHAT_DEBUG;

#define SX_DFN_EXT_VAR2
#include "udag_scanner.h"

/* Rappel : les tables "LC_TABLES_H", synonymes de L_huge.h ont été produites  
par la commande
   bnf -huge L.bnf > ../incl/L_huge.h  */
/* On compile ces tables "left_corner" ... */
/* ... uniquement celles dont on va avoir besoin :
 Par exemple, si on ne veut pas de "lispro" on spécifie :
#define def_lispro
*/

#define def_sxdfa_comb_non_terminal_names
#define def_sxdfa_comb_inflected_form

#include LC_TABLES_H

/* Conserver ce commentaire (et le #if 0)!!
   Attention depuis le 17/01/08 le dictionnaire des terminaux est sous la forme d'un sxdfa_comb (voir "fsa.h") et
   non plus sous la forme d'un sxword */
#if 0
#include "sxword.h"
#endif /* 0 */


/* extern */ SXTABLES  sxtables;


/*  S T A T I C     V A R I A B L E S   */
static bool	is_help,is_error;
static char	**err_titles;


/*---------------*/
/*    options    */
/*---------------*/

static char	Usage [] = "\
Usage:\t%s [options] [file]\n\
options=\t--help,\n\
\t\t-v, -verbose,\n\
";

#define OPTION(opt)	(1 << (opt - 1))
#define noOPTION(opt)	(~OPTION (opt))

#define OPT_NB ((sizeof(option_tbl)/sizeof(*option_tbl))-1)

#define UNKNOWN_ARG 	  0
#define HELP	          1
#define VERBOSE		  2
#define SOURCE_FILE	  3
#define STDIN	          4


static char	*option_tbl [] = {
    "",
    "-help",  
    "v", "verbose",
};

static SXINT	option_kind [] = {
    UNKNOWN_ARG,
    HELP,
    VERBOSE, VERBOSE,
};



static SXINT	option_get_kind (char *arg)
{
  char	**opt;

  if (*arg++ != '-')
    return SOURCE_FILE;

  if (*arg == SXNUL)
    return STDIN;

  for (opt = &(option_tbl [OPT_NB]); opt > option_tbl; opt--) {
    if (strcmp (*opt, arg) == 0 /* egalite */ )
      break;
  }

  return option_kind [opt - option_tbl];
}


#if 0
static char	*option_get_text (kind)
    SXINT	kind;
{
  SXINT	i;

  for (i = OPT_NB; i > 0; i--) {
    if (option_kind [i] == kind)
      break;
  }

  return option_tbl [i];
}
#endif /* 0 */



static void
make_tdef_run (char *pathname)
{
  FILE	*infile;

  if (pathname == NULL) {
    SXINT	c;

    if (sxverbosep) {
      fputs ("\"stdin\":\n", sxtty);
    }

    if ((infile = sxtmpfile ()) == NULL) {
      fprintf (sxstderr, "%s: Unable to create ", ME);
      sxperror ("temp file");
      sxerrmngr.nbmess [2]++;
      return;
    }

    while ((c = getchar ()) != EOF) {
      putc (c, infile);
    }

    rewind (infile);
    syntax (SXBEGIN, &sxtables, infile, "");
  }
  else {
    if ((infile = sxfopen (pathname, "r")) == NULL) {
      fprintf (sxstderr, "%s: Cannot open (read) ", ME);
      sxperror (pathname);
      sxerrmngr.nbmess [2]++;
      return;
    }
    else {
      if (sxverbosep) {
	fprintf (sxtty, "%s:\n", pathname);
      }

      syntax (SXBEGIN, &sxtables, infile, pathname);
    }
  }

  syntax (SXACTION, &sxtables);
  syntax (SXEND, &sxtables);
  fclose (infile);
}



/************************************************************************/
/* main function */
/************************************************************************/
int main (int argc, char *argv[])
{
  SXINT		argnum;
  bool	is_source_file, is_stdin;

  sxopentty ();

  /* valeurs par defaut */
  sxverbosep = false;
  is_help = false;
  is_stdin = true;
  is_source_file = false;
  
  argnum = 0;

  while (++argnum < argc) {
    switch (option_get_kind (argv [argnum])) {
    case HELP:
      is_help = true;
      break;

    case VERBOSE:
      sxverbosep = true;
      break;

    case STDIN:
      is_stdin = true;
      break;

    case SOURCE_FILE:
      is_stdin = false;
      is_source_file = true;
      source_file_name = argv [argnum];
      break;

    case UNKNOWN_ARG:
      fprintf (sxstderr, "%s: unknown option \"%s\".\n", ME, argv [argnum]);
      fprintf (sxstderr, Usage, ME);
      sxexit (3);
 
    default:
      sxtrap (ME, "unknown switch case #1");
    }
  }

  if ((!is_stdin && !is_source_file) || is_help) {
    fprintf (sxstderr, Usage, ME);
    sxexit (3);
  }


  syntax (SXINIT, &sxtables, false /* no includes */);

  make_tdef_run (is_stdin ? NULL : source_file_name);

  syntax (SXFINAL, &sxtables, true);

  sxexit (sxerr_max_severity ());
  return EXIT_SUCCESS; /* Jamais atteint !! pour les compilo susceptibles ... */
}





static void
gen_header ()
{
  printf ("\
/*   ******************************************************************************\n\
     This include tdef file for the language \"%s\" has been generated\n\
     by the SYNTAX(*) make_tdef processor\n\
     ******************************************************************************\n\
     (*) SYNTAX is a trademark of INRIA.\n\
     ****************************************************************************** */\n\n",
	  language_name);
}




void make_tdef_semact (SXINT what, SXINT action_no, SXTABLES *arg)
{
  switch (what) {
  case SXOPEN:
    err_titles = arg->err_titles;
    break;

  case SXINIT:
#if 0
    sxword_reuse (&inflected_form_names, "inflected_form_names", sxcont_malloc, sxcont_alloc, sxcont_realloc, NULL, sxcont_free, NULL, NULL);
    sxword_reuse (&non_terminal_names, "non_terminal_names", sxcont_malloc, sxcont_alloc, sxcont_realloc, NULL, sxcont_free, NULL, NULL);
#endif /* 0 */
    /* On sort un petit header et un define caracteristique de la date/heure.  Ca permet de faire des
       verifs eventuelles qui assurent que les tdef sont a jour */
    gen_header ();
    is_error = false;

    break;

  case SXACTION:
    {
      SXINT	        cas, code, tnt_name_lgth;
      char              *tnt_name;
      struct sxtoken	*tok;

      if (is_error)
	return;

      switch (cas = action_no) {
      case 0:
	return;

      case 1: /* <def>		= %T_NAME ~TAB~ =  <terminal> ~TAB~ ";"	~~ ; 1 */
      case 2: /* <def>		= %T_NAME ~TAB~ =  %NON_TERMINAL ~TAB~ ";"	~~ ; 2 */
	tok = &(SXSTACKtoken (SXSTACKtop () - 1));
	tnt_name = sxstrget (tok->string_table_entry);
	tnt_name_lgth = strlen (tnt_name);
    
	code = (cas == 1)
	  ? sxdfa_comb_seek_a_string (&sxdfa_comb_inflected_form, tnt_name, &tnt_name_lgth)
	  : sxdfa_comb_seek_a_string (&sxdfa_comb_non_terminal_names, tnt_name, &tnt_name_lgth);

	if (tnt_name_lgth != 0)
	  code = 0;

	if (code == 0)
	  sxerror (tok->source_index,
		       sxsvar.sxtables->err_titles [1][0],
		       "%sThis unknown %sterminal symbol \"%s\" is ignored.",
		       sxsvar.sxtables->err_titles [1]+1,
		       (cas == 1) ? "" : "non-",
		       tnt_name);
	else {
	  printf ("#define %s %ld\n", sxstrget (SXSTACKtoken (SXSTACKnewtop ()).string_table_entry), code);
	}

#if 0
	code = (cas == 1) ? sxword_retrieve (&inflected_form_names, tnt_name) : sxword_retrieve (&non_terminal_names, tnt_name);;

	if (code <= 1)
	  sxerror (tok->source_index,
		   err_titles [1][0],
		   "%sThis unknown %sterminal symbol \"%s\" is ignored.", err_titles [1]+1, (cas == 1) ? "" : "non-", tnt_name);
	else
	  printf ("#define %s %i\n", sxstrget (SXSTACKtoken (SXSTACKnewtop ()).string_table_entry), code-1);
#endif /* 0 */

	return;

      default:
	fputs ("The function \"make_tdef_semact\" is out of date with respect to its specification.\n", sxstderr);
	sxexit(1);
      }
    }

    break;

  case SXERROR:
    is_error = true;
    break;

  case SXFINAL:
  case SXCLOSE:
  case SXSEMPASS:
    break;

  default:
    fputs ("The function \"make_tdef_semact\" is out of date with respect to its specification.\n", sxstderr);
    sxexit(1);
  }
}




bool make_tdef_scanact (SXINT code, SXINT act_no)
{
  switch (code) {
  case SXOPEN:
  case SXCLOSE:
  case SXINIT:
  case SXFINAL:
    return SXANY_BOOL;

  case SXACTION:
    switch (act_no) {
      // short	c;

    case 1: /* \nnn => char */
      {
	SXINT	val;
	char	c, *s, *t;

	t = s = sxsvar.sxlv_s.token_string + sxsvar.sxlv.mark.index;

	for (val = *s++ - '0'; (c = *s++) != SXNUL; ) {
	  val = (val << 3) + c - '0';
	}

	*t = val;
	sxsvar.sxlv.ts_lgth = sxsvar.sxlv.mark.index + 1;
	sxsvar.sxlv.mark.index = -1;
      }
      return SXANY_BOOL;

    default:
      sxtrap (ME, "unknown switch case #2");
      /* NOTREACHED */
    }
    /* FALLTHROUGH */

  default:
    fputs ("The function \"make_tdef_scanact\" is out of date with respect to its specification.\n", sxstderr);
    sxexit(1);
  }
}

