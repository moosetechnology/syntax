% Copyright information:
%
% Copyright (c) 1988 INRIA, Projet Langages et Traducteurs
%
%    Permission is granted to anyone to make or distribute verbatim
%    copies of this document as received, in any medium, provided
%    that the copyright notice and this permission notice are
%    preserved, thus giving the recipient permission to redistribute
%    in turn.
%
%    Permission is granted to distribute modified versions of this
%    document, or of portions of it, under the above conditions,
%    provided also that they carry prominent notices stating who last
%    changed them.

% Ce document a ete adapte a partir de ``syntax.gi.info'', ecrit
% principalement par Pierre Boullier.  L'adaptation a LaTeX est de
% Philippe Deschamp.

% Le 6 Juillet 1988, integration par PhD d'un document intitule
% ``Bre`ve Pre'sentation du Syste`me SYNTAX'', ecrit en MS par Martin
% Jourdan.

\documentstyle[draft,twoside]{syntaxman}  % `draft' for the time being

\setcounter{secnumdepth}{3}	 % Want to produce numbers for
				 % subsubsections

\def\topfigrule{\hrule\kern-0.4pt}  % the \hrule is .4pt high
\def\botfigrule{\hrule\kern-0.4pt}  % the \hrule is .4pt high

\newcommand\bs{{\tt\char '134}}	 % A backslash character in \tt font
\newcommand\ga{{\tt\char '136}}  % A grave accent character in \tt font
\newcommand\lb{{\tt\char '173}}  % A left brace character in \tt font
\newcommand\rb{{\tt\char '175}}  % A right brace character in \tt font
\newcommand\ua{{\tt\char '013}}  % An up arrow character in \tt font

\newcommand\SYNTAX{\mbox{\sc Syntax}}
\newcommand\PASCAL{\mbox{\sc Pascal}}
\newcommand\UNIX{\mbox{\sc Unix}}
\newcommand\LEX{\mbox{\sc Lex}}
\newcommand\YACC{\mbox{\sc Yacc}}

\newcommand\BNF{\mbox{\sc Bnf}}
\newcommand\CSYNT{\mbox{\sc Csynt}}
\newcommand\CX{\mbox{\sc Cx}}
\newcommand\LECL{\mbox{\sc Lecl}}
\newcommand\MIX{\mbox{\sc Mix}}
\newcommand\PARADIS{\mbox{\sc Paradis}}
\newcommand\PPADA{\mbox{\sc ppAda}}
\newcommand\PPC{\mbox{\sc ppC}}
\newcommand\PRIO{\mbox{\sc Prio}}
\newcommand\RECOR{\mbox{\sc Recor}}
\newcommand\SEMACT{\mbox{\sc Semact}}
\newcommand\SEMAT{\mbox{\sc Semat}}
\newcommand\TABACT{\mbox{\sc Tabact}}
\newcommand\TABC{\mbox{\sc Tabc}}
\newcommand\TABLESC{\mbox{\sc Tables\_C}}
\newcommand\YAX{\mbox{\sc Yax}}
\newcommand\YSX{\mbox{\sc Ysx}}

\hyphenation{
cha-pi-tre cons-truc-tion cor-res-pon-dan-te impri-mables la-quel-le
lexi-co-gra-phi-ques per-met-tent prin-ci-pa-le-ment sui-vant
syn-ta-xi-que }

\title{
		LE SYSTE`ME {\huge S}YNTAX$^{\mbox{\rm \small TM}}$    \\[10pt]
		MANUEL D'UTILISATION	\\
		ET DE			\\
		MISE EN OEUVRE		\\
		SOUS {\UNIX}$^{\mbox{\rm \small TM}}$
}

\author{
		Pierre Boullier
	\and
		Philippe Deschamp
	\and
		INRIA--Rocquencourt		\\
		BP 105				\\
		78153 Le Chesnay Cedex		\\
		France
}


\date{
		Mise a` jour de septembre 1997, \\
		e'dition du \today.
}

\begin{document}

\maketitle
\begin{titlepage}
\null\vfil

Ce document permet l'utilisation du syste`me {\SYNTAX}\footnote{{\SYNTAX} est
une marque de'pose'e de l'INRIA.} de production de traducteurs, implante' sous
{\UNIX}\footnote{{\UNIX} est une marque de'pose'e des Laboratoires Cloche
(AT\&T Bell Laboratories).}\,; il est compatible avec la version de
distribution~3.8h de septembre~1997.  Tous commentaires, remarques, questions
et suggestions seront bienvenus, qu'ils concernent le syste`me lui-me^me ou le
pre'sent manuel\,: s'adresser par courrier e'lectronique aux
auteurs\footnote{Pierre.Boullier@inria.fr, Philippe.Deschamp@inria.fr}.

\par\vfil\small

Copyright {\copyright} 1988---1997 INRIA.

\vspace{2em}
\scriptsize

Autorisation est donne'e a` toute personne de fabriquer ou distribuer
des copies inte'grales et fide`les de ce document, sous toute forme
que ce soit, a` condition que le ``copyright'' et le pre'sent aline'a
soient pre'serve's, afin de transmettre au re'cipiendaire les me^mes
droits.

Autorisation est donne'e de distribuer des versions modifie'es de ce
document, ou d'extraits de ce document, aux me^mes termes que
ci-dessus, a` la condition supple'mentaire que les modifications
soient mises en e'vidence, signe'es et explique'es.

\vspace{2em}

Permission is granted to anyone to make or distribute {\it verbatim\/}
copies of this document as received, in any medium, provided that the
copyright notice and this permission notice are preserved, thus giving
the recipient permission to redistribute in turn.

Permission is granted to distribute modified versions of this
document, or of portions of it, under the above conditions, provided
also that they carry prominent notices stating who changed them, where
and why.

\par\vfil\null
\end{titlepage}

 \pagenumbering{roman}
 \pagestyle{headings}
 \tableofcontents \listoffigures \listoftables

\chapter{Introduction}
 \pagenumbering{arabic}

Le syste`me {\SYNTAX} regroupe un ensemble d'outils dont le but
premier est de faciliter la conception et la re'alisation de {\sl
traducteurs\/}---principalement, mais non exclusivement, dans le
domaine de la compilation.  Ces outils permettent d'une part la {\em
construction\/} d'analyseurs (syntaxiques, lexicographiques et
se'mantiques), d'autre part la {\em compilation\/} de textes sources
a` l'aide des analyseurs cre'e's au pre'alable.

Les buts poursuivis sont donc du me^me ordre que ceux qui ont
pre'side' a` la de'finition des utilitaires {\LEX} et {\YACC} de
{\UNIX}, mais il est beaucoup plus puissant et performant, en
particulier en ce qui concerne le traitement des erreurs.  De plus,
les analyseurs produits peuvent e^tre associe's a` des formes de
traitement se'mantique de plus haut niveau que celle disponible dans
{\YACC}, c'est-a`-dire la simple exe'cution de fragments de code
associe's a` chaque production.


{\SYNTAX} comprend principalement les modules suivants\,:
\begin{itemize}
 \item {\BNF}\,: mise sous forme interne des de'finitions
syntaxiques\,;

 \item {\CSYNT}\,: constructeur syntaxique\,;

 \item {\LECL}\,: constructeur lexicographique\,;

 \item {\RECOR}\,: traitement des erreurs\,;

 \item {\TABLESC}\,: production des tables d'analyse en langage C\,;

 \item les outils re'alisant l'analyse des textes source\,: {\tt
sxscanner}, {\tt sxparser}, \ldots, ou aidant a` cette analyse\,: {\tt
sxsrc\_mngr}, {\tt sxstr\_mngr}, {\it et cetera\/}.

\end{itemize}

La majeure partie de ce manuel est consacre'e a` la description de ces
modules, tant en ce qui concerne leurs fonctionnalite's qu'en ce qui
concerne leur mise en oeuvre sous le syste`me {\UNIX}.  En outre, le
chapitre~\ref{chap:semantique} est consacre' aux divers moyens de
re'aliser des traitements {\sl se'mantiques\/} a` l'aide de {\SYNTAX}.


\section{Les processeurs de base}

\subsection{Introducteur syntaxique\,: {\BNF}}

{\BNF} est le processeur de base pour la mise sous forme interne des
de'finitions syntaxiques\,; il lit une grammaire ``inde'pendante du
contexte'', effectue quelques ve'rifications simples de cohe'rence, et
produit une forme interne de cette grammaire (des ``tables'') qui sera
utilise'e par les autres processeurs.

La grammaire d'entre'e est e'crite dans un langage proche de la
``Backus-Naur Form'' bien connue.  Les non-terminaux et les terminaux
sont distingue's lexicalement.  Chaque alternative donne lieu a` une
production diffe'rente.

{\BNF} accepte des grammaires ambigu"es, a` condition que ces
ambigu"ite's puissent e^tre leve'es par la donne'e de niveaux de
priorite' (voir la section concernant {\CSYNT} et {\PRIO} ci-dessous).
De plus, l'analyse syntaxique peut e^tre influence'e par des {\sl
pre'dicats\/} et des {\sl actions\/} programme's par l'auteur de la
grammaire, ce qui permet de traiter des langages non-de'terministes,
voire de'pendants du contexte.


\subsection{Constructeur syntaxique\,: {\CSYNT} et {\PRIO}}


{\CSYNT} est le constructeur syntaxique.  Il lit les tables produites
par {\BNF} et construit un analyseur syntaxique ascendant en utilisant
la me'thode LALR(1).  Les conflits de'tecte's lors de la construction
de l'analyseur qui ne seraient pas re'solus par la lecture d'une
unite' lexicale en avance peuvent l'e^tre de plusieurs autres
manie`res\,:
\begin{itemize}
 \item par l'auteur de la description, soit en utilisant des
pre'dicats et des actions comme de'crit dans la section consacre'e a`
{\BNF}, soit en forc,ant des niveaux de priorite' (voir ci-dessous)\,;

 \item automatiquement par {\CSYNT}, gra^ce a` l'utilisation par
celui-ci de re`gles de re'solution pre'de'finies (par exemple {\it
Shift\/} prend pre'ce'dence sur {\it Reduce}).
\end{itemize}

La spe'cification de re'solution des conflits est traite'e par
{\PRIO}.  Elle se fait en utilisant une syntaxe et une se'mantique
tre`s proches de celles de {\YACC}, mais la description est se'pare'e
de la grammaire proprement dite.

Sur option, {\CSYNT} produit un listage de'taille' de'crivant les
conflits de'tecte's, ce qui permet a` un utilisateur averti de les
comprendre facilement.

Le second composant de {\CSYNT} re'duit tre`s fortement (usuellement
de plus de 95\%) la taille des tables repre'sentant l'automate
implantant l'analyseur syntaxique.  En outre, sur option, il est
capable d'e'liminer {\sl totalement} les re'ductions par des
productions simples, ce qui augmente en ge'ne'ral la vitesse de
l'analyse.


\subsection{Constructeur lexical\,: {\LECL}}

{\LECL} est le constructeur lexical.  Il lit les tables produites par
{\BNF} (en particulier la table donnant pour chaque terminal ceux qui
peuvent le suivre), ainsi qu'une description lexicale du langage, et
produit des tables de'crivant l'analyseur lexical engendre'.

Certains terminaux de la grammaire (tels ceux qui repre'sentent les
identificateurs du langage ou ses constantes), ainsi que les {\sl
commentaires\/} du langage, doivent e^tre de'crit par une {\sl
expression re'gulie`re\/} sur un alphabet dont les lettres sont des
classes de caracte`res.  {\LECL} propose un certain nombre
d'ope'rations ensemblistes pour de'finir ces classes.  Les ope'rations
disponibles pour la construction d'expressions re'gulie`res sont la
se'quence, l'alternative, la re'pe'tition, l'optionnalite' et le
groupement.  Il est aussi possible de de'finir des {\sl
abre'viations\/} correspondant a` des ``morceaux'' d'expressions
re'gulie`res, et de les utiliser pour de'finir d'autres expressions.

Pour construire l'automate d'e'tats finis implantant l'analyseur
lexical, {\LECL} utilise des techniques qui sont de'rive'es de la
me'thode LR pour la construction d'analyseurs syntaxiques\,; ceci lui
permet d'obtenir directement un automate de'terministe.

Les (ine'vitables) conflits de'tecte's lors de la construction de
l'analyseur qui ne seraient pas re'solus par la lecture d'un
caracte`re en avance peuvent l'e^tre de plusieurs autres manie`res\,:
\begin{itemize}
 \item par l'auteur de la description, soit en re'duisant les
contextes de'termine's a` partir de la grammaire, soit en utilisant
des pre'dicats et des actions semblables a` ceux du niveau syntaxique,
soit en forc,ant des niveaux de priorite'\,;

 \item automatiquement par {\LECL}, soit statiquement en utilisant des
re`gles de re'solution pre'de'finies (par exemple {\it Shift\/} prend
pre'ce'dence sur {\it Reduce\/}), soit dynamiquement en lisant un
nombre e'ventuellement {\sl non borne'\/} de caracte`res en avance.
\end{itemize}

{\LECL} construit aussi un automate tre`s performant pour la
reconnaissance des mots cle's.

Les automates produits par {\LECL} sont repre'sente's par des tables.
Sur option, l'analyseur lexical peut aussi e^tre produit sous la forme
d'un programme~C spe'cifique, ce qui permet d'augmenter la vitesse
d'analyse.


\subsection{Traitement des erreurs\,: {\RECOR}}

L'avantage le plus appre'ciable de {\SYNTAX} sur {\YACC} est son
puissant traitement d'erreurs\,; il faut d'ailleurs reconnai^tre que
{\YACC} est particulie`rement rustique sur ce point.

Tout traitement d'erreur se de'compose en trois ou quatre phases\,:
\begin{enumerate}
 \item de'tection,
 \item affichage,
 \item tentative de correction,
 \item rattrapage, si la correction a e'choue'.
\end{enumerate}

En ce qui concerne la de'tection d'erreur, les me'thodes d'analyse
employe'es par {\SYNTAX} posse`dent la proprie'te' du pre'fixe
correct, ce qui garantit qu'une erreur est de'tecte'e de`s que la
partie du texte de'ja` lue ne peut pas faire partie d'un texte
correct.

En ce qui concerne l'affichage, {\SYNTAX} e'met des messages d'erreur
tre`s clairs, avec rappel au terminal de la ligne du texte source et
marqueur sous l'erreur.  De plus, si les analyseurs sont construits en
conse'quence, un listage est produit, contenant le texte source et les
messages d'erreur au ``bon'' endroit.

L'analyse se poursuit apre`s une correction ou un rattrapage.


\subsubsection{Correction locale}

Quand une erreur est de'tecte'e, l'analyseur produit virtuellement
toutes les parties de texte syntaxiquement correctes a` partir du
point en erreur et les compare a` une liste ordonne'e de {\sl mode`les
de correction}.  Ces mode`les, fournis a` la construction par l'auteur
de la grammaire, peuvent spe'cifier un nombre {\sl quelconque\/} de
suppressions, d'insertions {\it vel\/} de remplacements dans le texte
source.  Si l'une des parties de texte engendre'es correspond a` l'un
de ces mode`les, la correction est accepte'e\,: le nouveau texte vient
remplacer l'ancien, et l'analyse reprend.

De nombreux dispositifs annexes permettent a` l'auteur de la
spe'cification de contro^ler tre`s finement le me'canisme de
correction\,: correction de fautes d'orthographe sur les mots cle's,
longueur de validation, terminaux cle's, ensembles {\it
Don't~Delete\/} et {\it Don't~Insert}, possibilite' d'agir sur le
terminal pre'ce'dant l'erreur,~\ldots

Notons que l'analyseur lexical be'ne'ficie du me^me me'canisme de
correction que l'analyseur syntaxique.  Notons aussi que ce me'canisme
est totalement inde'pendant de la grammaire et ne ne'cessite pas de
modifier cette dernie`re.


\subsubsection{Rattrapage global}

Si la correction locale e'choue---ce qui se produit dans moins de 20\%
des cas en pratique---, l'analyseur doit tout de me^me pouvoir
analyser le reste du texte.  Ceci est possible gra^ce au rattrapage
global.

Pour ce qui est du rattrapage syntaxique, le texte est lu sans analyse
jusqu'a` rencontrer un {\sl terminal cle'\/} tel qu'il existe dans la
pile un e'tat ayant une transition non-terminale valide pouvant e^tre
suivie du dit terminal.  L'analyseur est ensuite rede'marre' avec ce
terminal en entre'e, apre`s que la pile ait e'te' e'cre^te'e jusqu'a`
cet e'tat.  L'effet net de ce me'canisme est d'ignorer une partie de
texte entourant le point d'erreur, ce qui est un pis-aller mais permet
d'analyser la suite du texte.

Le rattrapage lexical consiste a` de'truire purement et simplement le
caracte`re en erreur.

L'action combine'e des deux phases du traitement d'erreur de {\SYNTAX}
est en pratique tre`s satisfaisante, et en tous cas incomparablement
supe'rieure a` celle de {\YACC}.


\subsubsection{Spe'cification du traitement d'erreur}

Tous les aspects du traitement d'erreur sont de'crits se'pare'ment de
la grammaire, qu'il s'agisse de l'affichage, de la correction locale
ou du rattrapage global, et ce aussi bien pour l'analyse lexicale que
pour l'analyse syntaxique.  L'auteur de cette description spe'cifie en
particulier les mode`les de correction, les terminaux cle's et les
messages d'erreur\,: aucune partie de message n'e'tant fabrique'e
directement par {\SYNTAX}, ceci permet de les adapter par exemple a`
la langue naturelle des utilisateurs ou a` leur niveau de compe'tence.

Cette description est traite'e par le processeur {\RECOR}.


\subsection{Production des tables\,: {\TABLESC}}

Ce dernier processeur lit les tables produites par les autres
constructeurs et construit un ``programme''~C, compose'
essentiellement de structures de donne'es initialise'es, contenant
toutes les informations ne'cessaires au syste`me d'exe'cution de
{\SYNTAX}, de'crit ci-dessous, pour traiter le langage en question.
Ce programme doit e^tre compile' et lie' au syste`me d'exe'cution pour
former un analyseur complet.


\section{Le Syste`me d'Exe'cution}

{\SYNTAX} ne produit pas directement un programme exe'cutable, mais un
ensemble de donne'es~C a` compiler et lier avec diffe'rents modules du
syste`me d'exe'cution.  Ces modules comprennent bien entendu un
analyseur lexical et un analyseur syntaxique qui vont interpre'ter les
tables du langage a` analyser, mais aussi de nombreux modules
utilitaires permettant de re'aliser a` peu de frais un ``squelette''
de compilateur\,:
\begin{itemize}
 \item gestionnaire du texte source, permettant en particulier de
traiter les {\it includes}\,;

 \item gestionnaire des messages d'erreur, permettant de les afficher
au cours de l'analyse et de les stocker pour les inclure dans le
listage\,;

 \item gestionnaire de chai^nes de caracte`res, permettant de stocker
des textes de longueur quelconque, de leur affecter un ``nume'ro
unique'' et d'y acce'der facilement\,;

 \item enchai^neur de passes\,;

 \item modules de traitement d'erreur\,;

 \item module de production du listage\,;

 \item gestionnaire de chai^nes de bits destine'es a` repre'senter des
ensembles\ldots
\end{itemize}

Tous ces modules sont disponibles sous forme binaire dans une
bibliothe`que manipulable par l'e'diteur de liens, et aussi sous forme
source, ce qui permet de les modifier pour les adapter a` des besoins
particuliers.


\section{Le Traitement Se'mantique}

L'utilite' d'un pur analyseur lexico-syntaxique est faible.  Certes,
il peut e^tre utile de savoir si un programme est syntaxiquement
correct avant de le soumettre a` un compilateur, {\it a priori\/} plus
lent, mais, dans la plupart des cas, il faut comple'ter l'analyse par
un traitement se'mantique.  {\SYNTAX} propose plusieurs me'thodes pour
e'crire un tel traitement, de'crites ci-apre`s.  Pour chacune d'elles,
un unique fichier source contient a` la fois la grammaire du niveau
syntaxique et la spe'cification du traitement se'mantique.  Cette
spe'cification se fait en inse'rant du texte apre`s chaque production
de la grammaire.  Un unique processeur traite a` la fois la grammaire,
avec des fonctionnalite's he'rite'es de {\BNF}, et la spe'cification
de la se'mantique.


\subsection{Actions}

La me'thode de plus bas niveau, mais aussi la plus puissante, est
d'associer un nume'ro d'action a` chaque production, et d'e'crire une
proce'dure comportant un fragment de programme pour chacun de ces
nume'ros.  Lors de chaque re'duction, l'analyseur appellera cette
proce'dure en lui passant le nume'ro de l'action associe'e a` la
production par laquelle on re'duit.  Cette action pourra alors
acce'der a` la pile d'analyse et effectuer un traitement approprie'.

Cette forme de se'mantique est la plus de'licate a` utiliser et la
plus fastidieuse a` manipuler, mais c'est aussi la plus puissante
puisque tout y est permis.  On pourrait la conside'rer comme ``le
langage d'assemblage'' du traitement se'mantique.  Cette comparaison
est d'autant plus justifie'e que, pour l'analyseur syntaxique, tout
traitement se'mantique est constitue' d'actions appele'es a` chaque
re'duction...

Cette forme de se'mantique est traite'e par le processeur {\SEMACT}.


\subsection{Actions a` la {\YACC}}

Cette forme de traitement se'mantique est un peu plus structure'e que
la pre'ce'dente en ce sens que les fragments de code implantant les
actions sont e'crits directement apre`s les productions, sous forme de
blocs~C (entre accolades).  Le processeur {\YAX} produit lui-me^me les
nume'ros d'action et la proce'dure correspondante.

En outre, les acce`s a` la pile sont ``de'guise's'' par l'emploi d'une
notation he'rite'e de {\YACC}, dont {\YAX} est fortement inspire'.  La
gestion de la pile est aussi effectue'e automatiquement.  Il faut
noter tout de me^me une diffe'rence importante\,: {\YAX} n'accepte
pas, contrairement a` {\YACC}, que de tels fragments de code soient
inse're's {\sl au milieu\/} des parties droites des productions.

{\SYNTAX} propose un traducteur, nomme' {\YSX}, transformant (purement
syntaxiquement) une spe'cification pour {\YACC} en une spe'cification
pour {\YAX}.  Les actions au milieu des productions sont correctement
traduites en les attachant a` des non-terminaux de'rivant la chai^ne
vide, produits automatiquement.

Une version de {\YAX} avec des actions en Pascal est actuellement a`
l'e'tude.


\subsection{Attributs se'mantiques purement synthe'tise's}

La formalisation des notions d'{\sl acce`s a` la pile\/} et de {\sl
gestion de la pile\/} em\-ploy\-e'es ci-dessus est la notion de {\sl
grammaire attribue'e}.  La description de cette technique demande trop
de place pour figurer ici, mais disons seulement qu'elle permet
d'exprimer de fac,on purement {\sl de'clarative\/} tous les calculs
dirige's par la syntaxe.

{\SYNTAX} propose une forme restreinte de grammaires attribue'es, dans
laquelle les valeurs des attributs sont calcule'es de bas en haut de
l'arbre de de'rivation (purement synthe'tise'es).  Le calcul de ces
valeurs peut e^tre de'crit soit en~C (processeur {\TABC}), soit en
{\PASCAL} (processeur {\TABACT}).  Dans ce dernier cas, plusieurs
modules d'interface, inclus dans le syste`me d'exe'cution, permettent
d'acce'der en {\PASCAL} aux fonctionnalite's de la version~C.


\subsection{Arbres abstraits}

Si le traitement se'mantique de'sire' ne peut pas s'effectuer en une
passe au cours de l'analyse syntaxique, il faut construire un arbre
repre'sentant le texte source et susceptible d'e^tre parcouru
plusieurs fois.  {\SYNTAX} propose une telle forme de traitement
se'mantique, dans laquelle les arbres produits sont des arbres
abstraits, ce qui signifie qu'ils ne contiennent pas d'information
purement syntaxique comme les terminaux non ge'ne'riques et les
productions simples.  De plus, les notions du langage exprimant des
listes sont effectivement repre'sente'es par des noeuds listes, et non
pas par des peignes.

La spe'cification de ce traitement se fait en attachant des noms de
noeud a` certaines productions.  La description est traite'e par le
processeur {\SEMAT}.  Ce dernier produit, outre des tables permettant
a` un module du syste`me d'exe'cution de construire l'arbre au cours
de l'analyse syntaxique, des ``squelettes'' de programmes~C, dans
lesquels les actions a` effectuer sur chaque noeud visite' peuvent
e^tre inse're'es.  Un autre module du syste`me d'exe'cution permet de
parcourir ces arbres du haut en bas et de gauche a` droite---on peut
aussi ``programmer'' des parcours diffe'rents---en appelant les
actions associe'es a` chaque noeud.  Des informations peuvent e^tre
attache'es a` chaque noeud.  Un autre module du syste`me d'exe'cution
produit une repre'sentation ``semi-graphique'' (alphanume'rique) de
ces arbres.  Le processeur {\MIX} permet d'automatiser la mise a` jour
des ``passes se'mantiques'' apre`s modification de la grammaire {\it
vel\/} de la spe'cification des arbres abstraits.


\subsection{Paragraphage}

L'expe'rience prouve rapidement qu'il est beaucoup plus agre'able et
efficace de travailler sur des programmes dont la mise en page
refle`te la structure.  Des processeurs permettant de produire
automatiquement une version {\sl paragraphe'e\/} de textes e'crits
sans prendre en compte leur structure sont donc bienvenus.

{\SYNTAX} propose un moyen de construire automatiquement de tels
paragrapheurs, en utilisant une technique base'e sur la remarque
suivante\,: quand on e'crit la grammaire d'un langage, on pre'sente
souvent les productions de cette grammaire de la me^me fac,on qu'on
voudrait voir paragrapher les textes de ce langage (voir la
figure~\ref{fig:ex-paradis}).

\begin{figure}[btp]
 \caption[Spe'cification de paragraphage.]
	{Exemple de spe'cification de paragraphage.}
	\label{fig:ex-paradis}
 \vspace{1ex}

Voici un extrait d'une grammaire de {\PASCAL} ``bien pre'sente'e''\,:

 \begin{quote}
\begin{verbatim}
<PROC DECL>     = <PROC HEAD>
                  <BLOCK> ;
<PROC HEAD>     = procedure  %ID  <FORMALS *>  ";" ;
<BLOCK>         = <DECL *>
                  <COMPOUND STMT>  ";" ;
<COMPOUND STMT> = begin
                      <STMT +>
                  end ;
\end{verbatim}
 \end{quote}

{\PARADIS} produit automatiquement un paragrapheur, a` partir de la
spe'cification pre'ce'dente\,; ce paragrapheur est capable de
transformer le texte suivant\,:

 \begin{quote}
\begin{verbatim}
ProCedure TRuc
; begin instruction1;
Instruction2           end
;
\end{verbatim}
 \end{quote}
en la forme paragraphe'e suivante\,:
 \begin{quote}
\begin{verbatim}
procedure TRUC ;
begin
    INSTRUCTION1 ;
    INSTRUCTION2
end ;
\end{verbatim}
 \end{quote}


 \vspace{1ex}
\end{figure}

Le processeur {\PARADIS} permet donc d'obtenir a` peu de frais un
paragrapheur pour un langage une fois qu'on en a e'crit la grammaire,
en pre'sentant cette dernie`re de fac,on a` ce qu'elle soit agre'able
a` l'oeil.

En fait, cette approche est un peu simpliste.  {\PARADIS} propose
donc, en plus de ce principe ge'ne'ral, des directives de paragraphage
qui permettent d'obtenir des mises en page plus sophistique'es.  En
outre, les proble`mes classiques de longueur borne'e de la ligne de
sortie et de placement des commentaires sont traite's de manie`re
ge'ne'ralement satisfaisante (e'tant entendu qu'ils n'ont pas de
solution comple`te).

%%%Les spe'cifications d'un paragrapheur de {\PASCAL} sont livre'es
%%%avec {\SYNTAX}.


\subsection{Utilitaires divers}

Outre les constructeurs de base et les outils traitant la se'mantique,
{\SYNTAX} comprend un certain nombre d'utilitaires\,:
\begin{itemize}
 \item {\CX}, un ge'ne'rateur de re'fe'rences croise'es pour le
langage~C\,;

 \item {\PPC} et {\PPADA}, des paragrapheurs pour les langages~C et
Ada\footnote{Ada est une marque de'pose'e du Gouvernement des
E'tats-Unis d'Ame'rique (Ada Joint Program Office).} respectivement.
\end{itemize}

Ces outils ont bien su^r e'te' construits a` l'aide de {\SYNTAX}.


\section{Mise en OEuvre de {\SYNTAX} sur {\UNIX}}

{\SYNTAX} est actuellement disponible sur de nombreuses machines
munies du syste`me d'exploitation {\UNIX} (ou l'un de ses de'rive's).
Soit {\tt \$sx} le re'pertoire ou` a e'te' installe' {\SYNTAX}.  Le
contenu des diffe'rents sous-re'pertoires de {\tt \$sx} est le
suivant\,:

\begin{description}
 \item[{\tt \$sx/bin}] contient les versions binaires exe'cutables de
tous les processeurs de {\SYNTAX}.  Habituellement, ces fichiers sont
aussi lie's (au sens {\UNIX}) dans un re'pertoire ``standard'' comme
{\tt /usr/local/bin}, ce qui e'vite aux utilisateurs d'avoir a`
changer leur ``{\tt PATH}''.

 \item[{\tt \$sx/doc}] contient la documentation.  Outre un fichier de
nom {\tt NOUVEAUTES}, qui re'sume l'e'volution des diverses versions
distribue'es, il contient les sous-re'pertoires {\tt man} (les ``pages
de manuel'', habituellement lie'es ou copie'es dans {\tt /usr/man} ou
autre pour acce`s imme'diat) et {\tt help} (courtes descriptions des
commandes de {\SYNTAX}, utilisables en particulier par la fonction
``{\it help}'' de {\tt tcsh(1)}), ainsi que divers fichiers facilitant
la mise en oeuvre de {\SYNTAX}.

 \item[{\tt \$sx/incl}] contient des fichiers ``{\it include\/}''
permettant l'acce`s aux modules du syste`me d'exe'cution.  Le plus
important est {\tt sxunix.h} qui est utilisable en~C.  Il existe aussi
des versions {\PASCAL}, disponibles dans des sous-re'pertoires.

 \item[{\tt \$sx/lib}] contient les binaires des modules du syste`me
d'exe'cution, re'partis entre une bibliothe`que {\tt libsx.a} et
quelques fichiers~``{\tt .o}''.  Ces derniers sont essentiellement des
versions de mise au point de modules existant dans la bibliothe`que en
version de production.  La bibliothe`que peut e^tre lie'e dans un
re'pertoire standard pour permettre l'utilisation de l'option {\tt
-lsx} de l'e'diteur de liens {\tt ld(1)}.

 \item[{\tt \$sx/src}] contient les sources de tous les modules du
syste`me d'exe'cution.  Leur disponibilite' permet de les adapter a`
tous les besoins.
\end{description}


\chapter[BNF -- Lecture des de'finitions syntaxiques]
{BNF~: \\ Lecture des De'finitions Syntaxiques}
	\label{chap:bnf}

\section{Fonction}

{\BNF} lit la grammaire et la met sous forme interne pour utilisation
ulte'rieure par d'autres constructeurs, tels {\CSYNT} et {\LECL}.  Il
effectue e'galement des tests de cohe'rence sur la grammaire\,:
\begin{itemize}
 \item Chaque re`gle doit e^tre unique.

 \item Un non-terminal quelconque doit e^tre productif (c'est-a`-dire
doit conduire a` une chai^ne terminale---e'ventuellement vide).

 \item Un non-terminal quelconque doit e^tre accessible depuis
l'axiome.

 \item Aucun non-terminal ne doit de'river dans lui-me^me
(c'est-a`dire que $N \buildrel+\over\Rightarrow N$ est interdit---les
{\sl re'cursions\/} gauche et droite sont bien entendu autorise'es).
\end{itemize}

{\BNF} construit en outre, pour chaque terminal, la liste des
terminaux pouvant le suivre ({\sl contexte\/})\,; cette information
est utilise'e par {\LECL} (voir en~\ref{sec:conflits}).

\section{Me'talangage syntaxique}

\subsection{Les e'le'ments syntaxiques}
	\label{sec:lexico-bnf}

La description de la grammaire utilise'e a` l'entre'e du processeur
{\BNF} est tre`s proche de la {\sl forme normale de
Backus\/}---appele'e e'galement {\sl forme de Backus-Naur\/} (``{\it
Backus-Naur Form\/}'', d'ou` le nom de {\sl BNF\/}).  Toutefois, pour
faciliter l'e'criture et la lecture de la grammaire, des notations
particulie`res sont em\-ploy\-e'es\,; les notations de {\BNF} sont
de'crites ci-dessous\,:

\begin{itemize}
 \item La grammaire est une liste de {\sl re`gles} appele'es aussi
{\sl productions}.  Le symbole
``\verb:|:'' ({\it ou\/} de la BNF standard) n'est pas utilise'\,: il
doit y avoir autant de re`gles que d'alternances.

 \item Chaque re`gle se de'compose en une {\sl partie gauche\/} et une
{\sl partie droite\/}, se'pare'es par un caracte`re~``\verb|=|'' (qui
remplace le symbole ``\verb|::=|'' de la BNF standard), et se termine
par un caracte`re~``\verb|;|''.

 \item Les symboles non-terminaux sont de'limite's par les caracte`res
``\verb|<|'' et ``\verb|>|'' et se composent d'un nombre quelconque de
caracte`res imprimables (autres que~``\verb|>|'') et
d'espaces~(``\verb*| |'').

 \item Le symbole non-terminal constituant la partie gauche d'une
re`gle doit obligatoirement commencer en colonne~1.

 \item L'axiome de la grammaire est, par de'finition, le symbole
non-terminal figurant en partie gauche de la premie`re re`gle.

 \item On distingue deux types de symboles terminaux\,:
  \begin{itemize}

   \item les terminaux {\sl ge'ne'riques\/} tels que les
identificateurs et les litte'raux, pouvant recouvrir un ensemble
the'oriquement infini de possibilite's pour le programme, et qui
doivent obligatoirement e^tre de'finis au niveau lexical (voir le
chapitre~\ref{chap:lecl}).  De tels terminaux sont de'note's par un
identificateur (forme~C du terme) pre'ce'de' du caracte`re
``\verb|%|''.

   \item les autres terminaux\,: mots cle's, symboles spe'ciaux, \ldots
Ceux-ci sont en ge'ne'ral e'crits exactement tels qu'ils devront
apparai^tre dans les programmes et se terminent au premier blanc ou
fin de ligne rencontre'.  Toutefois, pour re'soudre les proble`mes
d'ambigu"ite' que posent les terminaux commenc,ant par un des
caracte`res
\begin{quotation}
 \verb|; ~ " < % @ & #|
\end{quotation}
tout terminal peut e^tre pre'ce'de' d'un caracte`re ``\verb|#|''.

Tout terminal peut e'galement e^tre e'crit entre guillemets\,; dans ce
cas, les conventions d'e'criture des chai^nes de caracte`res du
langage~C s'appliquent---ces conventions sont rappele'es dans la
table~\ref{fig:conventions-C}.
\begin{table}[bhtp] \centering
 \caption{Conventions d'e'criture des caracte`res dans les chai^nes.}
	\label{fig:conventions-C}
 \vspace{1ex}
 \begin{tabular}{|llc|}
 \hline
 \multicolumn{1}{|c}{Se'quence} &
  \multicolumn{1}{l}{Nom du caracte`re} &
  \multicolumn{1}{c|}{Code ASCII (en octal)}			\\
 \hline
	\verb|\b| & {\small Back-Space} & 010			\\
	\verb|\t| & {\small Horizontal-Tabulation} & 011	\\
	\verb|\n| & {\small New-Line} & 012			\\
	\verb|\f| & {\small Form-Feed} & 014			\\
	\verb|\r| & {\small Carriage-Return} & 015		\\
	\verb|\"| & {\small Double-Quote} & 042			\\
	\verb|\\| & {\small Back-Slash} & 134			\\
	\verb|\|{\it nnn} & & {\it nnn}				\\
 \hline
 \end{tabular}
\end{table}
La figure~\ref{fig:ex-terminaux} donne quelques exemples de
possibilite's d'e'criture de symboles terminaux non-ge'ne'riques.
\begin{figure}[hbtp] \centering
 \caption[E'criture de terminaux non-ge'ne'riques.]
	{Exemples d'e'criture de terminaux non-ge'ne'riques.}
	\label{fig:ex-terminaux}
 \vspace{1ex}
 \begin{tabular}{|c|ccc|}
  \hline
  \multicolumn{1}{|r}{Le terminal} &
   \multicolumn{3}{c|} {peut s'e'crire} \\
  \hline
   \verb|Begin| & \verb|Begin| & \verb|#Begin| & \verb|"Begin"| \\
   \verb|~| & & \verb|#~| & \verb|"~"|			\\
   \verb|#| & & \verb|##| & \verb|"#"|			\\
   \verb|"AND"| & & \verb|#"AND"| & \verb|"\"AND\""|	\\
   \verb|%AND| & & \verb|#%AND| & \verb|"%AND"|		\\
   \verb|\| & \verb|\| & \verb|#\| & \verb|"\\"|	\\
  \hline
 \end{tabular}
 \vspace{1ex}
\end{figure}
  \end{itemize}

 \item La de'finition de la grammaire se termine par la fin du
fichier d'entre'e.

\end{itemize}

\subsubsection*{Remarques}

\begin{itemize}
 \item Les re`gles dont la partie droite est vide sont de'crites sous
la forme naturelle
\begin{quotation}
 \verb|<A> = ;|
\end{quotation}

 \item On peut inclure des {\sl commentaires\/} dans la de'finition de
la grammaire\,: ils de'butent en colonne 1 par un caracte`re
``\verb|*|'' et se terminent par une fin de ligne.

 \item Il est possible d'associer de la {\sl se'mantique\/} a` chaque
re`gle de grammaire.  Sur ce point, {\BNF} est un langage ouvert, au
sens ou` il se contente uniquement d'interpre'ter les re`gles de
syntaxe d'une description source.  {\BNF} conside`re comme de'crivant
de la ``se'mantique'' et, a` ce titre, ne l'interpre`te pas, tout le
texte se trouvant avant le premier~``\verb|<|'' en colonne 1 (marquant
le de'but de la premie`re re`gle de grammaire), ainsi que les portions
de texte situe'es entre chaque ``{\tt;}'' marquant la fin d'une re`gle
et le de'but de la re`gle suivante (ou la fin du fichier d'entre'e).
Ce texte peut, bien entendu, e^tre utilise' par un processeur associe'
a` {\BNF}---c'est d'ailleurs ainsi que sont implante's les
constructeurs ``se'mantiques'' de {\SYNTAX}\,: {\SEMACT}, {\SEMAT},
{\TABC}, {\YAX},~\ldots
\end{itemize}

\subsection{Les actions et pre'dicats}
	\label{sec:actions-bnf}

Fondamentalement, la classe de grammaires accepte'e par {\SYNTAX} est
le LALR(1) (voir en~\ref{sec:classe}).  Cette classe, bien fonde'e
the'oriquement, re'alise pour un langage donne' un bon compromis entre
la rapidite' de construction d'un analyseur et la facilite'
d'e'criture de sa grammaire.  Cependant, dans certains cas,
l'obtention d'une grammaire LALR(1) peut se re've'ler malcommode---et
le re'sultat obtenu e^tre trop e'loigne' de la grammaire
``naturelle''\,; il peut me^me e^tre impossible d'e'crire une telle
grammaire (si le langage est non-de'terministe).  Afin de pallier ces
faiblesses, nous avons ajoute' a` la de'finition syntaxique deux
me'canismes\,:
\begin{itemize}
 \item Une spe'cification de priorite' ``a` la {\YACC}'' (voir
en~\ref{sec:classe})

 \item Un me'canisme d'actions et de pre'dicats de'crit ci-dessous.
Ces actions et pre'dicats sont le pendant syntaxique des actions et
pre'dicats de {\LECL} (voir en~\ref{sec:actions-lecl}
et~\ref{sec:predicats-lecl}).
\end{itemize}

\subsubsection{Les actions}

Il est possible de spe'cifier des {\sl actions syntaxiques\/} dans les
parties droites des re`gles de grammaire.  Une action syntaxique est
un nombre entier~{\it n}, positif ou nul, pre'ce'de' du
caracte`re~``\verb|@|''.  Lors de la reconnaissance de l'exe'cution de
l'action~``\verb|@|{\it n\/}'' pendant l'analyse d'un texte source, un
programme e'crit par l'utilisateur sera appele' avec le
parame`tre~{\it n}.  En ge'ne'ral ces actions, par utilisation du
contexte (gauche ou droit), vont positionner des variables qui peuvent
e^tre utilise'es par les {\sl pre'dicats\/}---voir ci-dessous.

D'un point de vue syntaxique, une action joue le ro^le d'un symbole
non-terminal dont la de'finition est fournie par le syste`me---sous la
forme d'une partie droite vide.	 A` l'analyse d'un texte l'action~{\it
n\/} est appele'e chaque fois que la re`gle vide correspondante est
reconnue.

L'adjonction d'actions ne change pas le langage de'crit par la
grammaire\,; il est possible en revanche que la grammaire devienne
non-LALR(1).

\subsubsection{Les pre'dicats}

On peut associer un {\sl pre'dicat\/} a` un symbole terminal
quelconque, ge'ne'rique ou non ou a` un symbole non-terminal
quelconque situe' en partie droite d'une re`gle.  Un pre'dicat est un
nombre entier~$n$, positif ou nul, pre'ce'de' du
caracte`re~``\verb|&|''.  Un pre'dicat doit suivre lexicalement dans
la grammaire le symbole auquel il est associe'.	 Un tel couple est
appele' {\sl terminal e'tendu} ou {\sl non-terminal e'tendu}.

A` l'analyse, un terminal e'tendu~\verb|t&|$n$ est reconnu si et
seulement si le texte source contient le symbole~\verb|t| et le
pre'dicat~$n$ rend {\it vrai\/} (le pre'dicat est implante' par une
fonction a` re'sultat boole'en, e'crite par l'utilisateur, appele'e
avec le parame`tre~$n$).  Un non-terminal e'tendu~\verb|<A>&|$n$ est
reconnu si et seulement si une phrase de~\verb|<A>| a e'te' reconnue
(on vient d'effectuer une re'duction et~\verb|<A>| est en partie
gauche de la re`gle correspondante) et le pre'dicat utilisateur
nume'ro~$n$ a retourne' {\it vrai}.  D'un point de vue syntaxique,
si~\verb|s&|$m$ et~\verb|t&|$n$ sont des symboles e'tendus,
\verb|s&|$m \equiv \mbox{}$\verb|t&|$n \Leftrightarrow \verb|s| \equiv
\verb|t| \wedge m \equiv n$---ainsi l'on a ``\verb|"end"&9|$\mbox{}
\equiv \mbox{}$\verb*|#end &009|''.

\paragraph*{Remarques}

 \begin{itemize}

  \item Il est indispensable que le codage des pre'dicats soit
re'alise' sans {\sl effet de bord\/}---les pre'dicats sont cense's
e^tre {\sl purs}.  En effet, une me^me occurrence d'un pre'dicat peut
donner lieu a` plusieurs exe'cutions de la fonction qui l'implante
(test du ``{\it look-ahead\/}'' puis ``{\it shift\/}''---pour
l'explication de ces termes, voir au chapitre~\ref{chap:csynt}---, ou
traitement des erreurs$\dots$).

  \item Si, dans un e'tat donne', pour un symbole \verb|X|,
co{}existent ({\it shift\/ {\rm vel} look-ahead\/}) des occurrences
e'tendues et des occurrences simples, le syste`me conside`re que les
occurrences simples de \verb|X| dans cet e'tat sont en fait des
occurrences e'tendues \verb|X&Else|, le pre'dicat fictif
\verb|&Else| s'e'valuant toujours en {\it vrai}.

  \item L'ordre d'exe'cution des pre'dicats associe's a` un symbole
n'est pas spe'cifie' (sinon que le pre'dicat fictif \verb|&Else| est
toujours exe'cute' en dernier).	 Il faut donc que, dans un e'tat
donne', les pre'dicats associe's a` un me^me terminal soient exclusifs
les uns des autres.

  \item Du fait du traitement des erreurs (voir le
chapitre~\ref{chap:erreurs}), lors de l'exe'cution d'une action,
l'unite' lexicale suivante est lue et teste'e (pre'dicat e'ventuel
compris) et l'unite' lexicale d'apre`s est lue et ``semi-teste'e'' (il
existe dans l'automate une action d'analyse---{\sl Shift\/} ou {\sl
Reduce\/}---sur ce terminal, mais le pre'dicat e'ventuel associe' a`
ce terminal n'est pas encore exe'cute').  Ceci signifie que la portion
de grammaire
\begin{quote}
	\ldots\ \verb|@1 t &1| \ldots
\end{quote}
ou` \verb|&1| utilise le re'sultat de \verb|@1| est errone'e alors que
\begin{quote}
	\ldots\	 \verb|@1 s t &1| \ldots
\end{quote}
est valide.  Attention\,: dans cet exemple, l'expression ``portion de
grammaire'' n'implique pas que l'action et le terminal e'tendu
apparaissent dans la me^me re`gle.

 \item Le traitement des erreurs (voir le
chapitre~\ref{chap:erreurs}), et en particulier la phase de
correction, est de'licat a` mettre en oeuvre en pre'sence de
pre'dicats.  Lorsque le traitement des erreurs a de'cide' de remplacer
la chai^ne source $\alpha\beta\gamma$ par $\alpha\beta'\gamma$ (une
erreur a e'te' de'tecte'e dans~$\beta$) il faut obligatoirement que
$\alpha\beta'$ soit un pre'fixe correct d'une sentence du langage.  Or
$\beta'$ peut contenir des pre'dicats qui peuvent s'exe'cuter
diffe'remment dans le contexte de la correction des erreurs (les
actions ne sont pas exe'cute'es, l'environnement est diffe'rent) et
dans le contexte de l'analyse normale et donc produire des re'sultats
diffe'rents.

Afin de ne pas construire une chai^ne $\beta'$ qui risquerait d'e^tre
invalide'e par l'analyse normale---le couple analyseur/correcteur
pourrait me^me boucler inde'finiment---on a choisi de ne pas exe'cuter
les pre'dicats de l'utilisateur au cours du rattrapage d'erreur, en
supposant qu'ils retournent tous {\it faux}.  En proce'dant de cette
fac,on, il est bien entendu possible d'{``oublier''} quelques
corrections.

Il est donc conseille' d'e'viter de de'tecter des erreurs dans les
se'quences de pre'dicats en proce'dant de la fac,on suivante.
Rappelons que la pre'sence de pre'dicats dans une grammaire permet
d'expliciter d'une manie`re non syntaxique un choix entre plusieurs
possibilite's syntaxiques.  Conside'rons, pour simplifier, deux
choix~$C_1$ et~$C_2$ reconnus respectivement par les
pre'dicats~\verb|&1| et~\verb|&2| associe's au symbole $X$.  Il y a
{\it a priori\/} deux fac,ons d'e'crire la grammaire correspondante\,:
\begin{itemize}
 \item Les symboles e'tendus $X$\verb|&1| et $X$\verb|&2| figurent (en
paralle`le) dans la grammaire et, en conse'quence, l'automate
engendre' testera successivement \verb|&2|, \verb|&1| (ou inversement)
puis \verb|&Else|.  Il de'tectera donc une erreur si ni~\verb|&1|
ni~\verb|&2| n'a retourne' {\it vrai}, erreur qui ne pourra pas e^tre
corrige'e.

 \item Un seul choix est explicite' (le plus particulier si possible),
$C_1$ par exemple, par le symbole e'tendu~$X$\verb|&1|, l'autre
choix~$C_2$ e'tant repre'sente' par le symbole simple~$X$ qui est donc
conside're' par le syste`me comme e'tant associe' au
pre'dicat~\verb|&Else|.  Dans ce cas, l'automate engendre' testera
successivement~\verb|&1| (choix~$C_1$) puis \verb|&Else|
(choix~$C_2$).  Aucune erreur ne peut donc e^tre de'tecte'e a` cet
endroit.  Le choix~$C_2$ a e'te' privile'gie'.  Des erreurs seront
de'tecte'es ulte'rieurement si la chai^ne ne correspond ni au
choix~$C_1$ ni au choix~$C_2$ et les corrections correspondantes
tenteront de la rapprocher du choix~$C_2$.  Le lecteur pourra regarder
a` ce propos les grammaires des exemples suivants.
\end{itemize}

 \end{itemize}

On trouvera en annexe~\ref{annexe:lecl.bnf} la grammaire syntaxique
de'crivant le langage {\LECL}.  Cette grammaire utilise un pre'dicat
syntaxique (\verb|&1|) associe' a` un terminal ge'ne'rique pour
traiter la suite de mots cle's non re'serve's \verb''NOT''
\verb''KEYWORD'' (sinon, la grammaire propose'e n'est pas LR(1)).  On
trouvera en annexe~\ref{annexe:lecl_pact.c} le programme C codant le
pre'dicat \verb|&1|.  On trouvera en annexe~\ref{annexe:lalr2} une
grammaire LALR(2) ou` les conflits LALR(1) sont re'solus par
l'utilisation d'un non-terminal e'tendu et le programme codant le
pre'dicat correspondant.  On trouvera de me^me en
annexe~\ref{annexe:amb2manbn} la grammaire d'un langage
non-de'terministe et le programme associe' re'alisant les actions et
pre'dicats syntaxiques ne'cessaires.


\section{Mise en oeuvre}

Se reporter a` la documentation en ligne---{\tt man~bnf}.

\section{Exemples de de'finitions syntaxiques}

On trouvera en annexe~\ref{annexe:bnf.bnf} la grammaire du processeur
{\BNF} lui-me^me et en annexe~\ref{annexe:lecl.bnf} la grammaire de
{\LECL} (voir le chapitre~\ref{chap:lecl}).


\chapter[CSYNT -- Construction de l'Analyseur Syntaxique]
{CSYNT~: \\ Construction de l'Analyseur Syntaxique}
	\label{chap:csynt}

\section{Classe de grammaires accepte'e}
	\label{sec:classe}

{\CSYNT} accepte en entre'e des grammaires de la classe LALR(1)\,;
ceci permet a` notre avis de re'aliser le meilleur compromis possible
a` l'heure actuelle entre le temps de construction d'une part et la
puissance d'expression permise par la classe de grammaires accepte'e
d'autre part.

{\CSYNT} rec,oit en entre'e la forme interne de la grammaire produite
par {\BNF} (voir le chapitre~\ref{chap:bnf}) et construit un analyseur
syntaxique ascendant sous forme d'un automate a` pile.

Si {\CSYNT}, au cours de cette construction, de'tecte une
non-conformite' dans la de'finition de la grammaire, il le signale de
deux fac,ons\,:
\begin{itemize}
 \item Le message \verb|NON LALR(1)| est e'crit sur \verb|stderr| (en
ge'ne'ral le terminal de l'utilisateur).

 \item Un diagnostic circonstancie' des causes de cette
non-conformite' est inscrit dans le fichier {\it
nom-du-langage}\verb|.la.l|, donnant notamment les re`gles de la
grammaire qui la produisent et une partie du contexte.
\end{itemize}

\section{Les conflits}

On peut avoir deux types de non-conformite'\,:
\begin{itemize}
 \item des conflits {\sl Reduce/Reduce\/}\,: il existe plusieurs
possibilite's de reconnaissance simultane'e de parties droites de
re`gles ({\sl Reduce\/}) et les symboles du contexte droit de ces
re`gles ({\it look-ahead\/}) ne permettent pas de faire un choix.
 \item des conflits {\sl Shift/Reduce\/}\,: il y a conflit entre
l'absorption ({\it shift\/}) du symbole suivant, et une re'duction---ou
plusieurs.
\end{itemize}

Dans les messages d'erreur e'mis par {\CSYNT}, chacune des re`gles de
grammaire mentionne'es comporte un {\it marqueur LR}, symbolise' par
un ``\verb|.|'', qui indique ou` a e'te' de'tecte'e la
non-conformite'.

{\bf Exemple}\,: La figure~\ref{fig:conflit-LALR} donne un exemple de
diagnostic e'mis par {\CSYNT} lors de la construction d'un analyseur.

\begin{figure}[hbtp] \centering
 \caption[Diagnostic de non-conformite' {\sl Shift/Reduce}.]
	{Exemple de diagnostic de non-conformite' {\sl Shift/Reduce}.}
	\label{fig:conflit-LALR}
\begin{verbatim}
    NON LALR(1)
    Le terminal t est en conflit dans l'etat s

        - en position reduce dans :

        p1: <A> = alpha .
                derivant de :
                p2: <B> = beta . <D> gamma

        - en position shift dans :

        p3: <C> = delta . t lambda
\end{verbatim}
\end{figure}

La signification de ce diagnostic est la suivante\,: on vient de
reconnai^tre, dans l'e'tat \verb|s|, simultane'ment \verb|alpha|
(partie droite de \verb|p1|) et \verb|delta| (de'but de \verb|p3|) et
l'on doit de'cider s'il faut effectuer la re'duction \verb|p1| ({\sl
Reduce\/}) ou lire le symbole \verb|t| ({\sl Shift\/}) de \verb|p3|\,;
or l'on a \verb|<D>|~${\tt \buildrel\ast\over\Rightarrow omega}$~\verb|<A>|
et ${\tt t\in FIRST1(gamma)}$.

La re'solution du conflit devant se faire avec (au plus) un symbole en
avance, la vue de \verb|t| ne permet donc pas de prendre de de'cision,
d'ou` le message de non-conformite'.

On trouvera en annexe~\ref{annexe:ambig.bnf} une grammaire ambigu"e
illustrant le proble`me du ``dangling else'' et en
annexe~\ref{annexe:ambig.conf} les messages de non-conformite'
produits par {\CSYNT}. 

Si les renseignements pre'ce'dents ne suffisent pas a` comprendre les
raisons d'un conflit, L'option \verb|-path| du
processeur {\CSYNT} (voir la documentation en ligne---{\tt man~csynt})
permet d'obtenir des renseignements supple'mentaires.

Pour chaque e'tat \verb|s| dans lequel un conflit est de'tecte',
{\CSYNT} sort une chai^ne $X_1 \ldots X_i \ldots X_n$ ou` chaque $X_i$
est un e'le'ment du vocabulaire (terminal ou non terminal) telle que l'e'tat
\verb|s| est atteint depuis l'e'tat initial par transition sur cette
chai^ne.
Cette chai^ne permet de comprendre pourquoi les productions mises en
jeu dans un conflit sont atteintes simultane'ment.

Pour chaque terminal \verb|t| en conflit dans un e'tat \verb|s|, outre
les renseignements standards de'crits pre'ce'demment, {\CSYNT} sort
pour chaque production
\begin{quotation}
 \verb|p1: <A> = alpha .|
\end{quotation}
implique'e dans le conflit et pour chaque item
\begin{quotation}
 \verb|p2: <B> = beta . <D> gamma|
\end{quotation}
``responsable'' du contexte droit \verb|t| (${\tt t\in
FIRST1(gamma)}$), une de'rivation droite, issue de l'axiome \verb|<S>|
de la grammaire de la forme\,:
\begin{quotation}
\verb|<S>|
\begin{quote}
   ${\buildrel\ast\over\Rightarrow}$\ \verb|delta <B> |\ldots			\\
   ${\buildrel\ast\over\Rightarrow}$\ \verb|delta beta <D> gamma |\ldots	\\
   ${\buildrel\ast\over\Rightarrow}$\ \verb|delta beta <D> t |\ldots		\\
   \vdots									\\
   ${\buildrel\ast\over\Rightarrow}$\ \verb|delta beta omega <A> t |\ldots	\\
   ${\buildrel\ast\over\Rightarrow}$\ \verb|delta beta omega alpha t |\ldots
\end{quote}
\end{quotation}
qui montre le ``cheminement'' complet du terminal \verb|t| depuis son
apparition comme de'butant de la chai^ne \verb|gamma| jusqu'a` son
utilisation comme contexte droit de la production \verb|p1|.

L'option \verb|-path| demande e'galement au constructeur {\CSYNT} de rechercher
certain cas d'ambigu"ite' (le cas ge'ne'ral est inde'cidable). Si
{\CSYNT} de'tecte une ambigu"ite', deux de'rivations droites
diffe'rentes menant a` la me^me forme sentencielle sont e'galement produites.

On trouvera en annexe~\ref{annexe:ambig.path} les messages de non
conformite' produits avec l'option \verb|-path| sur l'exemple de
l'annexe~\ref{annexe:ambig.bnf}.

Pour un conflit donne', si aucune ambigu"ite' a e'te' de'tecte'e,
l'option \verb|-path| demande e'galement a` {\CSYNT} de ve'rifier si
la grammaire est LR(1). Si la grammaire n'est pas LR(1), {\CSYNT}
produit deux de'rivations droites diffe'rentes qui violent la
de'finition du LR(1).

Premie`re de'rivation\,:
\begin{quotation}
\verb|<S>|
\begin{quote}
   ${\buildrel\ast\over\Rightarrow}$\ \verb|beta <A> t z|	\\
   ${\Rightarrow}$\ \verb|beta alpha t z|
\end{quote}
\end{quotation}

Deuxie`me de'rivation\,:
\begin{quotation}
\verb|<S>|
\begin{quote}
   ${\buildrel\ast\over\Rightarrow}$\ \verb|gamma|	\\
   ${\Rightarrow}$\ \verb|beta alpha t z'|
\end{quote}
\end{quotation}
avec
\begin{quotation}
   \verb|gamma|\ ${\neq}$\ \verb|beta <A> t z'|
\end{quotation}

Outre un inte're^t pe'dagogique e'vident, ces deux de'rivations peuvent
aider a` la compre'hension du conflit.

On trouvera en annexe~\ref{annexe:nlr1.bnf} une grammaire
non LR(1) et les messages de non-conformite'
produits par {\CSYNT} lorsque l'option \verb|-path| est positionne'e. 

A` des fins pe'dagogiques ou pour comprendre les raisons de
conflits complexes, l'option \verb|-lalr1| de
{\CSYNT} permet d'obtenir l'automate LALR(1) sous une forme
lisible\,:
les items constituant chaque e'tat sont explicite's, les transitions
(avant et arrie`re) reliant entre eux les e'tats sont indique'es ainsi
que les ensembles de symboles terminaux formant le contexte droit
({\it look-ahead\/}) de chaque re'duction implique'e dans un conflit LR(0).

\section{Leur re'solution}

Face a` une grammaire pre'sentant des conflits, on peut re'agir de
quatre fac,ons (non exclusives)\,:
\begin{enumerate}
 \item Supprimer les conflits en transformant la grammaire afin de la
rendre LALR(1).

 \item Ne rien faire car les re`gles par de'faut choisies par le
constructeur conviennent.

 \item E'crire une spe'cification ``a` la {\YACC}'' qui indique au
constructeur les choix de l'utilisateur face a` un conflit.

 \item Inse'rer dans la grammaire des pre'dicats {\it vel\/} des
actions (voir en~\ref{sec:actions-bnf}) afin d'aider a` la re'solution
des conflits.
\end{enumerate}

Dans tous les cas, sur un conflit, avant de choisir un type de
re'solution, il faut comprendre la raison profonde de ce conflit.
Cette ta^che peut ne pas e^tre facile (voir le chapitre pre'ce'dent
et la documentation en ligne---{\tt man~csynt}).

Chacune de ces me'thodes a ses avantages et ses inconve'nients\,:
\begin{enumerate}

 \item C'est la me'thode des ``purs et durs''.	Outre le fait qu'elle
puisse e^tre de'licate a` mettre en oeuvre, elle a tendance a`
e'loigner la grammaire de sa forme ``naturelle''.  Il peut e^tre
parfois pre'fe'rable de de'crire un sur-langage, le comple'mentaire
e'tant filtre' par la ``se'mantique''.

 \item Par de'faut, le syste`me donne priorite'\,:
	\label{prio-defauts}
  \begin{itemize}
   \item au {\sl Shift\/} lors d'un conflit {\sl Shift/Reduce},

   \item a` la re`gle qui apparai^t la premie`re dans la grammaire,
lors d'un conflit {\sl Reduce/Reduce}.

  \end{itemize}

 \item Lors de la de'tection du premier conflit, {\CSYNT} cherche un
fichier de nom {\it nom-du-langage}\verb|.dt|.	Si ce fichier existe,
il est cense' contenir des tables, produites par le module {\PRIO},
qui vont aider le constructeur {\CSYNT} a` re'soudre les conflits.
Voir ci-dessous le format et la signification des spe'cifications
destine'es a` {\PRIO}.

L'avantage de cette fac,on de proce'der est la grande finesse possible
pour la re'solution des conflits, l'inconve'nient en est que l'on peut
ne plus savoir quel est le langage reconnu\ldots

 \item L'utilisation de pre'dicats permet d'influer sur l'analyse et
en particulier de faire intervenir des notions qui n'appartiennent pas
a` la classe LALR(1).  Ces notions peuvent e^tre purement
syntaxiques---utilisation du contexte (gauche {\it vel\/} droit) sur
une longueur e'ventuellement non borne'e---ou me^me ``se'mantiques''
(utilisation d'informations calcule'es par les actions syntaxiques).

Les pre'dicats peuvent repre'senter le seul moyen utilisable pour
re'soudre des conflits---voir l'exemple du langage non-de'terministe
en pages~\pageref{annexe:amb2manbn} et suivantes.  Ils ont cependant
pour inconve'nient de ne re'soudre les conflits que de manie`re {\it
dynamique}.  Ils ne se substituent donc pas aux autres possibilite's
e'nume're'es ci-dessus.
\end{enumerate}

\subsection{Le langage {\PRIO}}

Les tables mentionne'es ci-dessus sont construites par l'exe'cution
pre'alable du module {\PRIO} (voir la documentation en ligne---{\tt
man~prio}) sur des spe'cifications de priorite's, e'crites par
l'utilisateur et rassemble'es dans un fichier de nom {\it
nom-du-langage}\verb|.prio|.

Une spe'cification e'crite dans le langage {\PRIO} contient deux
parties, chacune e'tant optionnelle\,:
\begin{itemize}
 \item une partie (a) ou` l'on donne les priorite's des ope'rateurs\,;
 \item une partie (b) ou` l'on donne les priorite's des re`gles de
la grammaire.
\end{itemize}

\begin{description}

 \item[(a)] Cette partie de'finit, pour chaque symbole cite' (en
ge'ne'ral un terminal de la grammaire), son type d'associativite'
({\it gauche}, {\it droit}, {\it non associatif\/}) et sa priorite'
relative.

Cette liste est ordonne'e du moins prioritaire vers le plus
prioritaire.  Ainsi
\begin{quote}
\begin{verbatim}
%left + -
%left * /
\end{verbatim}
\end{quote}
de'crit la priorite' et l'associativite' des quatre ope'rations
arithme'tiques usuelles.  L'addition et la soustraction sont
associatives a` gauche et sont moins prioritaires que la
multiplication et la division qui sont elles aussi associatives a`
gauche.

Le mot cle' \verb|%right| est utilise' pour de'finir l'associativite'
droite et le mot cle' \verb|%nonassoc| est utilise' pour de'finir des
ope'rations qui, comme le \verb|.LT.| de FORTRAN, ne peuvent
s'associer avec elles-me^mes.  Ainsi
\begin{quote}
\begin{verbatim}
A .LT. B .LT. C
\end{verbatim}
\end{quote}
est ille'gal en FORTRAN.

 \item[(b)] En re`gle ge'ne'rale, une production prend la priorite' et
l'associativite' de son terminal le plus a` droite (s'il existe).  Il
est possible de modifier cette re`gle ge'ne'rale pour une production,
en e'crivant cette production et en la faisant suivre du mot cle'
\verb|%prec| suivi d'un symbole.  La production prend alors la
priorite' et l'associativite' de ce symbole.  Ce symbole (et donc sa
priorite') doit avoir e'te' de'fini dans la partie~(a).
\end{description}

{\bf Exemple}\,:
Conside'rons la grammaire de la figure~\ref{fig:expr.bnf}.
\begin{figure}[hbtp] \centering
 \caption{Grammaire d'expressions.}
	\label{fig:expr.bnf}
 \tt
 \begin{tabbing}
<EXPR>\ \ \==\ <EXPR> + <EXPR>\ \ \=;	\kill
<EXPR>	\>= <EXPR> + <EXPR>	\>;	\\
<EXPR>	\>= <EXPR> - <EXPR>	\>;	\\
<EXPR>	\>= <EXPR> * <EXPR>	\>;	\\
<EXPR>	\>= <EXPR> / <EXPR>	\>;	\\
<EXPR>	\>= - <EXPR>		\>;	\\
<EXPR>	\>= \%IDENT		\>;
 \end{tabbing}
\end{figure}
Cette grammaire est de toute e'vidence ambigu"e\,; il est cependant
possible de re'soudre aise'ment les conflits, comme le montre la
figure~\ref{fig:expr.prio}.
\begin{figure}[hbtp] \centering
 \caption{De'sambigu"ation de la grammaire d'expressions.}
	\label{fig:expr.prio}
 \tt
 \begin{tabbing}
<EXPR>\ \ \==\ <EXPR> + <EXPR>\ \ \=;	\kill
\%left + -				\\
\%left * /				\\[5pt]
<EXPR>	\>= - <EXPR>		\>; \%prec *
 \end{tabbing}
\end{figure}
La dernie`re re`gle de cette spe'cification indique que la priorite'
et l'associativite' de la production cite'e (donc du ``\verb|-|''
unaire) sont celles de~``\verb|*|''.

Les re`gles de {\sl de'sambigu"ation\/} sont utilise'es par {\CSYNT}
de la fac,on suivante pour re'soudre des conflits\,:
\begin{enumerate}

 \item On enregistre les pre'ce'dences et associativite's des
terminaux (s'il y en a).

 \item Une pre'ce'dence et une associativite' sont associe'es a`
chaque re`gle de la grammaire\,: ce sont la pre'ce'dence et
l'associativite' du symbole terminal le plus a` droite dans cette
re`gle (s'il existe).  Si la construction \verb|%prec| est utilise'e,
la valeur spe'cifie'e vient remplacer la valeur par de'faut.
Certaines re`gles de grammaire et certains terminaux peuvent donc ne
pas avoir de priorite' {\it vel\/} d'associativite'.

 \item Quand un conflit {\sl Shift/Reduce\/} ou {\sl Reduce/Reduce\/} se
produit, si le symbole en conflit ou une re`gle implique'e dans un
{\sl Reduce\/} n'a ni priorite' ni associativite', alors les re`gles
par de'faut (voir page~\pageref{prio-defauts}) s'appliquent et le conflit
est signale'.

 \item Sinon le conflit est re'solu en faveur de l'action ({\sl Shift\/}
ou {\sl Reduce\/}) associe'e a` la pre'ce'dence la plus forte.	Si les
pre'ce'dences sont identiques, alors l'associativite' est utilise'e\,:
associativite' {\sl gauche\/} implique {\sl Reduce\/}, associativite' {\sl
droite\/} implique {\sl Shift\/} et non-associativite' implique {\it
erreur}.  Si le conflit ne peut e^tre re'solu malgre' tout, on
applique les re`gles par de'faut.
\end{enumerate}

La plus grande prudence est vivement conseille'e dans l'emploi des
re`gles de de'sambigu"ation.

\section{Optimisation de l'automate}

Les automates produits par le constructeur LALR(1) sont optimise's
lors d'une deuxie`me phase nomme'e OPTIM.  Les optimisations
effectue'es sont de deux ordres\,:
\begin{description}

 \item[optimisations propres a` l'analyse LR]: L'automate est tout
d'abord partitionne' en trois\,: une partie qui traite les transitions
terminales (les ``T-tables''), une autre s'occupant des transitions
non-terminales (les ``NT-tables'') et une troisie`me partie (les
``Prdct-tables'') qui ge`re le traitement des pre'dicats.

Les automates correspondants sont re'duits.  Les productions simples
{\sl sans se'mantique\/} sont partiellement e'limine'es (cette
e'limination peut e^tre totale, sur option\,: voir la documentation en
ligne---{\tt man~csynt}), les transitions non-terminales (apre`s
re'duction) ne ne'cessitant pas la pile d'analyse sont de'tecte'es et
les NT-tables sont compacte'es.

 \item[techniques de repre'sentation de matrices creuses]: Les
T-tables et les NT-tables sont line'arise'es de fac,on a` conserver
un temps constant pour l'acce`s a` l'information.
\end{description}

Cette forme des tables est bien e'videmment inexploitable
manuellement.  L'utilisateur peut cependant avoir une ide'e de
l'automate a` pile engendre', en utilisant l'option
\verb|-floyd_evans| (voir la documentation en ligne---{\tt man~csynt})
qui permet d'obtenir le listage de l'automate sous une forme
compre'hensible.


\section{Listage de l'automate engendre'}

L'automate a` pile engendre' est partitionne' en trois tables\,:
\begin{itemize}
 \item les ``T-tables'' qui s'occupent des transitions terminales,

 \item les ``NT-tables'' qui s'occupent des transitions
non-terminales,

 \item les ``Prdct-tables'' qui s'occupent du traitement des
pre'dicats.
\end{itemize}

Chacune de ces tables est partitionne'e en {\em blocs}, comprenant une
se'quence d'{\em instructions}.  Chaque bloc est e'tiquete' pour
re'fe'rence, de la fac,on suivante\,:
\begin{description}
 \item{T-bloc} \verb|Etq |$l$\verb|:|

 \item{NT-bloc} \verb|State |$m$\verb|:|

 \item{Prdct-bloc} \verb|Prdct |$n$\verb|:|
\end{description}
A` chaque instruction est associe'e une adresse (nombre entier
positif).  Une instruction est forme'e d'un doublet $(\mbox{test},
\mbox{action})$.  Le premier champ sert a` la se'lection, le second
champ indique l'action a` effectuer lorsque l'instruction a e'te'
se'lectionne'e.

L'analyse commence dans les T-tables, par {\em activation\/} d'un
T-bloc dont l'e'tiquette est pre'cise'e dans le listage.  Le symbole
terminal sous la te^te de lecture est le symbole (fictif) \verb|End Of
File|.

Quand un bloc est active', une instruction et une seule de sa
se'quence est se'lectionne'e et exe'cute'e\,: les instructions sont
examine'es, l'une apre`s l'autre, jusqu'a` en rencontrer une dont le
{\em test\/} soit satisfait.  La dernie`re instruction d'une se'quence
contient toujours un champ {\sl test\/} valant \verb"Any", ce qui
assure une se'lection inconditionnelle de cette instruction.

Le mode de se'lection de'pend de la table conside're'e\,:
\begin{itemize}
 \item Une instruction d'un T-bloc est se'lectionne'e si et seulement
si le symbole terminal sous la te^te de lecture est celui du champ
{\sl test}.

 \item Une instruction d'un NT-bloc est se'lectionne'e si et seulement
si le symbole non-terminal courant, c'est-a`-dire le non-terminal en
partie gauche de la production qui vient d'e^tre reconnue et choisie,
est celui du champ {\sl test}.

 \item Une instruction d'un Prdct-bloc est se'lectionne'e si et
seulement si la fonction utilisateur appele'e avec le parame`tre {\sl
test\/} retourne {\it vrai}.
\end{itemize}

Lorsqu'une instruction est se'lectionne'e, l'action spe'cifie'e par le
deuxie`me champ est exe'cute'e.  Il existe quatre types d'actions\,:
{\em Shift}, {\em Reduce}, {\em Halt\/} et {\em Error}.  Chacun de ces
types est de'crit ci-dessous\,:
\begin{description}
\item[L'action Shift]
correspond au traitement d'une transition (terminale ou
non-terminale)\,; elle est code'e sur trois champs\,:
\begin{quote}
\begin{tabular}{|c|c|c|}
 \hline
  Scan & Stack & Goto	\\
 \hline
\end{tabular}
\end{quote}
Si le champ {\sl Scan\/} contient ``\verb"*"'', le symbole terminal
suivant du texte source est positionne' sous la te^te de lecture\,;
sinon, ce champ est vide et aucune lecture n'est effectue'e.

Le champ {\sl Stack}, obligatoire, contient une information qui est
empile'e sur la pile d'analyse.  Ce peut e^tre soit un nombre
entier~$n$ positif entre parenthe`ses, soit un nombre entier~$n$,
positif ou nul.
\begin{itemize}
 \item {\tt ($n$)} signifie que $n$ est le nume'ro d'un NT-bloc\,;

 \item $n$ signifie que $n$ est l'adresse d'une instruction du
NT-bloc.  Cette instruction, apres une action {\sl Reduce}, pourra
e^tre exe'cute'e inconditionnellement.  Si $n$ est nul, cette adresse
n'est pas significative.
\end{itemize}

Le champ {\sl Goto}, obligatoire, indique le prochain T-bloc qui va
e^tre active' (\verb|Goto Etq |$l$).


\item[L'action Reduce]
correspond au traitement d'une re'duction\,; elle est code'e sur quatre
champs\,:
\begin{quote}
\begin{tabular}{|c|c|c|c|}
 \hline
 Scan & Reduce & Stack & Goto	\\
 \hline
\end{tabular}
\end{quote}

Si le champ {\sl Scan\/} contient ``\verb"*"'', le symbole terminal
suivant du texte source est positionne' sous la te^te de lecture\,;
sinon, ce champ est vide et aucune lecture n'est effectue'e.

Le champ {\sl Reduce\/} contient un nombre entier positif~$p$ qui est
le nume'ro de la re`gle de grammaire qui vient d'e^tre reconnue et
choisie.

Le champ {\sl Stack\/} contient un certain nombre (e'ventuellement
nul) de barres verticales~``\verb"|"'', qui indiquent le nombre dont
la pile d'analyse est e'cre^te'e. Ce nombre est, pour une instruction
d'un T-bloc, la longueur de la
partie droite de la production~$p$, cette longueur
diminue'e de un pour un NT-bloc.

Le champ {\sl Goto\/} contient soit un non-terminal \verb|<nt>| spe'cifie' par
\begin{quote}
 \verb|Goto Branch_Table (<nt>, Top_Stack_State)|
\end{quote}
soit une adresse \verb|n| spe'cifie'e par
\begin{quote}
 \verb|Goto n|
\end{quote}
Ce champ est interpre'te' de la fac,on suivante\,: apre`s avoir
e'cre^te' la pile d'analyse de la longueur spe'cifie'e par le champ
{\sl Stack}, on examine le contenu du champ {\sl Goto}.  Si c'est
\verb|Goto |$n$, on va exe'cuter inconditionnellement l'instruction
nume'ro~$n$.  Sinon, on examine le sommet de la pile d'analyse.  Si
c'est l'adresse d'une instruction (voir action {\sl Shift\/}), on va
exe'cuter inconditionnellement cette instruction (on ne peut jamais
trouver l'adresse~ze'ro).  Sinon, le sommet de pile de'signe un
NT-bloc qui est active' et l'on recherche dans sa liste d'instructions
le non-terminal spe'cifie' dans le champ {\sl Goto}.  Ce
non-terminal~\verb|<nt>| est en ge'ne'ral le non-terminal se trouvant
en partie gauche de la production nume'ro~$p$ (du champ {\sl
Reduce\/}) mais, du fait des optimisations, ce peut e^tre un autre
non-terminal ou me^me un non-terminal ``invente''' par l'optimiseur
(de'note' par un nombre entier~$n$ compris entre un ``\verb">"'' et un
``\verb"<"''---donc ``{\tt >$n$<}'').

\item[L'action Halt]
marque la fin de la reconnaissance du texte.

\item[L'action Error]
indique la de'tection d'une erreur de syntaxe.  Elle provoque
l'exe'cution d'un programme de rattrapage d'erreur (voir le
chapitre~\ref{chap:erreurs}).
\end{description}


En fait, les instructions qui viennent d'e^tre de'crites sont une
forme simplifie'e d'un langage permettant de coder des automates a`
pile de'terministes et dont les instructions sont appele'es {\em
productions de Floyd-Evans}.

Une production de Floyd-Evans comporte cinq champs\,:
\begin{quote}
\begin{tabular}{|c|c|c|c|c|}
 \hline
 Test & Scan & Reduce & Stack & Goto	\\
 \hline
\end{tabular}
\end{quote}

Il y a dix types diffe'rents de productions de Floyd-Evans\,:

\begin{center}
 \newcommand\reduc{n$^\circ$ de re'duction}
 \newcommand\depil{\verb:|:$\cdots$}
 \newcommand\test{test}
 \newcommand\etat{{\tt(}n$^\circ$ de NT-bloc{\tt)}}
 \newcommand\etq{n$^\circ$ de T-bloc}
 \newcommand\adresse{adresse}
 \newcommand\nt{non-terminal}
\begin{tabular}{|c|c|c|c|c|}
\hline
Test	& Scan	& Reduce	& Stack		& Goto	\\
\hline
\test	& *	&		& \etat		& \etq	\\
\test	& *	&		& \adresse	& \etq	\\
\test	&	&		& \etat		& \etq	\\
\test	&	&		& \adresse	& \etq	\\
\test	& *	& \reduc	& \depil	& \adresse	\\
\test	& *	& \reduc	& \depil	& \nt	\\
\test	&	& \reduc	& \depil	& \adresse	\\
\test	&	& \reduc	& \depil	& \nt	\\
\test	&	&		&		& {\tt Halt}	\\
\test	&	&		&		& {\tt Error}	\\
\hline
\end{tabular}
\end{center}

{\bf Remarque}\,: Afin de faciliter l'exploitation manuelle de
l'automate, le code des NT-tables est pre'sente' dans le listage
successivement sous deux formes\,:
\begin{enumerate}
 \item La premie`re partie, organise'e comme on l'a pre'sente'
ci-dessus, regroupe se'quentiellement les instructions de chaque
NT-bloc.  Cette pre'sentation n'est exploite'e que lorsque le sommet
de pile, apres e'cre^tage, repre'sente un nume'ro de NT-bloc et le
champ {\sl Goto\/} de l'instruction spe'cifie un non-terminal.

 \item Dans la seconde pre'sentation, qui, elle, est exhaustive, les
instructions sont repe're'es par leur nume'ro et sont exe'cute'es
inconditionnellement\,; c'est la partie qui doit e^tre utilise'e lorsque
le champ {\sl Goto\/} d'une instruction {\sl Reduce\/} est \verb|Goto
|$n$ ou lorsque le sommet de pile apre`s e'cre^tage est une adresse.

\end{enumerate}


\section{Mise en oeuvre}

Se reporter a` la documentation en ligne---{\tt man~bnf}.

\chapter[LECL -- Construction de l'Analyseur Lexical]
{LECL~: \\ Construction de l'Analyseur Lexical}
	\label{chap:lecl}

{\LECL} est le constructeur lexical de {\SYNTAX}.  Nombre de ses
caracte'ristiques ont e'te' emprunte'es a` son pre'de'cesseur {\it
new\_10cl}, mais il s'en distingue notamment par une plus grande
facilite' de description et une plus grande puissance de
spe'cification.

{\LECL} a pour donne'es, d'une part la description des unite's
lexicales du langage sous forme d'expressions re'gulie`res, fournie
par l'utilisateur, et d'autre part des informations extraites des
tables produites par {\BNF} ({\it nom-du-langage}\verb|.bt|)\,; son
ro^le est de produire un automate d'e'tats finis capable d'effectuer
la reconnaissance des terminaux du niveau syntaxique.

\section{Me'talangage lexical}

La spe'cification d'un analyseur lexical en {\LECL} est un texte qui
doit ve'rifier une certaine syntaxe.  Le langage {\LECL} peut donc se
de'crire a` l'aide du syste`me {\SYNTAX}---voir
l'annexe~\ref{annexe:lecl.spec}.

Informellement, le niveau lexical de {\LECL} se de'finit comme suit\,:
\begin{itemize}

 \item C'est un langage non positionnel (le placement d'une unite'
lexicale dans une ligne est sans importance) qui comporte des mots
cle's re'serve's.

 \item Les mot cle's de {\LECL}, au nombre de 43, sont re'pertorie's
dans la table~\ref{fig:lecl.kw}.
\begin{table}[hbtp] \centering
 \caption{Les mots cle's de {\LECL}.}
	\label{fig:lecl.kw}
 \vspace{1ex}
 \begin{tabular}{lll}
	\verb|&FALSE|		&
	\verb|&IS_FIRST_COL|	&
	\verb|&IS_LAST_COL|	\\
	\verb|&IS_RESET|	&
	\verb|&IS_SET|		&
	\verb|&TRUE|		\\[10pt]

	\verb|@DECR|		&
	\verb|@ERASE|		&
	\verb|@INCR|		\\
	\verb|@LOWER_CASE|	&
	\verb|@LOWER_TO_UPPER|	&
	\verb|@MARK|		\\
	\verb|@PUT|		&
	\verb|@RELEASE|		&
	\verb|@RESET|		\\
	\verb|@SET|		&
	\verb|@UPPER_CASE|	&
	\verb|@UPPER_TO_LOWER|	\\[10pt]

	\verb|ABBREVIATIONS|	&
	\verb|ALL|		&
	\verb|BITS|		\\
	\verb|BUT|		&
	\verb|BYTE|		&
	\verb|CLASSES|		\\
	\verb|CODE|		&
	\verb|COMMENTS|		&
	\verb|CONTEXT|		\\
	\verb|END|		&
	\verb|END_OF_FILE|	&
	\verb|EOF|		\\
	\verb|FOR|		&
	\verb|INCLUDE|		&
	\verb|INTERNAL|		\\
	\verb|PRIORITY|		&
	\verb|REDUCE|		&
	\verb|SHIFT|		\\
	\verb|SYNONYMS|		&
	\verb|TOKENS|		&
	\verb|UNBOUNDED|	\\
	\verb|UNION|		&
	\verb|UNUSED|		&
	\verb|USE|		\\
	\verb|WORD|
 \end{tabular}
 \vspace{1ex}
\end{table}

Les mots cle's commenc,ant par ``\verb|&|'' repre'sentent les {\sl
pre'dicats syste`me\/} (voir en~\ref{sec:predicats-lecl}), ceux
commenc,ant par ``\verb|@|'' repre'sentent les {\sl actions
syste`me\/} (voir en~\ref{sec:actions-lecl}).

 \item L'ensemble des caracte`res ASCII est licite.

 \item Les identificateurs sont forme's d'une lettre suivie d'un nombre
quelconque (e'ventuellement nul) de lettres ou de chiffres pouvant
e^tre pre'ce'de's d'un blanc souligne' (``\verb|_|'').

 \item La capitalisation des lettres n'a aucune influence sur la
signification des identificateurs ou des mots cle's.

 \item Certains identificateurs peuvent repre'senter des terminaux du
niveau syntaxique ou` la capitalisation est significative.  Si ces
terminaux comportent des lettres minuscules, il faut les repre'senter
comme des chai^nes de caracte`res (entre guillemets) en conservant la
capitalisation utilise'e dans {\BNF}.

 \item Un commentaire est introduit par deux signes moins (``\verb|--|'') et
se termine a` la premie`re fin de ligne rencontre'e.

 \item Les chai^nes de caracte`res sont repre'sente'es entre guillemets
(``\verb|"|'').	 Ces guillemets de'limitent un nombre strictement
positif de caracte`res quelconques dont la convention de
repre'sentation est celle du langage~C---voir en
page~\pageref{fig:conventions-C}.
\end{itemize}

La de'finition syntaxique du langage est divise'e en cinq parties.
Chacune de ces parties est optionnelle.

\subsection{Les classes}

Le vocabulaire terminal du niveau lexical est ge'ne'ralement un
sous-ensemble des caracte`res valides pour une machine donne'e\,: ASCII,
EBCDIC\ldots

Cependant, l'utilisation directe et syste'matique des caracte`res
comme vocabulaire terminal des expressions re'gulie`res peut
\begin{itemize}
 \item e^tre malcommode pour l'utilisateur
 \item engendrer un grand nombre d'e'tats pour l'automate
\end{itemize}
d'ou` l'introduction de la notion de {\sl classe}.

Une classe est un ensemble de caracte`res qui jouent un ro^le
identique a` un moment donne'.

{\bf Exemple}\,: Dans la de'finition des identificateurs, les lettres
jouent un ro^le analogue\,; d'un point de vue lexical le fait important
est d'avoir une lettre et non de connai^tre son nom.  Dans un
identificateur l'ensemble des lettres majuscules ou minuscules peut
donc constituer une {\sl classe}.

Il existe un certain nombre de classes pre'de'finies en {\LECL}.  Le
nom de ces classes n'est pas re'serve', l'utilisateur peut donc les
rede'finir s'il le de'sire.  La table~\ref{fig:classes-composees}
liste l'ensemble des classes qui ont e'te' pre'de'finies pour
simplifier l'e'criture des spe'cifications {\LECL}, et la
table~\ref{fig:classes-simples} donne les noms qui sont associe's aux
caracte`res non imprimables du code ASCII.

\begin{table}[hbtp] \centering
 \caption{Classes pre'de'finies pour le confort de l'utilisateur.}
	\label{fig:classes-composees}
 \vspace{1ex}
 \begin{tabular}{|cc|}
  \hline
	Nom		& Signification				\\
  \hline
	\verb|ANY|	& Ensemble des caracte`res ASCII	\\
	\verb|EOL| ou \verb|NL| & Fin de ligne (code octal 012) \\
	\verb|LETTER|	& Les lettres, majuscules et
				minuscules			\\
	\verb|LOWER|	& Les lettres minuscules		\\
	\verb|UPPER|	& Les lettres majuscules		\\
	\verb|DIGIT|	& Les chiffres de'cimaux		\\
	\verb|QUOTE|	& Caracte`re ``\verb|"|'' (Code octal
				042)				\\[5pt]

	\verb|A|	& ``\verb|Aa|''				\\
	\verb|B|	& ``\verb|Bb|''				\\
	\vdots		& \vdots				\\
	\verb|Z|	& ``\verb|Zz|''				\\
   \hline
 \end{tabular}
\end{table}
\begin{table}[hbtp] \centering
 \caption{Classes pre'de'finies pour les caracte`res non-imprimables.}
	\label{fig:classes-simples}
 \vspace{1ex}
 \begin{tabular}{|ccl|}
  \hline
	Nom & \multicolumn{2}{l|}{Code ASCII (octal)}	\\
  \hline
	\verb|NUL|	& 000	&	\\
	\verb|SOH|	& 001	&	\\
	\verb|STX|	& 002	&	\\
	\verb|ETX|	& 003	&	\\
	\verb|EOT|	& 004	&	\\
	\verb|ENQ|	& 005	&	\\
	\verb|ACK|	& 006	&	\\
	\verb|BEL|	& 007	&	\\
	\verb|BS|	& 010	& {\small Back-Space}	\\
	\verb|HT|	& 011	& {\small Horizontal-Tabulation} \\
	\verb|LF|	& 012	& {\small Line-Feed}	\\
	\verb|VT|	& 013	& {\small Vertical-Tabulation}	\\
	\verb|FF|	& 014	& {\small Form-Feed}	\\
	\verb|CR|	& 015	& {\small Carriage-Return}	\\
	\verb|SO|	& 016	&	\\
	\verb|SI|	& 017	&	\\
	\verb|DLE|	& 020	&	\\
	\verb|DC1|	& 021	&	\\
	\verb|DC2|	& 022	&	\\
	\verb|DC3|	& 023	&	\\
	\verb|DC4|	& 024	&	\\
	\verb|NAK|	& 025	&	\\
	\verb|SYN|	& 026	&	\\
	\verb|ETB|	& 027	&	\\
	\verb|CAN|	& 030	&	\\
	\verb|EM|	& 031	&	\\
	\verb|SUB|	& 032	&	\\
	\verb|ESC|	& 033	&	\\
	\verb|FS|	& 034	&	\\
	\verb|GS|	& 035	&	\\
	\verb|RS|	& 036	&	\\
	\verb|US|	& 037	&	\\
	\verb|SP|	& 040	& {\small Space} \\
	\verb|DEL|	& 177	&	\\
   \hline
 \end{tabular}
 \vspace{1ex}
\end{table}

Une classe est {\sl nomme'e\/} si l'ensemble des caracte`res qui la
composent a rec,u un nom.  Cette de'finition est l'objet de la
premie`re partie d'un source {\LECL}, dans laquelle on de'finit les
classes nomme'es en regroupant tous les caracte`res les composant.

Cette de'finition de'bute par le mot cle' \verb|CLASSES|.

Une classe se de'finit par un nom ({\sl identificateur\/}), suivi du symbole
``\verb|=|'', suivi d'une expression\,; la de'finition se termine par un ``\verb|;|''.

L'expression utilise'e admet
\begin{description}

 \item[comme ope'randes]:
  \begin{itemize}
   \item des classes pre'de'finies\,;

   \item des chai^nes de caracte`res (l'ensemble des caracte`res de la
chai^ne appartient a` la classe)\,;

   \item des codes octaux (nombre octal de trois chiffres pre'ce'de'
du caracte`re ``\verb|#|''), dont la valeur est la repre'sentation
interne en ASCII du caracte`re de'signe'\,;

   \item des intervalles de'crivant une suite de caracte`res dont les
codes internes sont contigus\,; un intervalle est repre'sente' par le
premier et le dernier caracte`re de la se'quence, se'pare's par
``\verb|..|''.	Ces caracte`res marquant le de'but et la fin de la
se'quence sont repre'sente's, soit par le caracte`re entre guillemets,
soit par son code interne exprime' en octal et pre'ce'de' du
caracte`re ``\verb|#|'', soit par le nom (s'il existe) de ce
caracte`re.  L'ordre sous-jacent est celui de l'ASCII et le code
interne du premier caracte`re d'un intervalle doit bien entendu e^tre
infe'rieur ou e'gal a` celui du second.

   \item des classes nomme'es de'finies pre'alablement\,;
  \end{itemize}

 \item[comme ope'rateurs] (binaires infixes)\,:
  \begin{itemize}
   \item l'union ensembliste\,: ``\verb|+|''\,;
   \item la diffe'rence ensembliste\,: ``\verb|-|''.
  \end{itemize}
\end{description}

Une classe est {\sl anonyme\/} si sa de'notation apparai^t directement
a` l'endroit de son utilisation (par exemple dans une expression
re'gulie`re).

Tous les caracte`res licites doivent e^tre de'finis.  Cette
de'finition peut e^tre explicite ou implicite.  Un caracte`re est
de'fini explicitement s'il apparai^t dans une de'finition de classe
(nomme'e ou anonyme)\,; il est de'fini implicitement s'il intervient
dans le nom d'un terminal non-ge'ne'rique du niveau syntaxique alors
qu'il n'est pas explicitement de'fini.

Tout caracte`re non de'fini (implicitement ou explicitement) est un
caracte`re {\sl interdit} dans le langage.

\begin{figure}[hbtp]
 \caption[De'finition de classes.]
	{Exemple de de'finition de classes.}
\begin{verbatim}
Classes
   tout_sauf_EOL   = ANY - EOL ;
   tout_sauf_quote = ANY - quote ;
   printable       = ANY - (#000..SP + #177) ;
\end{verbatim}
\end{figure}

\subsection{Les abre'viations}

Afin d'e'viter l'e'criture fastidieuse de sous-expressions
re'gulie`res identiques, il est possible de nommer de telles
expressions et d'utiliser ce nom dans une expression re'gulie`re
ulte'rieure.  Toute occurrence du nom d'une expression re'gulie`re est
se'mantiquement e'quivalente a` une occurrence parenthe`se'e de
l'expression qu'elle de'note.

Cette rubrique de'bute par le mot cle' \verb|ABBREVIATIONS|.

Une abre'viation se de'finit par un nom ({\sl identificateur\/}),
suivi du symbole ``\verb|=|'', suivi d'une expression re'gulie`re
(voir en~\ref{sec:expressions-regulieres})\,; la de'finition est
termine'e par un ``\verb|;|''.

On peut e'galement de'finir dans cette partie des expressions de
pre'dicats (voir en~\ref{sec:predicats-lecl}).

\subsection{Les unite's lexicales}

La de'finition lexicale se poursuit par la de'finition des expressions
re'gulie`res qui permettent de reconnai^tre les diffe'rentes unite's
lexicales du langage.

Cette de'finition de'bute par le mot cle' \verb|TOKENS|.

Une de'finition d'unite' lexicale s'e'crit dans le cas le plus simple
de la manie`re suivante\,: un nom d'unite' lexicale, suivi du symbole
``\verb|=|'', suivi d'une expression re'gulie`re termine'e par un
``\verb|;|''\,; ce ``\verb|;|'' peut e^tre e'ventuellement suivi d'une
spe'cification de priorite', de contexte ou de post-action (voir
en~\ref{sec:conflits} et~\ref{sec:actions-lecl}).

Un nom d'unite' lexicale peut e^tre\,:
\begin{itemize}
 \item le mot cle' \verb|COMMENTS|\,;
 \item le mot cle' \verb|INCLUDE|\,;
 \item un terminal ge'ne'rique (voir en~\ref{sec:lexico-bnf})\,;
 \item une chai^ne de caracte`res (terminal du langage entre
guillemets)\,;
 \item le mot cle' \verb|EOF| (pour ``{\em E}nd {\em O}f {\em F}ile'',
voir plus loin)\,;
 \item un identificateur (dont le nom n'est pas significatif).
\end{itemize}

L'unite' lexicale de nom ``\verb|COMMENTS|'' de'finit les {\sl
commentaires}.	L'expression re'gulie`re de sa partie droite doit
de'crire non seulement les commentaires du langage mais e'galement les
{\sl espacements\/} entre les symboles terminaux (blanc, fin de ligne,
{\it et cetera\/}).

L'unite' lexicale de nom ``\verb|INCLUDE|'' permet de de'finir des {\sl
includes\/} (voir en~\ref{sec:includes}).

Les terminaux ge'ne'riques sont les seuls qui doivent obligatoirement
e^tre de'finis au niveau lexical.  Les autres terminaux sont traite's
par {\LECL} de la fac,on suivante\,:
\begin{quotation}
Pour un terminal donne' non de'fini (c'est-a`-dire dont le nom
n'apparai^t pas en partie gauche d'unite' lexicale), {\LECL} regarde s'il
est reconnu par l'expression re'gulie`re d'une unite' lexicale\,:
 \begin{itemize}
  \item si non\,: {\LECL} engendre automatiquement l'expression re'gulie`re
le reconnaissant, caracte`re par caracte`re.
  \item si oui\,: ce terminal est range' dans une table qui sera
utilise'e par l'{\sl analyseur lexical}.
 \end{itemize}
\end{quotation}

Lors de l'analyse lexicale, si une chai^ne de caracte`res est reconnue
par une expression re'gulie`re, plusieurs cas peuvent se produire\,:
\begin{itemize}

 \item L'unite' lexicale est ``\verb|EOF|'' ({\sl End Of File\/})\,:
l'analyseur lexical renvoie le {\sl code\/} de ``\verb|EOF|'' a`
l'analyseur syntaxique.

 \item L'unite' lexicale est un terminal\,: l'analyseur lexical renvoie
le code du terminal et me'morise la chai^ne de caracte`res dans une
table.  Cette table est manipulable par l'interme'diaire des
proce'dures du ``\verb|string_manager|'' (voir la documentation en
ligne---{\tt man~sxstr\_mngr}).

 \item L'unite' lexicale est ``\verb|COMMENTS|''\,: les caracte`res
composant cette unite' sont accessibles (s'ils ont e'te' conserve's)
par l'interme'diaire de la structure ``\verb|sxterminal_token|'' (voir
la documentation en ligne---{\tt man~sxunix}) associe'e a` l'unite'
lexicale qui suit ces commentaires.
\end{itemize}

{\bf Exemple}\,:
Dans la de'finition syntaxique on trouve la re`gle\,:
\begin{verbatim}
   <expression>   =    <expression>    PLUS    <terme>    ;
\end{verbatim}
et au niveau lexical, on trouve\,:
\begin{verbatim}
   PLUS    =  "+" ;
\end{verbatim}

``\verb|PLUS|'' est un terminal du langage.  Lorsque l'analyseur
lexical reconnai^t la chai^ne ``\verb|+|'', il renvoie le code du
terminal ``\verb|PLUS|''.


{\bf Remarque}\,: L'unite' lexicale ``\verb|EOF|'' permet a`
l'utilisateur de pre'ciser que ses fichiers se terminent par une
certaine chai^ne de caracte`res.  Si l'on ne mentionne pas \verb|EOF|
dans les unite's lexicales, le syste`me ge'ne`rera un \verb|EOF| lors
de la reconnaissance de la fin physique du fichier.


\subsubsection{Les mots cle's}
	\label{sec:mot-cle}
Par de'finition un {\sl mot cle'\/} est un terminal non ge'ne'rique
qui est reconnu par une unite' lexicale dont le nom est diffe'rent de
celui du mot cle'.

{\bf Exemple}\,:
\begin{verbatim}
   %ID = LETTER {LETTER | DIGIT} ;
\end{verbatim}

Supposons que le terminal ``\verb|begin|'' apparaisse dans la
grammaire syntaxique, mais ne soit pas de'crit au niveau lexical.  La
chai^ne de caracte`res ``\verb|begin|'' e'tant reconnue par
\verb|%ID|, le terminal ``\verb|begin|'' est par de'finition un mot
cle'.

{\LECL} construit le texte en langage C d'une fonction de nom
\verb|check_keyword| qui permet de ve'rifier si une chai^ne est ou non
un mot cle'.  Le texte de cette fonction fait partie inte'grante des
tables d'analyse produites par le module {\TABLESC}---voir le
chapitre~\ref{chap:tablesc}.  Chaque fois qu'un terminal est reconnu
par une unite' lexicale pouvant reconnai^tre des mots cle's,
l'analyseur lexical appelle \verb|check_keyword| qui retourne\,:
\begin{itemize}

 \item $0$\,: le terminal n'est pas un mot cle'\,; le code retourne' par
l'analyseur lexical est celui de l'unite' lexicale (\verb|%ID| dans
l'exemple)\,;

 \item $n>0$\,: le terminal est un mot cle' de code interne $n$.
\end{itemize}

Si l'unite' lexicale est un identificateur qui n'est le nom d'aucun
terminal du langage, l'analyseur lexical effectue la me^me recherche
en table que dans le cas pre'ce'dent.  Si cette recherche re'ussit,
l'analyseur lexical retourne a` l'analyseur syntaxique le code du
terminal (mot cle') ainsi reconnu.  Dans le cas contraire, il e'limine
purement et simplement la chai^ne reconnue (en signalant une erreur)
et ne renvoie pas de code.  Ce genre d'unite' lexicale permet donc de
de'crire un ensemble de terminaux du langage par une expression
re'gulie`re unique, dans le cas ou` ils ne peuvent pas e^tre reconnus
par un terminal ge'ne'rique.

{\bf Exemple}\,: Dans le langage {\LECL}, les se'quences de caracte`res
{\tt @DECR}, {\tt @ERASE}, {\ldots} sont des mots cle's re'serve's qui
de'signent des actions pre'de'finies.  Dans la version actuelle du langage
ces mots cle's sont au nombre de 12.  De plus, toute autre se'quence de caracte`res
ve'rifiant l'expression re'gulie`re
\begin{quote}
\begin{verbatim}
"@" LETTER {["_"] LETTER}
\end{verbatim}
\end{quote}
est errone'e.  La description des ces mots cle's est re'alise'e simplement
par l'ajout de la de'finition
\begin{quote}
\begin{verbatim}
KEYWORD = "@" LETTER {["_"] LETTER};
\end{verbatim}
\end{quote}
ou` {\tt KEYWORD} est un identificateur qui n'est pas un symbol terminal
de la grammaire du niveau syntaxique du langage {\LECL}.

De plus, le source d'une spe'cification {\LECL} a pu e^tre cre'e' par un
programme (paragrapheur ou autre) qui a produit les mots cle's en gras.
Chaque caracte`re "{\tt c}" d'un mot cle' a pu e^tre superpose' un certain
nombre de fois sur lui-me^me (par la se'quence \verb|"c" {BS "c"}+| pour
cre'er une impression de gras.  Chaque mot cle' peut donc maintenant avoir
un nombre infini de repre'sentations dont la reconnaissance, si on adopte
la philosophie prone'e par {\LECL} (de'grossissage de la reconnaissance
par une expression re'gulie`re puis utilisation de la fonction \verb|check_keyword|
ge'ne're'e automatiquement) ne'cessite l'obtention d'une forme normale.  Or {\LECL}
a la possibilite' de modifier la chai^ne source (voir en~\ref{sec:operateur-moins}
et~\ref{sec:actions-lecl}) pour obtenir une forme interne qui sera re'ellement
utilise'e.  Ainsi les expressions re'gulie`res
\begin{quote}
\begin{verbatim}
DARK_A   = "A" -{BS "A"}+ | "a" -{BS "a"}+ ;
DARK_B   = "B" -{BS "B"}+ | "b" -{BS "b"}+ ;
         .
         .
DARK_LET = DARK_A | DARK_B | ... ;    
\end{verbatim}
\end{quote}
permettent de de'finir des lettres grasses dont la forme normale contient
une lettre unique.  L'expression re'gulie`re
\begin{quote}
\begin{verbatim}
DARK_WORD = DARK_LET {[DARK_US] DARK_LET} ;
\end{verbatim}
\end{quote}
ou`
\begin{quote}
\begin{verbatim}
DARK_US = "_" -{BS "_"}+ ;
\end{verbatim}
\end{quote}
de'crit un identificateur dont la forme externe est "grasse{}" et dont
la forme normale est e'pure'e.

Il serait alors agre'able que la de'finition

\begin{quote}
\begin{verbatim}
KEYWORD = "@" DARK_WORD ;
\end{verbatim}
\end{quote}
permette automatiquement de reconnai^tre les mots cle's de'signant les
actions syste`me (et de ge'ne'rer la fonction \verb|check_keyword|).  Or
du fait de la pre'sence de l'ope'rateur "{\tt +}" dans la de'finition d'une
lettre grasse, chaque lettre est re'pe'te'e au moins deux fois et ne
correspond donc pas a` la forme normale bien que la forme interne obtenue
apre`s application de l'ope'rateur "{\tt -}" soit la forme normale du mot cle'.
Pour que l'utilisation pre'ce'dente soit possible, la de'finition des mots cle's a e'te'
(le'ge`rement) modifie'e\,:
\begin{quote}
Un mot cle' est un terminal non ge'ne'rique qui\,:
\begin{itemize}
 \item soit est reconnu par une unite' lexicale dont le nom est celui
d'un terminal (ge'ne'rique ou non) de la grammaire du niveau syntaxique,
diffe'rent de celui du mot cle'\,;

\item soit est la forme interne obtenue apre`s reconnaissance et application
(e'ventuelle) des ope'rateurs "{\tt -}" par une unite' lexicale dont le nom
n'est pas celui d'un terminal du niveau syntaxique.
\end{itemize}
\end{quote}

Cette possibilite' est utilise'e de fac,on intensive dans la description
du niveau lexical de {\LECL} lui-me^me (voir en annexe B.2).


Afin de de'terminer statiquement (a` la construction) si un terminal
du langage est un mot cle', {\LECL} recherche s'il existe au moins une
expression re'gulie`re qui de'crit le terminal conside're' (le
terminal appartient-il au langage de'fini par l'expression
re'gulie`re\,?).  Or les expressions re'gulie`res peuvent contenir des
actions et des pre'dicats utilisateur qu'il est bien entendu
impossible d'exe'cuter a` la construction.  La possibilite' de
manipuler des variables globales (dont les valeurs peuvent e^tre
utilise'es d'une unite' lexicale a` une autre) spe'cifiant par exemple
des contextes de reconnaissance, interdit e'galement la connaissance statique
du re'sultat de l'exe'cution de pre'dicats syste`me.  Afin de
ne pas ``oublier'' des possibilite's de reconnaissance de mots cle's,
{\LECL} suppose, pour cette reconnaissance des mots cle's a` la
construction, que tous les pre'dicats dynamiques retournent {\tt
VRAI}.  De ce fait, {\LECL} est susceptible de de'cre`ter que telle
unite' lexicale reconnai^t tel mot cle', alors qu'il n'en est rien.
Ge'ne'ralement, cet abus n'est pas dommageable.


Pour des raisons analogues il n'est pas en ge'ne'ral possible pour {\LECL} de
connai^tre a` la construction la forme interne d'une chai^ne re'sultant
de la reconnaissance d'une chai^ne source.  {\LECL} est donc susceptible
de "rater" la reconnaissance de certains mots cle's.


Afin de pallier cette faiblesse et de permettre un contro^le plus fin,
l'utilisateur a la possibilite' de modifier le comportement pre'ce'dent
en indiquant explicitement si telle ou telle unite' lexicale reconnait
tel ou tel mot cle'.  Pour ce faire il est possible d'inse'rer une clause
mot cle' apre`s la de'finition d'une unite' lexicale.  Cette clause spe'cifie
le comportement de cette unite' lexicale vis a` vis des mots cle's.

Cette clause, si elle est pre'sente, doit suivre
\begin{itemize}
 \item le ``\verb|;|'' marquant la fin d'une expression re'gulie`re
de'finissant une unite' lexicale

 \item ou le ``\verb|;|'' marquant la fin d'une spe'cification de
``post-action''

 \item ou le ``\verb|;|'' marquant la fin d'une clause contexte.
\end{itemize}

Elle peut avoir les formes suivantes\,:
\begin{itemize}
\item \verb|NOT KEYWORD [ALL] ;|	
indique qu'en aucun cas, l'unite'
lexicale a` laquelle elle est rattache'e ne peut reconnai^tre de mot cle'.

\item \verb|KEYWORD [ALL] ;|	
indique que l'unite'
lexicale a` laquelle elle est rattache'e reconnait tous les mots cle's.

\item \verb|KEYWORD a, b, ... ;|	
indique que l'unite'
lexicale a` laquelle elle est rattache'e ne reconnait que les mots cle's
de la liste ({\tt a}, {\tt b}, \ldots).

\item \verb|KEYWORD ALL BUT a, b, ... ;|	
indique que l'unite'
lexicale a` laquelle elle est rattache'e ne reconnait que les mots cle's
qui n'appartiennent pas a` la liste ({\tt a}, {\tt b}, \ldots).

\end{itemize}


{\bf Remarque}\,: Pour des raisons de compatibilite' avec les versions pre'ce'dentes
\verb|NOT| et \verb|KEYWORD| sont des mots cle's non re'serve's de {\LECL}.


{\bf Remarque}\,: Les unite's lexicales \verb|Comments| et \verb|Include| ne
permettent pas de de'finir des mots cle's.

\subsection{Les synonymes}

Si cette rubrique est pre'sente,
elle est introduite par le mot cle' \verb|SYNONYMS|.  Elle permet
d'associer une liste de synonymes a` chaque terminal du niveau
syntaxique.

Deux synonymes sont deux symboles qui vont jouer exactement le me^me
ro^le du point de vue syntaxique (ils auront le me^me code interne),
mais qui ont des repre'sentations diffe'rentes au niveau lexical.

La spe'cification de synonymes, utilise'e essentiellement pour les
mots cle's, permet de diminuer le nombre des symboles terminaux de la
grammaire syntaxique, ce qui diminue en conse'quence la taille de
l'automate a` pile engendre' par le constructeur syntaxique.

\begin{figure}[hbtp]
 \caption[De'finition de synonymes.]
	{Exemple de de'finition de synonymes.}

\begin{verbatim}
Synonyms
   DECLARE   = DECL, DCL ;
   PROCEDURE = PROC ;
   POINTER   = PTR ;
\end{verbatim}

``\verb|DECLARE|'' est un terminal du niveau syntaxique, tandis que
``\verb|DECL|'' et ``\verb|DCL|'' n'en sont pas.  Cette de'finition
signifie que trouver ``\verb|DECL|'' ou ``\verb|DCL|'' dans un texte
est e'quivalent a` y trouver ``\verb|DECLARE|''.
 \vspace{1ex}
\end{figure}

\subsection{La spe'cification de repre'sentation}

Cette dernie`re rubrique, si elle est pre'sente, permet de
construire un analyseur lexicographique pour une machine diffe'rente
de la machine ho^te.  On peut indiquer la repre'sentation interne des
caracte`res utilise'e par la machine cible, ainsi que les longueurs de
l'octet---{\it byte}---et du mot---{\it word}---de cette machine
cible.

La syntaxe est la suivante---$n$ et $m$ e'tant deux entiers positifs\,:
\begin{quote} \tt 
  For Internal Code Use {\it liste\_de\_composants\/} ;	\\
  For Byte Use $n$ Bits ;				\\
  For Word Use $m$ Bits ;
\end{quote}

Les {\it composants\/} sont se'pare's par des virgules et indiquent,
pour chaque index (en partant de 0), si le nombre associe' correspond
a` une repre'sentation interne d'un caracte`re ou non, et dans
l'affirmative, pre'cisent ce caracte`re\,:
\begin{itemize}
 \item ``\verb|UNUSED|'' ou ``$n$ \verb|UNUSED|''\,: un nombre ou $n$
nombres conse'cutifs ne sont pas des repre'sentations internes de
caracte`res\,;
 \item un code octal ou une chaine de caracte`res\,: fournissent une ou
plusieurs correspondances
``caracte`re~$\rightleftharpoons$~repre'sentation interne''.
\end{itemize}


\begin{figure}[hbtp]
 \caption[Spe'cification de repre'sentation.]
	{Exemple de spe'cification de repre'sentation.}
\begin{verbatim}
        For Internal Code Use 10 Unused, "01", Unused, #012 ;
\end{verbatim}

Les repre'sentations internes sont\,: {\it 10\/} pour le caracte`re
``\verb|0|'', {\it 11\/} pour le caracte`re ``\verb|1|'' et {\it 13\/}
pour le caracte`re ASCII de code 10---``012'' en octal.	 Dans la
machine cible, les codes internes {\it 0\/} a` {\it 9\/} et {\it 12\/}
correspondent a` des caracte`res ille'gaux.
 \vspace{1ex}
\end{figure}

\subsection{Les expressions re'gulie`res}
	\label{sec:expressions-regulieres}

Le vocabulaire des expressions re'gulie`res est forme' par les noms de
classes (pre'de'finies, nomme'es ou anonymes) , d'abre'viations,
d'actions et de pre'dicats.

Une expression re'gulie`re est une liste d'alternatives se'pare'es par
des ``\verb"|"'' (ou).

Une alternative est de'finie par les re`gles suivantes\,:
\begin{quote} \tt
 \newcommand\expreg{{\it expression r\a'{e}guli\a`{e}re\/}}
\begin{tabbing}
 \quad <{\it alternative\/}>\ \ \=::\== \=				\kill
 <{\it alternative\/}>
  \>::=\>\>	<{\it alternative\/}> <{\it facteur\/}>			\\
  \>\>|\>	<{\it facteur\/}>					\\[10pt]
 <{\it facteur\/}>
  \>::=\>\>	\verb|(| <\expreg> \verb|)|	 \\
  \>\>|\>	\verb|{| <\expreg> \verb|}|	 \\
  \>\>|\>	\verb|{| <\expreg> \verb|}*|	 \\
  \>\>|\>	\verb|(| <\expreg> \verb|)*|	 \\
  \>\>|\>	\verb|(| <\expreg> \verb|)+|	 \\
  \>\>|\>	\verb|{| <\expreg> \verb|}+|	 \\
  \>\>|\>	\verb|[| <\expreg> \verb|]|	 \\
  \>\>|\>	<{\it primaire\/}>
\end{tabbing}
\end{quote}

Et {\tt <{\it primaire\/}>} est un e'le'ment du vocabulaire.

Les parenthe`ses ``\verb|(|'' et ``\verb|)|'' ont la signification
usuelle.

Les couples ``\verb|{|''--``\verb|}|'', ``\verb|{|''--``\verb|}*|'' et
``\verb|(|''--``\verb|)*|'' sont utilise's pour symboliser
l'ope'rateur de fermeture transitive re'flexive.

Les couples ``\verb|(|''--``\verb|)+|'' et ``\verb|{|''--``\verb|}+|''
sont utilise's pour symboliser l'ope'rateur de fermeture transitive.

Le couple ``\verb|[|''--``\verb|]|'' indique que l'expression
re'gulie`re est facultative.

\begin{figure}[hbtp]
 \caption{Exemple d'expression re'gulie`re.} \vspace{1ex} Les
identificateurs du langage d'entre'e {\LECL} peuvent e^tre de'finis
par l'expression re'gulie`re\,:
\begin{quote}
\begin{verbatim}
                LETTER {["_"] (LETTER|DIGIT)}
\end{verbatim}
\end{quote}
\end{figure}

\subsubsection{L'ope'rateur ``{\tt -}''}
	\label{sec:operateur-moins}

Certains caracte`res reconnus au niveau lexical n'ont aucune utilite'
pour l'analyse syntaxique.  Par exemple, dans une chai^ne de
caracte`res, les guillemets de de'but et de fin peuvent e^tre
e'limine's, en ne conservant que les caracte`res utiles.

L'utilisateur a la possibilite' de spe'cifier si un groupe de
caracte`res doit e^tre ou non conserve' par l'analyseur lexical, en
faisant pre'ce'der le {\sl facteur\/} qui correspond a` ce groupe de
l'ope'rateur unaire ``\verb|-|''.  Cette suppression doit e^tre
cohe'rente, c'est-a`-dire que deux occurrences du me^me caracte`re
atteintes simultane'ment lors d'une analyse lexicale ne peuvent a` la
fois e^tre conserve'es et supprime'es.

\begin{figure}[hbtp]
 \caption[Utilisation de l'ope'rateur ``{\tt -}''.]
	{Exemples d'utilisation de l'ope'rateur ``{\tt -}''.}
	\label{fig:-.lecl}
 \vspace{1ex}
Les deux expressions re'gulie`res suivantes sont {\it a priori\/}
licites\,:
\begin{quote}
\begin{verbatim}
-QUOTE {tout_sauf_quote | -QUOTE QUOTE} -QUOTE

-({SP|EOL}+ | "-" "-" {tout_sauf_EOL} EOL)
\end{verbatim}
\end{quote}

En revanche, la description suivante est errone'e\,:
 \begin{quote} \tt
   -QUOTE$_1$ \{tout\_sauf\_quote | QUOTE$_2$ -QUOTE$_3$\} -QUOTE$_4$
 \end{quote}

En effet, lors de la reconnaissance d'une chai^ne, les
occurrences~{\scriptsize 2} et~{\scriptsize 4} de \verb|QUOTE| sont
atteintes en paralle`les.  S'agit-il du guillemet de fin ou d'un
guillemet inte'rieur\,?  Seule la connaissance du symbole suivant va
permettre d'en de'cider.  Il est donc errone' dans ce cas de
spe'cifier simultane'ment une suppression (occurrence~{\scriptsize 4})
et une me'morisation (occurrence~{\scriptsize 2}).
 \vspace{1ex}
\end{figure}

{\bf Attention}\,: L'ope'rateur binaire ``\verb|-|'' utilise' dans les
classes (diffe'rence ensembliste) ne peut pas e^tre utilise' dans les
expressions re'gulie`res.

\subsubsection{L'ope'rateur ``{\tt \ga}''}

C'est un ope'rateur unaire dont l'ope'rande est une classe et dont le
re'sultat est le comple'mentaire de la classe ope'rande par rapport a`
\verb|ANY|.

\begin{figure}[hbtp]
 \caption[Utilisation de l'ope'rateur ``{\tt \ga}''.]
	{Exemples d'utilisation de l'ope'rateur ``{\tt \ga}''.}
 \vspace{1ex}
L'expression re'gulie`re de'finissant une chai^ne peut s'e'crire\,:
\begin{verbatim}
        -QUOTE {^QUOTE | -QUOTE QUOTE} -QUOTE
\end{verbatim}

L'e'criture
\begin{verbatim}
        ^"<"&Is_First_Col
\end{verbatim}
(voir en~\ref{sec:predicats-lecl}) a la signification
``\verb|(^"<")&Is_First_Col|'', c'est-a`-dire `caracte`re quelconque
diffe'rent de ``\verb|<|'' qui se trouve en premie`re colonne{'}.
 \vspace{1ex}
\end{figure}

\subsubsection{Les actions}
	\label{sec:actions-lecl}

Afin de permettre a` l'utilisateur d'exe'cuter, au cours de l'analyse
lexicale, des traitements qui se spe'cifient mal---ou ne peuvent pas
se spe'cifier---par le formalisme des expressions re'gulie`res, il a
e'te' introduit des {\sl actions\/} dans la description lexicale.  Ces
actions peuvent e^tre conside're'es comme le pendant des ``actions
se'mantiques'' du niveau syntaxique.

Tout nom d'action commence par le caracte`re ``\verb|@|''.  Certaines
actions d'inte're^t ge'ne'ral sont pre'de'finies par le syste`me
{\LECL}.  Ces actions pourraient pour la plupart e^tre e'crites tre`s
simplement par l'utilisateur\,; leur existence se justifie toutefois,
non seulement par des conside'rations d'efficacite', mais encore par
l'ame'lioration qu'elles peuvent apporter a` la clarte' de la
spe'cification\,: elles portent en effet un nom significatif de leur
fonction, alors que les actions de l'utilisateur ne peuvent e^tre
re'fe'rence'es que par un nume'ro.

Lors de l'exe'cution d'une action, que ce soit une action pre'de'finie
ou une action de l'utilisateur, le caracte`re suivant dans le texte
source a toujours e'te' lu, mais n'a pas encore e'te' (pleinement)
exploite'\,; il est donc accessible, si besoin est, par l'interme'diaire
du module de gestion du texte source, dans la structure
``\verb|sxsrcmngr|'' (voir la documentation en ligne---{\tt
man~sxsrcmngr}).

\paragraph{Actions pre'de'finies.}

Les actions pre'de'finies par le syste`me sont les suivantes\,:

\begin{description}

 \item[{\tt @LOWER\_CASE}]: Passe en minuscule tous les caracte`res
qui ont e'te' conserve's depuis le de'but de la reconnaissance de
l'unite' lexicale courante.

 \item[{\tt @UPPER\_CASE}]: Passe en majuscule tous les caracte`res
qui ont e'te' conserve's depuis le de'but de la reconnaissance de
l'unite' lexicale courante.

 \item[{\tt @LOWER\_TO\_UPPER}]: Passe en majuscule le dernier
caracte`re conserve'.

 \item[{\tt @UPPER\_TO\_LOWER}]: Passe en minuscule le dernier
caracte`re conserve'.

 \item[{\tt @PUT (}{\it char\/}{\tt )}]: Inse`re le caracte`re {\it
char\/} dans la chai^ne conserve'e.

 \item[{\tt @MARK}]: Me'morise la position courante dans la chai^ne
conserve'e---voir les actions \verb|@ERASE| et \verb|@RELEASE|.

 \item[{\tt @ERASE}]: Supprime tous les caracte`res qui ont pu e^tre
conserve's depuis le \verb|@MARK| pre'ce'dent (dans la me^me unite'
lexicale) s'il existe ou sinon depuis le de'but de la reconnaissance
de l'unite' lexicale courante.

 \item[{\tt @RELEASE}]: {\sl Repousse} dans le source les caracte`res
me'morise's depuis le \verb|@MARK| pre'ce'dent (dans la me^me unite'
lexicale) s'il existe ou sinon depuis le de'but de l'unite' lexicale
courante.
\end{description}

Les actions suivantes permettent la gestion de compteurs (nume'rote's
a` partir de 0).  Ces compteurs peuvent e^tre teste's par
l'interme'diaire des pre'dicats pre'de'finis \verb|&Is_Set| et
\verb|&Is_Reset|---voir plus loin.  Ils sont e'galement manipulables
par des actions {\it vel\/} des pre'dicats de l'utilisateur (voir la
documentation en ligne---{\tt man~sxscanner}).  Ces compteurs sont
initialise's a` ze'ro au de'but de l'analyse de tout texte source.

\begin{description}

 \item[{\tt @RESET (}$n${\tt )}]: Mise a` ze'ro du compteur
nume'ro~$n$.

 \item[{\tt @SET (}$n${\tt )}]: Mise a` un du compteur nume'ro~$n$.

 \item[{\tt @INCR (}$n${\tt )}]: Le compteur nume'ro~$n$ est
incre'mente' de~1.

 \item[{\tt @DECR (}$n${\tt )}]: Le compteur nume'ro~$n$ est
de'cre'mente' de~1.
\end{description}

\paragraph{Actions de l'utilisateur.}

Les actions utilisateur sont de'finies par l'apparition de leur nom
dans une expression re'gulie`re (caracte`re ``\verb|@|'' suivi d'un
nombre entier positif ou nul).	A chacune de ces actions doit
correspondre une portion de programme, e'crite par l'utilisateur,
re'alisant la fonction de'sire'e.  Ces actions sont exe'cute'es au
cours de l'analyse lexicale d'un texte source.

{\bf Exemple}\,: En Ada, la casse, majuscule ou minuscule, des lettres
composant un identificateur est indiffe'rente.	Le me^me nom peut donc
s'e'crire tanto^t en majuscules, tanto^t en minuscules ou en
me'langeant les deux types de capitalisation.  Il est possible de
me'moriser les identificateurs sous une forme normale, ne comportant
par exemple que des lettres majuscules\,; la transformation d'un
identificateur quelconque vers cette forme normale (passage des
minuscules en majuscules) peut e^tre programme'e en utilisant une
action syste`me.  Cette action peut soit passer une seule lettre de
minuscule en majuscule (action \verb|@LOWER_TO_UPPER|) soit
transformer l'ensemble de l'identificateur (action \verb|@UPPER|).
Suivant le cas on obtient la description
\begin{verbatim}
 LETTER @LOWER_TO_UPPER {["_"] (LETTER @LOWER_TO_UPPER | DIGIT)}
\end{verbatim}
si la transformation se fait lettre apre`s lettre, ou
\begin{verbatim}
 LETTER {["_"] (LETTER | DIGIT} @UPPER_CASE
\end{verbatim}
si la transformation s'effectue globalement.

{\bf Un autre exemple}\,: Certains langages de programmation spe'cifient
que seuls un certain nombre de caracte`res sont significatifs dans les
identificateurs, ou me^me limitent leur taille.  La troncature ou la
ve'rification ne'cessaires peuvent aise'ment se re'aliser a` l'aide du
me'canisme des actions.

Une des originalite's de {\LECL} est d'utiliser les contextes droits
(sur une longueur e'ventuellement non borne'e) pour de'cider de
l'action a` exe'cuter, de la me^me fac,on que le contexte droit sert
a` la reconnaissance d'une expression re'gulie`re (voir
en~\ref{sec:contextes}).

{\bf Exemple}\,: La de'finition des deux unite's lexicales
\begin{verbatim}
        UL1     = "a" @1 {"b"} "c" ;
        UL2     = "a" @2 {"b"} "d" ;
\end{verbatim}
est licite.  C'est la vue des caracte`res ``\verb|c|'' ou ``\verb|d|''
apre`s un nombre non borne' de ``\verb|b|'' qui de'cidera de
l'exe'cution de l'action ``\verb|@1|'' ou ``\verb|@2|''.

{\bf Remarque}\,: Bien entendu, certaines des variables utilise'es par
l'analyseur lexical sont accessibles (et me^me modifiables\ldots) par
l'utilisateur, en particulier depuis le programme codant ses actions
et pre'dicats (voir en~\ref{sec:lecl(1)} et consulter la documentation
en ligne---{\tt man~sxscanner}).

\subparagraph*{Post-action.}

Il est e'galement possible de spe'cifier une action utilisateur.
Cette action, si elle existe, doit suivre
\begin{itemize}

 \item le ``\verb|;|'' marquant la fin de l'expression re'gulie`re a`
laquelle elle s'applique,

 \item ou le ``\verb|;|'' marquant la fin de la clause
\verb"Priority" (voir en~\ref{sec:priorites}), si elle est pre'sente,

 \item ou le ``\verb|;|'' marquant la fin de la clause \verb''NOT''
\verb''KEYWORD'',

 \item ou le ``\verb|;|'' marquant la fin de la clause contexte.
\end{itemize}

Une telle action est appele'e {\sl post-action\/}\,: lors de l'analyse
lexicale, apre`s reconnaissance de l'expression re'gulie`re a`
laquelle elle est attache'e, cette action sera exe'cute'e
imme'diatement avant le retour a` l'analyseur syntaxique.
L'utilisateur a donc la possibilite' d'y modifier les informations
calcule'es par l'analyseur lexical (code interne du terminal reconnu,
informations stocke'es dans la ``string-table'', {\it et cetera\/}).

\subsubsection{Les pre'dicats \label{sec:predicats-lecl}}

Jusqu'a` pre'sent, nous avons suppose' que la signification d'un
caracte`re donne' ne de'pendait que de ce caracte`re.  Il existe
cependant un certain nombre de situations ou` cette signification
de'pend e'galement de l'environnement\,: positionnement du caracte`re a`
un nume'ro de colonne donne', occurrence dans une portion de texte
donne'e, {\it et cetera\/}.

En ge'ne'ral, ce genre de situation ne peut que difficilement se
de'crire de fac,on purement syntaxique.	 Afin de re'soudre ce
proble`me, {\LECL} permet d'influer sur l'analyse lexicale, par
l'interme'diaire de {\sl pre'dicats}.

Il est possible, dans une expression re'gulie`re quelconque,
d'associer a` une occurrence d'une classe de caracte`res quelconque un
pre'dicat syste`me ou utilisateur.  Un nom de pre'dicat commence par
le caracte`re ``\verb|&|''.  Lors de l'analyse d'un texte source, un
caracte`re {\em t\/} ne peut e^tre reconnu par le couple {\em
classe--pre'dicat\/} que si {\em t\/} appartient a` {\em classe\/} et
si {\em pre'dicat\/} est {\tt vrai}.

Dans une expression re'gulie`re, toute occurrence d'un nom de classe
n'ayant pas de pre'dicat associe' peut e^tre conside're'e comme e'tant
associe'e a` un pre'dicat toujours {\tt vrai}.

A` chaque pre'dicat---autre qu'un pre'dicat {\sl statique}, voir
ci-dessous---doit correspondre une fonction a` valeur boole'enne
(de'finie par le syste`me pour ce qui concerne les pre'dicats
pre'de'finis, ou e'crite par l'utilisateur)\,; ces fonctions sont
exe'cute'es au cours de l'analyse lexicale d'un texte source.

\paragraph{Les pre'dicats syste`me}

\begin{description}

 \item[Statiques]: Ces pre'dicats, contrairement aux autres, sont
e'value's a` la construction et permettent de simplifier l'e'criture
des expressions re'gulie`res\,; il s'agit des pre'dicats \verb|&TRUE| et
\verb|&FALSE|.

Le pre'dicat \verb|&TRUE| a la signification suivante\,:
\begin{quotation}
si, au cours de la construction de l'automate, {\LECL} se trouve en
plusieurs endroits diffe'rents dans le graphe des e'tats
(non-de'terminisme) et qu'un de ces endroits au moins est une classe
associe'e au pre'dicat \verb|&TRUE|, alors le constructeur ne conserve
que les endroits ainsi repe're's, les autres e'tant conside're's comme
des impasses.
\end{quotation}

{\bf Exemples}\,:
\begin{itemize}
 \item Les expressions re'gulie`res de la figure~\ref{fig:-.lecl},
reconnaissant les chai^nes de caracte`res et les commentaires, peuvent
s'e'crire\,:
\begin{verbatim}
        -QUOTE {ANY |-QUOTE&TRUE QUOTE} -QUOTE&TRUE

        -({SP|EOL}+ | "-" "-" {ANY} EOL&TRUE )
\end{verbatim}

La classe compose'e \verb|ANY| contient le caracte`re guillemet
(\verb|QUOTE| appartient a` \verb|ANY|)\,; lorsqu'un guillemet est
reconnu, l'on se trouve en trois endroits diffe'rents dans
l'expression re'gulie`re\,:

\begin{tabbing}
\ \ \ \ \ \ \ \ \verb|-QUOTE {|\=\verb"ANY |
 -"\=\verb|QUOTE&TRUE QUOTE} -|\=\verb|QUOTE&TRUE| \\
\>$\uparrow$\>$\uparrow$\>$\uparrow$
\end{tabbing}

Selon la re`gle pre'ce'dente, seuls les deux derniers emplacements
sont conserve's.  Le guillemet est donc reconnu par \verb|QUOTE| et
non par \verb|ANY|.

 \item Sans utiliser de pre'dicat \verb|&TRUE|, les commentaires PL/1
peuvent e^tre reconnus par l'expression re'gulie`re
\begin{verbatim}
"/" "*" {^"*" | {"*"}+ ^"*/"} {"*"}+ "/"
\end{verbatim}

En utilisant le pre'dicat \verb|&TRUE|, on obtient l'expression
ci-dessous, notablement plus simple et plus lisible\,!
\begin{verbatim}
 "/" "*" {ANY} "*" "/"&TRUE
\end{verbatim}
\end{itemize}

 \item[Dynamiques]:
  \begin{description}
   \item[{\tt \&IS\_FIRST\_COL}]: Vrai si et seulement si les
caracte`res de la classe courante sont en premie`re colonne.
   \item[{\tt \&IS\_LAST\_COL}]: Vrai si et seulement si les caracte`res
de la classe courante sont sur la dernie`re colonne d'une ligne.
   \item[{\tt \&IS\_RESET (}$n${\tt )}]: Vrai si et seulement si le
compteur nume'ro $n$ est nul.
   \item[{\tt \&IS\_SET (}$n${\tt )}]: Vrai si et seulement si le
compteur nume'ro $n$ est non nul.
  \end{description}
\end{description}

\paragraph{Les pre'dicats utilisateur.}

Ils de'signent, soit une fonction boole'enne de l'utilisateur
(caracte`re ``\verb|&|'' suivi d'un nombre entier positif ou nul),
soit un {\sl nom d'expression boole'enne\/} (caracte`re ``\verb|&|''
suivi d'un identificateur).  Dans ce deuxie`me cas, l'{\sl expression
boole'enne\/} a du^ e^tre de'finie au pre'alable dans le paragraphe
``\verb|ABBREVIATIONS|'' de la fac,on suivante\,:
\begin{quote} \tt
\quad <{\it nom de l'expression\/}>\ \ ::= <{\it expression bool\/}>
\end{quote}
ou`
\begin{itemize}
 \item les ope'rateurs de {\it {\tt<}expression bool\/{\tt>}} sont\,:
 \begin{itemize}
  \item la concate'nation par juxtaposition (ope'ration {\em et\/}),
  \item l'ope'rateur ``\verb"|"'' (ope'ration {\em ou\/}),
  \item l'ope'rateur ``\verb|^|'' (ope'ration de comple'mentation),
 \end{itemize}
avec les pre'ce'dences usuelles\,;
 \item les ope'randes sont des pre'dicats\,; chaque pre'dicat peut e^tre
soit un pre'dicat syste`me {\em dynamique}, soit un pre'dicat
utilisateur, soit un nom d'expression de pre'dicats de'fini
pre'alablement.
\end{itemize}

\paragraph{Exemples}

\begin{enumerate}
 \item La figure~\ref{fig:predicats-1} spe'cifie qu'un commentaire
commence par le caracte`re ``\verb|*|'' ve'rifiant la condition\,: e^tre
en premie`re colonne et variable nume'ro 2 nulle, ou ne pas e^tre en
premie`re colonne et variable nume'ro 2 non nulle.

\begin{figure}[hbtp]
 \caption[De'finition d'expression de pre'dicats.]
	{Exemple de de'finition d'expression de pre'dicats.}
	\label{fig:predicats-1}
\begin{verbatim}
Abbreviations
   &COND = &Is_First_Col &Is_Reset(2) |
           ^&Is_First_Col &Is_Set(2);
Tokens
   Comments = "*"&COND {^EOL} EOL;
\end{verbatim}
\end{figure}

 \item Dans les langages {\sl formatte's}, la signification d'une
unite' lexicale peut de'pendre de l'emplacement de son occurrence dans
une ligne.  Prenons comme exemple de spe'cification celle de {\BNF},
dans laquelle on impose que les non-terminaux de la partie gauche
d'une re`gle commencent en colonne 1.	 Ces symboles
(\verb|%LHS_NON_TERMINAL|) et les non-terminaux de la partie droite
(\verb|%NON_TERMINAL|) peuvent se de'crire comme en
figure~\ref{fig:predicats-2}, ou` le pre'dicat \verb|&IS_FIRST_COL|
re'pond \verb|vrai| si et seulement si le caracte`re auquel il est
associe' (ici ``\verb|<|'') se trouve en colonne~1\,; dans le cas
contraire, on conside`re que le ``\verb|<|'' est le de'butant de
\verb|%NON_TERMINAL|.

\begin{figure}[hbtp]
 \caption{Extrait de la spe'cification lexicale de {\BNF}.}
	\label{fig:predicats-2}
\begin{verbatim}
 %LHS_NON_TERMINAL = "<"&IS_FIRST_COL {^EOL} ">"&TRUE ;
 %NON_TERMINAL     = "<" {^EOL} ">"&TRUE ;
\end{verbatim}
\end{figure}

 \item Le me'canisme des actions et des pre'dicats augmente la
puissance the'orique de description des expressions re'gulie`res\,; il
est possible de de'crire des langages non re'guliers, par exemple des
commentaires imbrique's.

Supposons que les caracte`res ``\verb|{|'' et ``\verb|}|'' marquent
respectivement le de'but et la fin d'un commentaire et qu'il soit
possible de trouver un commentaire a` l'inte'rieur d'un autre
commentaire---ce type de commentaire ne se rencontre a` l'heure
actuelle que tre`s rarement dans les langages, malheureusement.	 Une
description possible est donne'e en figure~\ref{fig:olga-comments}.

\begin{figure}[hbtp] \centering
 \caption{Exemple de spe'cification des commentaires de {\sl OLGA}.}
	\label{fig:olga-comments}
\begin{verbatim}
Comments = "{" @Reset (0)
               {
                ^"{}"                    |
                "{" @Incr (0)            |
                "}"&Is_Set (0) @Decr (0)
               }
           "}" ;
\end{verbatim}
\end{figure}

\end{enumerate}

{\bf Remarque}\,: Plus ge'ne'ralement, il est possible d'utiliser
{\LECL} pour de'crire des langages non re'guliers en simulant
l'automate a` pile correspondant par des appels re'cursifs de
l'analyseur lexical, dans un style qui s'apparente a` la descente
re'cursive dans les analyseurs syntaxiques de la classe~LL.  A` chaque
notion du langage (non-terminal) on fait correspondre une description
(langage) et chaque fois qu'a` un niveau donne' on reconnait, gra^ce
a` un pre'fixe, la pre'sence d'une notion, l'analyseur lexical de
cette notion est appele' par l'interme'diaire d'une action
utilisateur.  Lorsque cette notion a e'te' traite'e, une autre action
utilisateur permet le retour au niveau appelant.

Par exemple, la spe'cification lexicale pre'ce'dente des commentaires
OLGA, peut e'galement se de'crire comme en
annexe~\ref{annexe:olga-comments-2}.


\subsubsection{Les {\em includes}}
	\label{sec:includes}

L'utilisateur a la possibilite' de de'finir des {\sl commandes
d'inclusion}, introduites par le mot cle' \verb|INCLUDE| dans la
rubrique \verb|TOKENS|.	 Cette de'finition doit comporter une
expression re'gulie`re qui reconnai^t la commande et deux actions
utilisateur (dont une {\em post-action\/}).  La premie`re action doit
assurer le changement de fichier source (en fonction des informations
extraites de la commande) alors que la post-action doit assurer le
retour normal a` la lecture du fichier courant.	 Le module de
librairie \verb|sxincl_mngr| ({\sl include manager\/}) peut e^tre
utilise' (voir la documentation en ligne---\verb|man sxincl_mngr|).

{\bf Exemple}\,: Soit un langage ou` la commande \verb|include| est
introduite par le caracte`re ``\verb|#|'' et se termine sur la
premie`re fin de ligne.	 Les caracte`res non blancs sont cense's
repre'senter le {\sl chemin} ({\it pathname\/}) du fichier a`
conside'rer.  La description lexicale correspondante peut donc e^tre\,:
\begin{center}
\verb/Include = -"#" -{SP | HT} {^" \t\n"}+ -{SP | HT} -EOL @1 ; @2 ;/
\end{center}

On trouvera en annexe~\ref{annexe:include-actions} le texte du programme
codant les actions \verb|@1| et \verb|@2|.


\subsection{Les conflits}
	\label{sec:conflits}

Les langages de'crits par les expressions re'gulie`res de la rubrique
\verb|TOKENS| doivent e^tre disjoints deux a` deux, c'est-a`-dire que
lors d'une analyse lexicale, toute se'quence de caracte`res ne doit
pouvoir e^tre reconnue que par une seule expression re'gulie`re.
Sinon on a un conflit potentiel qui est dit {\sl Reduce/Reduce}.

De me^me une chai^ne reconnue par une expression re'gulie`re donne'e
ne peut e^tre le pre'fixe d'un autre chai^ne, sinon on a un conflit
potentiel qui est dit {\sl Shift/Reduce}.\footnote{Les conflits {\sl
Shift/Action\/} n'existent pas---ce ne sont que des mirages\,!}

Afin de re'soudre de tels conflits, {\LECL} met a` la disposition de
l'utilisateur deux me'canismes\,: les contextes qui font l'objet
de~\ref{sec:contextes} et les priorite's qui sont traite'es
en~\ref{sec:priorites}.

\subsubsection{Les contextes}
	\label{sec:contextes}

La grammaire du niveau syntaxique de'finit les se'quences valides
d'unite's lexicales mais ne pre'cise pas la fac,on dont elles vont
e^tre se'pare'es les unes des autres.

Conside'rons par exemple un langage ou` un nombre peut suivre un
identificateur\,; la chai^ne ``\verb"A1"'' peut e^tre conside're'e soit
comme un seul identificateur de texte~\verb"A1", soit comme la
se'quence identificateur~\verb"A"--nombre~\verb"1".

Les se'quences valides d'unite's lexicales (de'duites de la grammaire
syntaxique) permettent e'galement, dans certains cas, de lever des
ambigu"ite's.  Soit un langage ou` ``\verb"*"'' et ``\verb"**"'' sont
des ope'rateurs valides.  La vue d'une e'toile ne suffit pas pour
de'cider si l'on a reconnu l'ope'rateur~\verb"*" ou si l'on est dans
l'ope'rateur~\verb"**".

En revanche, si l'on suppose que l'ope'rateur~\verb"*" ne peut pas
e^tre suivi d'une unite' lexicale commenc,ant par une e'toile, la
connaissance d'un caracte`re en avance ({\it look-ahead\/} d'un
caracte`re) permet de re'soudre ce conflit\,: si ce caracte`re en avance
est une e'toile, on est dans la reconnaissance de~\verb"**", sinon on
vient de reconnai^tre~\verb"*".

Les {\sl clauses contextes\/} permettent de pre'ciser les {\sl
suivants imme'diats\/} possibles des unite's lexicales et des
commentaires.

On appelle {\sl suivants imme'diats\/} l'ensemble des unite's
lexicales pouvant suivre une unite' lexicale donne'e, conforme'ment a`
la grammaire du niveau syntaxique et aux clauses contextes.

Attention\,: cette notion est de'finie en terme d'unite's lexicales et
non en terme de terminaux du niveau syntaxique.

{\bf Exemple}\,: Supposons que le mot cle' \verb|THEN| puisse, d'apre`s
la grammaire, suivre un nombre entier (terminal ge'ne'rique
\verb|%integer|) et que ce mot cle' soit reconnu par l'unite' lexicale
\verb|%identifier|\,; alors \verb|%identifier| est un e'le'ment des
suivants imme'diats de \verb|%integer|.

En l'absence de clause contexte, les suivants imme'diats sont\,:
\begin{itemize}

 \item pour un commentaire\,: toutes les unite's lexicales ainsi que les
commentaires\,;

 \item pour une unite' lexicale\,: les commentaires plus les unite's
lexicales reconnaissant les terminaux qui peuvent suivre, d'apre`s la
grammaire, n'importe quel terminal reconnu par cette unite' lexicale.
\end{itemize}

La clause contexte, si elle existe, doit suivre
\begin{itemize}

 \item le ``\verb|;|'' marquant la fin de l'expression re'gulie`re a`
laquelle elle s'applique,

 \item ou le ``\verb|;|'' marquant la fin de la clause
\verb"Priority" (voir en~\ref{sec:priorites}), si elle est pre'sente,

 \item ou le ``\verb|;|'' marquant la fin de la spe'cification d'une
``post-action'' (voir en~\ref{sec:actions-lecl}),

 \item ou le ``\verb|;|'' marquant la fin de la clause \verb''NOT''
\verb''KEYWORD'',

 \item ou le ``\verb|;|'' marquant la fin d'une autre clause contexte.
\end{itemize}

Cette clause contexte se termine par un point-virgule et peut
s'e'crire de trois manie`res diffe'rentes\,:
\begin{enumerate}
 \item {[\verb|Unbounded|]}\verb| Context |{\it liste\_de\_suivants\/}\,;

 \item {[\verb|Unbounded|]}\verb| Context All|\,;

 \item {[\verb|Unbounded|]}\verb| Context All But |{\it liste\_de\_suivants\/}\,;
\end{enumerate}

Dans le premier cas, on indique explicitement la liste des suivants
valides.  Dans le deuxie`me cas, on indique que les suivants valides
sont ceux de'duits de la grammaire syntaxique, sans modification.  Le
troisie`me cas est analogue au pre'ce'dent, excepte' que {\it
liste\_de\_suivants\/} est supprime'e des suivants valides.

Les suivants (se'pare's par des virgules) peuvent e^tre\,:
\begin{itemize}
 \item un nom d'unite' lexicale (identificateur ou chai^ne de
caracte`res)\,;

 \item un nom d'un composant d'union (voir ci-dessous).
\end{itemize}

Ces contextes peuvent e^tre utilise's de deux fac,ons pour re'soudre
des conflits\,:
\begin{enumerate}
 \item si le mot cle' \verb"Unbounded" est absent, on est en mode {\it
1\_look\_ahead}\,; {\LECL} essaie alors de re'soudre les conflits a`
la vue d'un seul caracte`re en avance\,;

 \item si le mot cle' \verb"Unbounded" est pre'sent, {\LECL} peut
utiliser un nombre non borne' de caracte`res en avance.	 Une
re'solution \verb"Unbounded" sur une unite' lexicale, dont le contexte
est directement donne' par la grammaire du niveau syntaxique et non
modifie' par une clause \verb"Context" explicite, doit e^tre
introduite par \verb"Unbounded Context All;".
\end{enumerate}

\subsubsection{Les unions}

Afin d'augmenter la pre'cision de la description des se'quences
valides d'unite's lexicales, il est possible de de'finir une unite'
lexicale comme e'tant de'crite par plusieurs expressions re'gulie`res.
Cette possibilite', appele'e {\sl union\/}, est introduite par le mot cle'
\verb"UNION" et se termine par le mot cle' \verb"END"---voir l'exemple
de la figure~\ref{fig:union}.  On re'fe'rence les membres d'une union par
une notation pointe'e\,:
\begin{quote}
{\it nom-de-l'unite'}\verb|.|{\it nom-du-composant}.
\end{quote}

Il peut y avoir des clauses mot cle' (voir en~\ref{sec:mot-cle}), post-action
(voir en~\ref{sec:actions-lecl}), contexte (voir en~\ref{sec:contextes}) et
priorite' (voir en~\ref{sec:priorites})
associe'es a` chaque composant de l'union.  Par de'faut chaque
composant he'rite les clauses (s'il y en~a) de l'unite' lexicale, qui
sont spe'cifie'es apre`s le \verb"End ;" marquant la fin de l'union.
Pour une clause donne'e, cet he'ritage est inhibe' si pour un composant
d'une union cette clause a e'te' rede'finie au niveau de ce composant.

\begin{figure}[hbtp]
 \caption[Utilisation de l'union.]
	{Exemple d'utilisation de l'union.}
	\label{fig:union}
 \vspace{1ex}
Conside'rons la de'finition suivante---extraite de la spe'cification
du langage~Ada\,:

\begin{verbatim}
    Comments =  Union
                   blanks : {SP|HT|EOL}+ ;
                   ada    : "-" "-" {^EOL} EOL ;
                End ;
\end{verbatim}

Cette de'finition, e'quivalente en ce qui concerne la reconnaissance
des commentaires a`
\begin{quote}
\begin{verbatim}
    Comments = {SP|HT|EOL}+ | "-" "-" {^EOL} EOL ;
\end{verbatim}
\end{quote}
permet par exemple d'interdire a` la deuxie`me forme des commentaires
de suivre l'ope'rateur {\it moins}, en le de'finissant par
\begin{quote}
\begin{verbatim}
    "-" = "-" ; Context All But Comments.ada;
\end{verbatim}
\end{quote}
ce qui signifie que la pre'sence des caracte`res ``\verb"---"'' en
de'but d'une unite' lexicale n'a pas la signification {\sl ope'rateur
moins suivi d'un de'but de commentaire}.
 \vspace{1ex}
\end{figure}

\subsubsection{Les priorite's}
	\label{sec:priorites}

Cette clause, introduite par le mot cle' \verb"PRIORITY", doit suivre,
si elle est pre'sente
\begin{itemize}
 \item le ``\verb|;|'' marquant la fin d'une expression re'gulie`re

 \item ou le ``\verb|;|'' marquant la fin d'une spe'cification de
``post-action''

 \item ou le ``\verb|;|'' marquant la fin d'une clause contexte,

 \item ou le ``\verb|;|'' marquant la fin d'une clause ``NOT KEYWORD'',

 \item ou le ``\verb|;|'' marquant la fin d'une autre clause \verb"PRIORITY".
\end{itemize}
Elle est forme'e d'une liste d'au plus trois spe'cifications de
priorite' se'pare'es par des ``\verb","''\,; cette clause se termine par
un ``\verb";"''.

Les possibilite's de spe'cification de priorite' sont les suivantes\,:
\begin{description}
 \item[{\tt Reduce>Reduce}]: En cas de conflit ({\it 1\_look\_ahead\/}
ou {\it Unbounded\/}), la priorite' est donne'e a` l'expression
courante sur toute autre expression ne comportant pas cette clause et
reconnaissant un (sous-)langage commun.

 \item[{\tt Reduce>Shift}]: En cas de conflit ({\it 1\_look\_ahead\/}
ou {\it Unbounded\/}), les chai^nes reconnues par l'expression
re'gulie`re courante ({\sl Reduce\/}) ont priorite' sur les pre'fixes
stricts ({\sl Shift}) de chai^nes reconnues soit par cette expression
re'gulie`re soit par d'autres.

 \item[{\tt Shift>Reduce}]: En cas de conflit ({\it 1\_look\_ahead\/}
ou {\it Unbounded\/}), toute chai^ne reconnue par une expression ({\sl
Reduce\/}) comportant cette clause est abandonne'e au profit des
pre'fixes stricts ({\sl Shift\/}) de'ja` reconnus, s'il y en a.
\end{description}

Les clauses priorite' sont applique'es successivement dans l'ordre
indique'.

\begin{figure}[hbtp]
 \caption[Utilisation de clause {\tt Priority}.]
	{Exemples d'utilisation de clause {\tt Priority}.}
 \vspace{1ex}
On de'finit les deux terminaux ge'ne'riques suivants\,:
\begin{quote}
\begin{verbatim}
%IDENT   = LETTER {["_"] (LETTER|DIGIT)} ;
%CAR_CDR = "C" {"A" | "D"}+ "R";
           Priority Reduce>Reduce;
\end{verbatim}
\end{quote}
et l'on suppose que leurs contextes sont identiques.

La chai^ne ``\verb"CADDR"'' est reconnue par les deux expressions
re'gulie`res, mais a` cause de la clause de priorite' sera
conside're'e comme e'tant un \verb|%CAR_CDR|.

Notons que la chai^ne ``\verb"CADDR1"'' sera conside're'e comme e'tant
un \verb|%IDENT|.  En revanche, avec la description suivante\,:
\begin{quote}
\begin{verbatim}
%IDENT   = LETTER {["_"] (LETTER|DIGIT)};
%NOMBRE  = {DIGIT}+;
%CAR_CDR = "C" {"A" | "D"}+ "R";
           Priority Reduce>Reduce, Reduce>Shift;
\end{verbatim}
\end{quote}
cette me^me chai^ne source ``\verb"CADDR1"'' sera conside're'e comme
e'tant une suite \verb|%CAR_CDR|\,--\,\verb|%NOMBRE| (``\verb"CADDR"'' et
``\verb"1"'').
 \vspace{1ex}
\end{figure}

\subsubsection{Principes de la re'solution des conflits}

En cas de conflit, {\LECL} applique les re`gles suivantes\,:
\begin{itemize}
 \item La pre'sence d'actions dans une expression re'gulie`re ne doit
pas {\it a priori\/} modifier le re'sultat de l'analyse.

 \item Les de'cisions se prennent sur les re'ductions.

 \item On de'termine tout d'abord le mode de re'solution du conflit\,:
{\it 1\_look\_ahead\/} ou {\it Unbounded\/}\,: une re'solution est {\it
Unbounded\/} si et seulement si toutes les unite's lexicales
intervenant dans le conflit ont une clause \verb"Unbounded Context"\,;
dans le cas contraire, le mode est {\it 1\_look\_ahead}.

 \item S'il y a conflit pour le mode trouve', {\LECL} applique les
priorite's utilisateur (s'il y en a).

 \item S'il reste des conflits, {\LECL} applique alors les re`gles de
re'solution par de'faut\,: il donne priorite' a` l'action ({\sl
Shift}, {\sl Action}, {\sl Reduce\/}) qui assure la reconnaissance de
la chai^ne la plus longue a` l'inte'rieur d'une me^me expression
re'gulie`re.  En cas d'e'galite', il donne priorite' a` l'action
rencontre'e en premier dans un parcours gauche droit de la grammaire
lexicale et produit un diagnostic.
\end{itemize}

\paragraph{Exemple}

Conside'rons le langage forme' par une liste d'identificateurs
(``\verb|%ID|'') et de nombres entiers (``\verb|%NB|''), et qui a la
de'finition lexicale suivante\,:
\begin{quote}
\begin{verbatim}
Tokens
        Comments = -{SP|EOL}+ ;
        %ID      = LETTER {LETTER | DIGIT} ;
        %NB      = {DIGIT}+ ;
\end{verbatim}
\end{quote}
{\LECL} produit sur cette spe'cification les diagnostics de la
figure~\ref{fig:diagnostics-conflits}.  Comme il n'y a pas de clause
\verb"Unbounded Context", tous ces conflits sont traite's en mode {\it
1\_look\_ahead}.

\begin{figure}[hbtp]
 \caption[Diagnostics de {\LECL} sur des conflits.]
	{Exemple de diagnostics de {\LECL} sur des conflits.}
	\label{fig:diagnostics-conflits}
 { \tt
 \begin{tabbing}
**** Warning : \= Shift\= detec\=			\kill
**** Warning :\>1\_look\_ahead Shift/Reduce conflict in state 3 on LETTER between	\\
\>		Shift : \\
\>\>		     \%ID = LETTER \{\ua LETTER | DIGIT\} ;	\\
\>		Reduce :	\\
\>\>		     \%ID = LETTER \{LETTER | DIGIT\}\ua  ;	\\
\>\>		     detected on :	\\
\>\>\>			  \%ID = \ua LETTER \{LETTER | DIGIT\} ;	\\
\>		Priority is given to Shift.	\\[5pt]

**** Warning :\>1\_look\_ahead Shift/Reduce conflict in state 3 on DIGIT between	\\
\>		Shift : \\
\>\>		     \%ID = LETTER \{LETTER | \ua DIGIT\} ;	\\
\>		Reduce :	\\
\>\>		     \%ID = LETTER \{LETTER | DIGIT\}\ua  ;	\\
\>\>		     detected on :	\\
\>\>\>			  \%NB = \{\ua DIGIT\}+ ;	\\
\>		Priority is given to Shift.	\\[5pt]

**** Warning :\>1\_look\_ahead Shift/Reduce conflict in state 4 on DIGIT between	\\
\>		Shift : \\
\>\>		     \%NB = \{\ua DIGIT\}+ ;	\\
\>		Reduce :	\\
\>\>		     \%NB = \{DIGIT\}+\ua  ;	\\
\>\>		     detected on :	\\
\>\>\>			  \%NB = \{\ua DIGIT\}+ ;	\\
\>		Priority is given to Shift.
 \end{tabbing}
 }
\end{figure}

Le premier diagnostic signifie que si deux identificateurs se
succe`dent sans se'parateur, il est impossible de les distinguer de
l'occurrence d'un seul.	 Le traitement par de'faut est dans ce cas de
conside'rer que l'on a un seul identificateur (priorite' est donne'e
a` la chai^ne la plus longue).

Le second et le troisie`me ont des significations analogues\,:
identificateur suivi d'un nombre et nombre suivi d'un nombre.

Si l'on veut e'viter ces messages, il est possible de spe'cifier, en
utilisant les clauses contexte, qu'un identificateur ou un nombre ne
peut pas suivre (imme'diatement) un identificateur et qu'un nombre ne
peut pas suivre un nombre\,:
\begin{quote}
\begin{verbatim}
%ID = LETTER {LETTER | DIGIT} ;
      Context All But %ID, %NB ;
%NB = {DIGIT}+ ;
      Context All But %NB ;
\end{verbatim}
\end{quote}

La re'solution de ces conflits peut e'galement e^tre obtenue (sans
diagnostic) en utilisant les clauses priorite'\,:
\begin{quote}
\begin{verbatim}
%ID = LETTER {LETTER | DIGIT} ;
      Priority Shift>Reduce ;
%NB = {DIGIT}+ ;
      Priority Shift>Reduce ;
\end{verbatim}
\end{quote}

\subsection{Exemples de de'finitions lexicales}
	\label{sec:lecl-exemples}

On trouvera en annexe les spe'cifications {\LECL} du langage {\PASCAL}
(annexe~\ref{annexe:pascal.lecl}) et des langages
{\BNF}~(\ref{annexe:bnf.lecl}) et {\LECL}
lui-me^me~(\ref{annexe:lecl.lecl}).

\section{Mise en oeuvre}
	\label{sec:lecl(1)}

Voir la documentation en ligne---{\tt man~lecl}.  De plus, si
l'utilisateur a inclu des actions {\it vel\/} des pre'dicats dans sa
de'finition lexicale, il doit e'crire un programme en langage~C,
codant ces actions et pre'dicats.  Ce codage ne'cessite en ge'ne'ral
d'acce'der a` un certain nombre de variables manipule'es par {\SYNTAX}
(se reporter a` la documentation en ligne, concernant notamment
\verb|sxunix(3)|, \verb|sxsrc_mngr(3)|, \verb|sxscanner(3)| et
\verb|sxstr_mngr(3)|).

On trouvera des exemples de codage d'actions et de pre'dicats en
annexes~\ref{annexe:lecl_sact.c} et~\ref{annexe:bnf_sact.c}.

\chapter{La se'mantique dans SYNTAX}
	\label{chap:semantique}

{\SYNTAX} permet deux types distincts de traitement se'mantique\,:
\begin{itemize}
 \item soit en effectuant des {\sl actions se'mantiques\/} pendant
l'analyse syntaxique\,: l'appel de l'action associe'e a` une re`gle de
la grammaire s'effectue apre`s la reconnaissance de la partie droite
de cette re`gle.

 \item soit en utilisant l'{\sl arbre abstrait\/} que peut construire
l'analyseur syntaxique et en appliquant sur cet arbre un programme
d'e'valuation d'{\sl attributs se'mantiques}.
\end{itemize}

Ces deux possibilite's sont obtenues respectivement par utilisation
des constructeurs {\SEMACT} et {\SEMAT}.

\section[SEMACT~: Actions se'mantiques]
	{\SEMACT~: Actions se'mantiques}

Pour introduire des actions se'mantiques dans la grammaire (contenue
alors ge'ne'ralement dans un fichier de nom {\it
nom-du-langage}\verb|.bnf|), l'utilisateur doit ajouter, en fin de
re`gle (apre`s le ``\verb";"''), un nombre entier.  Ce nombre indique
le nume'ro de l'action se'mantique qui sera appele'e par l'analyseur
syntaxique au moment de la reconnaissance de la re`gle associe'e.

Dans le cas ou` une re`gle n'est pas suivie d'un nume'ro d'action le
syste`me ajoute automatiquement le nombre~{\tt 0} a` la fin de cette
re`gle.  Ainsi l'action nume'ro~{\tt 0} sera appele'e lors de la
re'duction de telles re`gles.  (En ge'ne'ral, cette action ne fait
rien\ldots)

L'utilisateur doit alors e'crire un programme en langage~C (ou dans un
autre langage, apre`s re'alisation d'une interface) re'alisant
l'ensemble des actions se'mantiques du langage.	 Ce programme doit
correspondre a` la structure donne'e en annexe~\ref{annexe:_act.c}.


\section[SEMAT~: Se'mantique par arbre abstrait]
	{\SEMAT~: Se'mantique par arbre abstrait}
	\label{sec:semat}

\subsection{Spe'cification et construction de l'arbre abstrait}

La phase pre'liminaire de l'analyse se'mantique par arbre abstrait est
la production de cet arbre par le constructeur d'arbres abstraits
(voir la documentation en ligne---{\tt man~sxatc}), au cours de
l'analyse syntaxique.

Pour obtenir cette construction, il faut modifier la de'finition
syntaxique (il est d'usage de nommer alors {\it
nom-du-langage}\verb|.at| le fichier correspondant)\,; cette
modification consiste en l'ajout de noms de noeuds, a` la fin des
re`gles (apre`s le ``\verb";"'')\,; ces noms sont des identificateurs
``a` la~C'' place's entre guillemets~(``\verb|"|'').

Lorsque l'analyseur syntaxique reconnait une re`gle, les racines des
arbres correspondant aux non-terminaux et aux terminaux ge'ne'riques
de la partie droite deviennent les fils d'un nouveau noeud
repre'sentant le non-terminal de la partie gauche de la re`gle.	 Ce
nouveau noeud porte le nom qui se trouve en fin de re`gle.

A` un terminal ge'ne'rique correspond une feuille qui porte le me^me
nom que ce terminal.  Cependant, dans le cas ou` ce terminal
ge'ne'rique se trouve dans une re`gle ne comportant pas d'autres
terminaux ge'ne'riques et aucun non-terminal et que cette re`gle est
suivie par un nom de noeud, alors la feuille qui correspond au
terminal ge'ne'rique porte ce nom.

Les re`gles de construction qui viennent d'e^tre e'nonce'es ne sont
pas tout a` fait syste'matiques.  Il existe quelques exceptions
importantes\,:

\begin{enumerate}

 \item Lorsque l'analyseur syntaxique reconnait une re`gle ne
comportant que des terminaux non ge'ne'riques, ou une re`gle vide, il
cre'e une feuille dont le nom est le nom de noeud associe'---s'il est
spe'cifie', sinon \verb|VOID|.

 \item Si le nom d'un non-terminal re'cursif a` gauche se termine par
``\verb"_LIST"'' (par ``\verb"_RIGHT_LIST"'' s'il est re'cursif a`
droite), tous les e'le'ments de la liste sont re'unis sous un me^me
noeud.	Aucun nom de noeud ne doit suivre la (les) re`gle(s)
re'cursive(s) de'finissant ce non-terminal.  Si la (les) re`gle(s)
de'finissant ce non-terminal et de'butant (ou finissant) la re'cursion
est suivie d'un nom de noeud, le noeud {\sl liste\/} cre'e' portera ce
nom\,; sinon il porte le nom du non-terminal de la partie gauche.

Voir l'exemple de la figure~\ref{fig:liste-OBJ}.

\begin{figure}[hbtp]
 \caption[Cre'ation d'un arbre abstrait pour une liste.]
	{Exemple de cre'ation d'arbre abstrait pour une liste.}
	\label{fig:liste-OBJ}
 \vspace{1ex}
Conside'rons les re`gles\,:
\begin{quote}
\begin{verbatim}
        <OBJECT_LIST>   = <OBJECT_LIST> , <OBJECT> ;
        <OBJECT_LIST>   = <OBJECT>                 ; "OBJ_S"
        <OBJECT>        = .....                    ; "OBJ"
\end{verbatim}
\end{quote}

Si, dans un texte source, la liste d'objets contient trois objets,
l'arbre syntaxique classique serait celui de'crit en
figure~\ref{fig:arbre-syntaxique-OBJ}.  En revanche, l'arbre abstrait
engendre' par le constructeur d'arbre est celui de la
figure~\ref{fig:arbre-abstrait-OBJ}.
 \vspace{1ex}
\end{figure}

\begin{figure}[hbtp] \centering
 \caption{Exemple d'arbre syntaxique.}
	\label{fig:arbre-syntaxique-OBJ}
\begin{center}
\begin{verbatim}
                                        _________
                                        |       |
                                        | OBJ_S |
                                        |_______|
                                         |  |  |
                              ___________|  |  |_________
                              |             |           |
                        ______|__        ___|___    ____|____
                        |       |        |     |    |       |
                        | OBJ_S |        |  ,  |    |  OBJ  |
                        |_______|        |_____|    |_______|
                         |  |  |
          _______________|  |  |_________
          |                 |           |
     _____|___           ___|___    ____|____
     |       |           |     |    |       |
     | OBJ_S |           |  ,  |    |  OBJ  |
     |_______|           |_____|    |_______|
          |
     _____|___
     |       |
     |  OBJ  |
     |_______|
\end{verbatim}
\end{center}
\end{figure}

\begin{figure}[hbtp] \centering
 \caption{Exemple d'arbre abstrait.}
	\label{fig:arbre-abstrait-OBJ}
\begin{center}
\begin{verbatim}
                        _________
                        |       |
                        | OBJ_S |
                        |_______|
                         |  |  |
                         |  |  |
              ___________|  |  |___________
             |              |             |
        _____|_____    _____|_____   _____|_____
        |         |    |         |   |         |
        |   OBJ   |    |   OBJ   |   |   OBJ   |
        |_________|    |_________|   |_________|
\end{verbatim}
\end{center}
\end{figure}

 \item Il est possible de ne pas spe'cifier de nom de noeud pour une
re`gle, si cette re`gle ne comporte qu'un seul non-terminal ou
terminal ge'ne'rique en partie droite (e'ventuellement accompagne' de
terminaux non ge'ne'riques).  Lorsque l'analyseur syntaxique re'duit
une telle re`gle, il n'apporte aucune modification a` l'arbre en cours
de construction.  Ces omissions permettent donc de condenser l'arbre
abstrait engendre'.

 \item Enfin, en cas d'erreur syntaxique non corrigible (voir
en~\ref{sec:recup-globale}), le constructeur d'arbres re'unit tous les
sous-arbres de'ja` construits et implique's dans ce rattrapage global
sous un noeud de nom \verb|ERROR|.
\end{enumerate}

{\bf Remarque}\,: On peut donner le me^me nom de noeud a` plusieurs
re`gles diffe'rentes si elles ont la me^me arite' (c'est a` dire les
noeuds repre'sentant les non-terminaux de la partie gauche des re`gles
ont le me^me nombre de fils).

Voir par exemple la grammaire de'crivant le me'talangage lexical en
page~\pageref{annexe:lecl.bnf}.

Une fois la grammaire modifie'e, on la soumet a` l'entre'e de
{\SEMAT}.  En plus des sorties propres a` {\BNF}, {\SEMAT} fournit,
pour chaque nom de noeud et pour chacune des positions des fils, la
liste de tous les noms de noeuds qui peuvent se trouver a` cette
position.

De plus, une trame de passe se'mantique est engendre'e, e'crite en
langage~C.  Cette trame peut e^tre utilise'e, apre`s avoir e'te'
comple'te'e {\it manuellement\/} par les calculs d'attributs, pour
e'crire l'analyseur se'mantique.

\subsection{Re'alisation de l'analyseur se'mantique}

\subsubsection{E'valuation des attributs se'mantiques}

Les attributs se'mantiques sont associe's aux noeuds de l'arbre
abstrait.  Une {\sl passe se'mantique\/} consiste en un parcours de
cet arbre dans le sens ``haut-bas, gauche-droite'', en profitant des
passages sur les noeuds pour e'valuer les attributs.  Plusieurs passes
peuvent e^tre re'alise'es de la sorte.

Chaque noeud est visite' deux fois\,:
\begin{enumerate}
 \item a` l'entre'e de son sous-arbre\,: lors de ce passage, les
attributs {\sl he'rite's\/} du noeud sont e'value's.  Cette visite
sera dite ``he'rite'e''.

 \item a` la sortie du sous-arbre\,: cette fois les attributs {\sl
synthe'tise's\/} sont e'value's.  Cette visite sera qualifie'e de
``synthe'tise'e''.
\end{enumerate}

Depuis un noeud, il est possible d'acce'der aux noeuds voisins (s'ils
existent), a` savoir\,: son pe`re, ses fre`res et ses fils.  Il est donc
possible, en un noeud donne', de calculer un attribut de ce noeud en
fonction d'attributs de'ja` calcule's des noeuds voisins.

\subsubsection{Les outils}

Les outils ne'cessaires a` la re'alisation de l'analyse se'mantique
sont principalement la structure des noeuds et les pointeurs qui
permettent d'y acce'der, ainsi que les proce'dures de parcours de
l'arbre abstrait (voir la documentation en ligne sur \verb|sxatc(3)|
et~\verb|sxat_mngr(3)|).

Tous les noeuds de l'arbre ont la me^me structure, et posse`dent donc
tous les attributs utilise's.

La macro ``\verb|VISITED|'' s'e'tend en un pointeur vers le noeud
{\sl visite'\/}---celui pour lequel on doit calculer des attributs.

\begin{figure}[btp]
 \caption{Acce`s a` l'arbre abstrait.}
	\label{fig:arbre-abstrait}
 \vspace{1ex}
Le sous-arbre {\sl entourant\/} le noeud visite' a la structure
suivante\,:
\begin{center} \small
\begin{verbatim}
                                 _______
                                 |     |
              VISITED->father--->|     |
                                 |_____|
                                  | | |
        __________________________| | |__________________________
        |                           |                           |
     ___|___                     ___|___                     ___|___
     |     |                     |     |                     |     |
B1-->|     |  ...   VISITED----->|     |  ...           Bn-->|     |
     |_____|                     |_____|                     |_____|
                                  | | |
        __________________________| | |__________________________
        |                           |                           |
     ___|___                     ___|___                     ___|___
     |     |                     |     |                     |     |
S1-->|     |  ...        Si----->|     |  ...           Sm-->|     |
     |_____|                     |_____|                     |_____|
\end{verbatim}
\end{center}
\end{figure}

Les relations suivantes, qui font re'fe'rence a` la
figure~\ref{fig:arbre-abstrait}, sont ve'rifie'es\,:

\begin{center} \tt
 \begin{tabular}{rcl}
${\tt B}_1$ &	= & {\tt sxbrother (VISITED, 1)}	\\
VISITED &	= & {\tt sxbrother (VISITED, VISITED->position)} \\
${\tt B}_n$ &	= & {\tt sxbrother (VISITED, $n$)}	\\
& & {\rm avec } $n$ = {\tt VISITED->father->degree}	\\[5pt]
${\tt S}_1$ &	= & {\tt sxson (VISITED, 1)}		\\
${\tt S}_i$ &	= & {\tt sxson (VISITED, $i$)}		\\
${\tt S}_m$ &	= & {\tt sxson (VISITED, $m$)}		\\
& & {\rm avec } $m$ = {\tt VISITED->degree}
 \end{tabular}
\end{center}

Quelques {\sl acce'le'rateurs\/} peuvent e^tre utilise's dans certains
cas, pour ame'liorer la vitesse d'acce`s a` un noeud particulier\,:
\begin{itemize}
 \item On peut acce'der au fre`re de droite (s'il existe) par
\verb|VISITED->brother| pluto^t que par \verb|sxbrother (VISITED,
VISITED->position + 1)|.

 \item Si l'on est en visite he'rite'e, le fre`re de gauche (s'il
existe) peut e^tre acce'de' par \verb|LEFT| pluto^t que par
\verb|sxbrother (VISITED, VISITED->position - 1)|.
 \item En visite synthe'tise'e, le fils le plus a` droite peut e^tre
acce'de' par \verb|LAST_ELEM| pluto^t que par
\verb|sxson (VISITED, VISITED->degree)|.
\end{itemize}

\subsubsection{Mise en oeuvre}

L'e'valuation des attributs est re'alise'e par des instructions qui
sont a` inse'rer dans la trame engendre'e par {\SEMAT}.  Cette trame
comporte essentiellement la de'finition de deux proce'dures\,:
\begin{itemize}

 \item {\it nom-du-langage}\verb|_pi| pour les attributs he'rite's,

 \item {\it nom-du-langage}\verb|_pd| pour les attributs
synthe'tise's.
\end{itemize}

Ces deux proce'dures sont constitue'es principalement par des
instructions \verb|switch|, le choix e'tant fait sur\,:
\begin{itemize}
 \item le nom du noeud pe`re, puis la position du fils visite', pour
la passe he'rite'e\,;

 \item le nom du noeud visite' pour la passe synthe'tise'e.
\end{itemize}

L'ente^te d'une telle trame est constitue'e par les de'clarations de
constantes repre'sentant les noms de noeud.  Chaque nom de constante
est forme' par le nom du noeud suffixe' par ``\verb"_n"''.

Par exemple, au noeud de nom \verb"OBJ" et de code interne~3 est
associe'e la de'finition \verb|#define OBJ_n 3|.

Les deux proce'dures ``{\it nom-du-langage}\verb|_pi|'' et ``{\it
nom-du-langage}\verb|_pd|'' sont passe'es en parame`tre a`
\verb|sxsmp|, qui re'alise une passe ``haut-bas gauche-droite'' sur
l'arbre parame`tre.  Chaque fois qu'un noeud est visite' en he'rite',
\verb|sxsmp| appelle {\it nom-du-langage}\verb|_pi|, chaque fois qu'un
noeud est visite' en synthe'tise', \verb|sxsmp| appelle {\it
nom-du-langage}\verb|_pd|.

On trouvera en annexe~\ref{annexe:bnf_at.c}, a` titre d'exemple, la
passe se'mantique produite automatiquement par {\SEMAT} sur la
grammaire syntaxique de {\BNF}.

\vspace{1ex}

{\bf Remarques}\,: Il est possible de spe'cifier que le prochain noeud
visite' sera ``\verb|node|'' dans le {\sl sens\/} ``\verb|kind|''
(\verb|INHERITED| ou \verb|DERIVED|), en utilisant la macro
``\verb|sxat_snv (kind, node)|''.

Le module {\MIX} (voir la documentation en ligne---{\tt man~mix}) peut
aider a` ge'rer les versions successives d'une passe se'mantique.

\chapter[RECOR -- Le traitement des erreurs]
{RECOR~: \\ Le traitement des erreurs}
	\label{chap:erreurs}

Pour tout langage ``{\it nom-du-langage}'', une spe'cification
destine'e au traitement des erreurs doit e^tre de'crite dans un
fichier {\it nom-du-langage}\verb".recor".

En ge'ne'ral, ce fichier sera construit par modifications de
\verb"standard.recor".	Une modification de la spe'cification du
traitement des erreurs ne ne'cessite que de re'activer le module
{\RECOR}, sans avoir a` repasser les autres phases de la construction.

\section{Traitement des erreurs syntaxiques}

Le traitement des erreurs dans le syste`me {\SYNTAX} se de'compose en
deux parties\,:
\begin{enumerate}
 \item une tentative de {\sl correction locale\/} du programme source
errone'\,;

 \item si la tentative pre'ce'dente e'choue, {\sl re'cupe'ration\/} de
l'erreur de'tecte'e, au niveau global.
\end{enumerate}

\subsection{Correction locale}

Supposons qu'une erreur de syntaxe soit de'tecte'e sur le symbole
terminal $a_1$.	 Soit $x a_0 y$ le texte source ou` $x a_0$ est la
portion de texte de'ja` analyse'e ($a_0$ est le symbole pre'ce'dent
$a_1$) et $y=a_1 a_2 a_3\ldots$ est la partie non encore analyse'e.

La me'thode de correction locale s'e'nonce comme suit\,:
\begin{quotation}
 On conside`re l'ensemble $\cal V$ de toutes les chai^nes terminales
de longueur $n$ telles que, quelle que soit la chai^ne $t$ de $\cal
V$, la chai^ne $x t$ soit (un pre'fixe de chai^ne) syntaxiquement
correcte.

 On choisit dans $\cal V$ une chai^ne qui va remplacer le de'but de
$a_0 y$ de telle fac,on que le texte source modifie' {\sl ressemble\/}
au texte source initial.  Cette {\sl ressemblance\/} est de'crite par
l'utilisateur, qui spe'cifie une liste de mode`les de priorite'
de'croissante.
\end{quotation}

Conside'rons par exemple les trois mode`les suivants nume'rote's de 1
a`~3\,:
\begin{center}
\begin{minipage}{3cm}
 \begin{flushleft}
     1	: \quad \verb|0 X 1 2 3|	\\
     2	: \quad \verb|0 X 2 3 4|	\\
     3	: \quad \verb|0 2 3 4|
 \end{flushleft}
\end{minipage}
\begin{minipage}{10pt}
\begin{picture}(10,20)
\put(5,20){\vector(0,-1){20}}
\end{picture}
\end{minipage}
\begin{minipage}{2cm}
 priorite' \\ de'croissante
\end{minipage}
\end{center}

Dans ces mode`les, \verb|X| a la signification ``un symbole terminal
quelconque du langage'', et les nombres repre'sentent les symboles
terminaux du texte source\,: \verb|0| pour $a_0$, \verb|1| pour
$a_1$,~...

Supposons que la chai^ne ``~$a_0 b a_2 a_3 a_4$~'' soit dans $\cal V$.
Cette chai^ne satisfait le mode`le nume'ro~2, ce qui est interpre'te'
de la fac,on suivante\,:
\begin{quote}
 Le symbole $a_1$ est errone' mais peut e^tre remplace' par le
symbole~$b$.
\end{quote}
La chai^ne d'entre'e ``~$a_0 a_1 a_2 a_3 a_4$~'' sera donc remplace'e
par ``~$a_0 b a_2 a_3 a_4$~'' a` moins qu'il n'y ait dans $\cal V$ une
chai^ne qui satisfasse le premier mode`le (``~$a_0 c a_1 a_2 a_3$~''
par exemple) de plus forte priorite'.

Les mode`les peuvent e'videmment e^tre plus e'labore's\,:

\begin{center}
 \begin{tabular}{ll}
  \multicolumn{1}{c}{Mode`le} &
   \multicolumn{1}{l}{Interpre'tation}			\\[2pt]

\verb|1	 :  0 X 1 2 3|	& oubli d'un symbole		\\
\verb|2	 :  0 X 2 3 4|	& un symbole errone'		\\
\verb|3	 :  0 2 3 4|	& un symbole en trop		\\
\verb|4	 :  1 0 2 3|	& interversion de deux symboles \\
\verb|5	 :  X 1 2 3 4|	& symbole pre'ce'dent errone'	\\
\verb|6	 :  1 2 3 4|	& symbole pre'ce'dent en trop
 \end{tabular}
\end{center}

La longueur du plus long mode`le spe'cifie la longueur $n$ des
chai^nes de $\cal V$.

A` la vue de ces mode`les, on remarquera que l'on a la possibilite'
d'effectuer des corrections impliquant le symbole qui pre'ce`de le
symbole sur lequel l'erreur a e'te' de'tecte'e.

Les mode`les utilise's ne doivent pas e^tre trop longs, pour ne pas
augmenter de manie`re conse'quente le temps d'exe'cution de la
correction d'erreur.  Il semble qu'un bon compromis soit atteint pour
une valeur de $n$ voisine de~4 ou~5.

{\SYNTAX} comporte e'galement un me'canisme assez ge'ne'ral de
correction des ``fautes d'orthographe'' sur les mots cle's.  Ce
me'canisme peut e^tre exploite' lors de la tentative de correction
d'une erreur mettant en cause un terminal ge'ne'rique dont la
de'finition lexicale ``reconnai^t'' un ou plusieurs mots cle's.  Il
permet de corriger les fautes simples tombant dans l'une des quatre
cate'gories suivantes\,:
\begin{itemize}
 \item omission d'un caracte`re,
 \item ajout d'un caracte`re,
 \item remplacement d'un caracte`re,
 \item interversion de deux caracte`res.
\end{itemize}

Ce me'canisme sera mis en oeuvre si l'on fournit des mode`les dans
lesquels un nume'ro de symbole terminal est remplace' par
``\verb|S|''.

{\bf Exemple}\,:
\begin{center}
 \begin{tabular}{ll}
\verb|0 S 2|	& correction sur le symbole $a_1$	\\
\verb|S 1|	& correction sur le symbole $a_0$
 \end{tabular}
\end{center}

\subsection{Re'cupe'ration globale}
	\label{sec:recup-globale}

Si aucune correction locale, gouverne'e par les mode`les fournis, ne
peut produire une chai^ne valide, l'on tente une action globale
permettant la reprise de l'analyse.

Cette re'cupe'ration globale utilise la liste de {\sl terminaux de
rattrapage\/} de ``\verb"Key_Terminals"'' (voir
en~\ref{sec:standard.recor}).

Lorsque la correction locale a e'choue', le texte source est lu (sans
analyse) jusqu'a` rencontrer un des terminaux de rattrapage.
L'analyseur regarde alors si la chai^ne source de longueur $p$ ($p$
est donne' par ``\verb"Validation_length"'') commenc,ant par ce
terminal peut e^tre un suivant possible de l'un des e'tats de la pile
d'analyse apre`s transition sur un non-terminal\,:
\begin{itemize}
 \item si oui, l'analyse repart de cet endroit et on de'pile jusqu'a`
ce que l'on puisse {\it transiter} sur ce non-terminal a` partir du
sommet de pile.	 Tout se passe comme si la partie du texte non
analyse'e, plus e'ventuellement une portion du texte de'ja` analyse'e,
e'tait conside're'e comme une chai^ne de'rive'e de ce non-terminal\,;

 \item si non, l'analyseur recherche dans le texte source le prochain
terminal de rattrapage et il recommence.
\end{itemize}

Cette description du me'canisme de re'cupe'ration globale sugge`re
qu'il est pre'fe'rable, pour permettre une {\sl bonne\/}
re'cupe'ration d'erreurs, que les terminaux de rattrapage choisis
soient place's, dans la grammaire, imme'diatement apre`s des
non-terminaux repre'sentant des {\sl phrases de haut niveau\/} du
langage---voir l'exemple de la figure~\ref{fig:ex-recup-globale}.

\begin{figure}[hbtp]
 \caption{Modification de la grammaire pour ame'liorer le rattrapage d'erreur.}
	\label{fig:ex-recup-globale}
 \vspace{1ex}
Conside'rons les re`gles suivantes\,:
\begin{verbatim}
        <LISTE DE DECL> = <LISTE DE DECL> <DECL> ;
        <LISTE DE DECL> = <DECL>                 ;
        <DECL>          = DCL %id #;             ;
\end{verbatim}

Le ``\verb";"'' est {\it a priori\/} de'fini comme un terminal de
rattrapage.  Mais si une erreur se produit en de'but de de'claration,
le ``\verb";"'' se trouvant en fin de de'claration ne pourra pas
permettre de se re'cupe'rer car il n'est pas pre'ce'de' d'un
non-terminal.

Pour permettre la re'cupe'ration, il faut transformer la grammaire,
par exemple de la fac,on suivante\,:
\begin{verbatim}
        <LISTE DE DECL> = <LISTE DE DECL> <DECL> #; ;
        <LISTE DE DECL> = <DECL> #;                 ;
        <DECL>          = DCL %id                   ;
\end{verbatim}
\end{figure}


{\bf Remarque}\,: Avant d'effectuer une re'cupe'ration globale,
l'analyseur regarde s'il n'existe qu'un seul symbole pouvant suivre la
partie du texte source de'ja` analyse'e.  Si c'est le cas, il
l'inse`re automatiquement et il repart sur ce symbole.	Il peut ainsi
rajouter toute une se'quence de symboles ``obligatoires''.

\section{Traitement des erreurs lexicales}

Les erreurs lexicales e'tant plus rares que les erreurs syntaxiques,
la correction des erreurs est moins e'labore'e.	 Elle repose
uniquement sur une correction locale, et utilise le me^me principe que
dans l'analyse syntaxique.  Mais seuls les mode`les permettant
l'insertion, le remplacement ou la suppression d'un caracte`re sont
autorise's.  L'utilisateur a seulement la possibilite' de modifier la
longueur des mode`les et l'ordre dans lequel ils sont de'finis dans la
liste fournie par {\SYNTAX}\,:

\begin{center}
 \begin{tabular}{ll}
  \multicolumn{1}{c}{Mode`le} &
   \multicolumn{1}{c}{Interpre'tation}			\\[2pt]

\verb|1	 :  1 2 3 4|	& suppression	\\
\verb|2	 :  X 1 2 3 4|	& remplacement	\\
\verb|3	 :  X 0 1 2 3|	& insertion
 \end{tabular}
\end{center}

Au niveau lexical, il est impossible d'agir sur le caracte`re
pre'ce'dent le caracte`re en erreur, 0 de'signe donc le caracte`re en
erreur, 1 le caracte`re qui le suit etc...
Si aucun mode`le ne s'applique, le caracte`re en erreur est supprime'.

\section{Le fichier {\tt standard.recor}}
	\label{sec:standard.recor}

Ce fichier permet non seulement de spe'cifier le traitement des
erreurs des niveaux lexicographique et syntaxique et e'galement les
textes des diagnostics qui seront produits.  Il est donc possible, par
exemple, de de'crire les messages en Franc,ais, Allemand ou
patois\ldots

La spe'cification contenue dans \verb"standard.recor" est donne'e en
annexe~\ref{annexe:standard.recor}.

Le texte d'un message est forme' d'une se'quence de chai^nes de
caracte`res (les guillemets internes doivent e^tre pre'ce'de's de
``\verb"\"'').	``\verb"$"$n$, ou` $n$ est un entier positif ou nul,
sera remplace' par le $n$-ie`me symbole de la chai^ne source
(attention, dans l'analyseur lexical, le caracte`re en erreur est le
nume'ro~0, alors que dans l'analyseur syntaxique le terminal en erreur
est le nume'ro~1).  ``\verb"%"$n$'' sera remplace' par le symbole
correspondant au ``\verb"X"'' (ou au ``\verb"S"'') d'indice $n$ dans
le mode`le courant.  Ainsi avec le mode`le \verb"0 X 1 X 3",
``\verb|%1|'' de'signe le premier \verb|X| et ``\verb|%3|'' le second.

``\verb|Dont_Delete|'' et ``\verb|Dont_Insert|'' sont des ensembles de
symboles, spe'cifie's par l'utilisateur, qui permettent d'influer sur
le me'canisme ge'ne'ral qui vient d'e^tre de'crit, afin de limiter les
possibilite's de suppression ou d'insertion de symboles a` forte
connotation ``se'mantique''.  Il est en effet souvent dangeureux pour
la suite de l'analyse de supprimer ou d'inse'rer un ``symbole
ouvrant'' qui ne'cessite que l'on rencontre plus tard le ``symbole
fermant'' correspondant.  La prise en compte de ces deux ensembles
conduit a` une modification dynamique des priorite's respectives des
diffe'rentes instances des mode`les de correction.  Ils ont en effet
la de'finition suivante\,:
\begin{quote}
Lors d'une tentative de correction, une instance d'un mode`le qui
implique la suppression d'un symbole de \verb|Dont_Delete| ne sera
choisie que s'il n'existe pas d'instance d'un mode`le, me^me moins
prioritaire, qui ne ne'cessite ni la suppression d'un e'le'ment de
\verb|Dont_Delete| ni l'insertion d'un e'le'ment de
\verb|Dont_Insert|.  De me^me, l'insertion d'un e'le'ment de
\verb|Dont_Insert| ne pourra avoir lieu que si aucun mode`le ne permet
de correction sans suppression d'e'le'ment de \verb|Dont_Delete|.
\end{quote}

Pour le niveau lexical, les e'le'ments de ces ensembles sont des
caracte`res\,; pour le niveau syntaxique, il s'agit de symboles
terminaux.

``\verb|Key_Terminals|'', dans la spe'cification destine'e a` la
re'cupe'ration globale de l'analyseur syntaxique, de'finit l'ensemble
des symboles terminaux sur lesquels sera tente'e la re'cupe'ration si
la correction a e'choue'.  Ces symboles sont e'galement utilise's pour
limiter la taille d'un mode`le de correction.  Soit ``~\verb|0 X 1 2 3
4|~'' un mode`le tel que, pour l'erreur courante, le symbole $a_2$
soit un e'le'ment de ``\verb|Key_Terminals|''.	 Dans ce cas, il est
e'quivalent au mode`le ``~\verb|0 X 1 2|~'', la chai^ne $a_3 a_4$ n'a
pas besoin d'e^tre valide'e.  Cette extension permet d'accroi^tre
les possibilite's de correction dans des portions de texte denses en
erreurs.


\chapter[TABLES\_C -- Production des tables d'analyse en langage~C]
	{TABLES\_C~: \\ Production des tables d'analyse en langage~C}
	\label{chap:tablesc}

Le module {\TABLESC} constitue l'e'pilogue obligatoire d'une
construction\,; il a deux fonctions\,:
\begin{itemize}
 \item Ve'rifier la cohe'rence globale des tables qui ont e'te'
pre'alablement produites par les diffe'rents constructeurs de
{\SYNTAX}---ces tables contiennent en effet une indication permettant
de de'terminer si les constructeurs ont exploite' la me^me version de
la grammaire syntaxique.

 \item Traduire l'ensemble de ces tables en un programme en langage~C
forme' essentiellement de variables initialise'es.
\end{itemize}

{\TABLESC} produit un texte sur sa sortie standard ({\tt stdout}), qui
est usuellement redirige'e vers un fichier de nom {\it
nom-du-langage}\verb|_t.c|\,; ce texte rassemble, pour le langage {\it
nom-du-langage}, toutes les tables ne'cessaires a` l'analyse et au
traitement de la se'mantique, produites par les diverses phases de la
construction.  Il contient en outre, si {\it nom-du-langage} comporte
des mots cle's, le texte, en langage~C, de la fonction
\verb|check_keyword|.


\chapter{Analyse d'un texte source}
	\label{chap:sxunix}

L'analyse d'un texte source est re'alise'e en une ou deux passes,
suivant le type de description se'mantique choisi.

La premie`re passe correspond a` l'analyse lexicale et syntaxique du
texte source.

L'analyse lexicale est re'alise'e par l'analyseur lexical---ou {\it
scanner}, qui est un interpre'teur de l'automate d'e'tats finis
produit par {\LECL}.  Le {\it scanner\/} lit le texte source (par
l'interme'diaire du {\it source manager\/}) et remplit d'une part la
structure \verb"terminal_token" qui sera exploite'e par l'analyseur
syntaxique et d'autre part la \verb|string_table| (table contenant les
textes des unite's lexicales, exploite'e par l'interme'diaire du {\it
string manager\/}).

L'analyse syntaxique est re'alise'e par l'analyseur syntaxique---ou
{\it parser}, qui est un interpre'teur de l'automate a` pile produit
par {\CSYNT}.  Au cours de cette passe, selon le type de se'mantique
choisi, des appels a` des actions se'mantiques sont effectue's ou bien
un arbre abstrait est engendre'.

Dans le cas ou` on re'alise la se'mantique par arbre abstrait, une
deuxie`me passe ({\it SEMANTIC PASS\/}) est effectue'e.	 Elle consiste
uniquement a` exe'cuter le programme \verb|semantic_pass| e'crit par
l'utilisateur.

Les analyseurs lexical et syntaxique contiennent e'galement des
modules permettant la correction {\it vel\/} la re'cupe'ration
automatique des erreurs.  Ces modules ont e'te' spe'cifie's par
l'interme'diaire de {\RECOR}---voir le chapitre~\ref{chap:erreurs}.

\section{Mise en oeuvre}

Se reporter a` la documentation en ligne\,; voir notamment
\verb|sxsrc_mngr(3)|, \verb|sxscanner(3)|, \verb|sxparser(3)|,
\verb|sxstr_mngr(3)|, \verb|sxatc(3)|, \verb|sxat_mngr(3)|.


\appendix\onecolumn


\chapter{Spe'cifications du langage BNF}
	\label{chap:bnf.spec}

\section{De'finition syntaxique}
	\label{annexe:bnf.bnf}

Ceci est la grammaire de {\BNF} (voir le chapitre~\ref{chap:bnf}).
Les chai^nes de caracte`res suivant une re`gle de grammaire---a` la
droite du~``\verb|;|''---sont une spe'cification d'arbre abstrait
destine'e a` {\SEMAT} (voir en~\ref{sec:semat}).

{\small\tt
\begin{tabbing}
<VOCABULARY\_LIST> \== <VOCABULARY\_LIST> \ <VOCABULARY> \ \=; \kill
{*}								\\
{*} This grammar is used for the specification of BNF		\\
{*}								\\
<BNF>	\>	= <RULE\_LIST>	\>			; "BNF" \\
{*}								\\
<RULE\_LIST> \> = <RULE\_LIST>					\\
	\>\ \	  <RULE>	\>			;	\\
<RULE\_LIST> \> = <RULE>	\>			; "RULE\_S"	\\
{*}								\\
<RULE>	\>	= <VOCABULARY\_LIST> \ ";"	\>	;	\\
{*}								\\
<VOCABULARY\_LIST>
	\>	= <VOCABULARY\_LIST> \ <VOCABULARY> \>	;	\\
<VOCABULARY\_LIST>
	\>	= \%LHS\_NON\_TERMINAL \ =	\>	; "VOCABULARY\_S"	\\
{*}								\\
<VOCABULARY> \> = \%NON\_TERMINAL	\>		; "NON\_TERMINAL"	\\
<VOCABULARY> \> = \%NON\_TERMINAL \ \%PREDICATE	\>	; "X\_NON\_TERMINAL"	\\
<VOCABULARY> \> = \%ACTION	\>			; "ACTION"	\\
<VOCABULARY> \> = <TERMINAL>	\>			;	\\
<VOCABULARY> \> = <TERMINAL> \ \%PREDICATE	\>	; "X\_TERMINAL" \\
{*}								\\
<TERMINAL> \>	= \%TERMINAL	\>			; "TERMINAL"	\\
<TERMINAL> \>	= \%GENERIC\_TERMINAL	\>		; "GENERIC\_TERMINAL"
\end{tabbing}
}

\section{De'finition lexicale}
	\label{annexe:bnf.lecl}

{\small
\begin{verbatim}
Classes

        PRINT           = ANY - #000..#040 - #177 ;
        T_HEADER        = PRINT - "<#;\"~&@" ;
        NT_BODY         = PRINT + SP - ">" ;
        OCTAL           = "0".."7" ;


Abbreviations

        NUMBER_NORMAL_FORM
                        = @Mark {"0"&True}+ @Erase {DIGIT}+
                        | "0"&True
                        | {DIGIT}+ ;


Tokens

        Comments        = -{SP | HT | VT | FF |
                            "~" {^"~\n" | {EOL}+ ^"<~\n"} {EOL} "~" |
                            EOL {"*" {^EOL} EOL}}+ ;
                           Priority Shift>Reduce ;
                           Context All But Comments ;
        %LHS_NON_TERMINAL
                        = "<"&Is_First_Col @Set (0) {NT_BODY} ">" ;
        %NON_TERMINAL   = "<" {NT_BODY} ">" ;
        %TERMINAL       = (-"#" PRINT | T_HEADER) {PRINT}
                        | -QUOTE {^"\"\n\\" |
                                  -"\\" {-EOL -"\\"}
                                      (-EOL ^"\"\n\\<" |
                                       -"n" @Put (EOL) |
                                       -"b" @Put (BS) |
                                       -"t" @Put (HT) |
                                       -"v" @Put (VT) |
                                       -"f" @Put (FF) |
                                       -"r" @Put (CR) |
                                       @Mark OCTAL&True
                                            [OCTAL&True [OCTAL&True]]
                                            @2 |
                                       ^"bnfrtv\n"
                                      )
                                 }+ {-"\\" -EOL}
                          -QUOTE ;
                           Priority Shift>Reduce ;
                           Context Comments ;
        %GENERIC_TERMINAL
                        = "%" LETTER {["_"] (LETTER | DIGIT)} ;
                           Priority Reduce>Reduce, Shift>Reduce ;
                           Context Comments ;
        %ACTION         = "@" NUMBER_NORMAL_FORM ;
                           Context Comments ;
        %PREDICATE      = "&" NUMBER_NORMAL_FORM ;
                           Context Comments ;
        "="             = -"="&Is_Set (0) @Reset (0) ;
        ";"             = -";" @1 ;


--  scan_act (INIT)  : erases the source text from beginning until the
--                         first "<" laying at column 1
--  @1  : Skip the source text until the first "<" laying at column 1
--  @2  : Convert octal code \nnn to character
\end{verbatim}
}

\section{Actions et pre'dicats lexicaux}
	\label{annexe:bnf_sact.c}

Ceci est le codage en langage~C des actions et pre'dicats associe's a`
la description lexicale de {\BNF}.

{\small
\begin{verbatim}
#include "sxunix.h"


#define rule_slice 100

static struct span {
           unsigned long        head;
           struct tail {
               unsigned long    line;
               unsigned int     column;
           }    tail;
       }        *coords;
static int      xprod, rules_no;
static int      current_rule_no;



int     bnf_get_line_no (rule_no)
    int         rule_no;
{
    return rule_no > xprod ? 0 : coords [rule_no].head;
}



SXVOID  bnf_skip_rule ()
{
    register struct tail        *tail_coord;
    register unsigned long      line;
    register unsigned int       column;

    if (current_rule_no >= xprod) {
        current_rule_no = 0;
    }

    tail_coord = &coords [++current_rule_no].tail;
    line = tail_coord->line;
    column = tail_coord->column;

    while (sxsrcmngr.source_coord.line < line) {
        if (sxnext_char () == EOF)
            return;
    }

    while (sxsrcmngr.source_coord.column < column) {
        if (sxnext_char () == EOF)
            return;
    }
}



SXVOID  bnf_found_bad_beginning_of_rule ()
{
    struct sxsource_coord       less_coord;

    less_coord = sxsrcmngr.source_coord, less_coord.column = 1;
    sxput_error
         (less_coord,
          "%s\
Illegal occurrence of \"<\"; \
the head of a new grammar rule is assumed.",
          sxsvar.sxtables->err_titles [2]);
    sxsrcpush ('\n', "<", less_coord);
}



static VOID     gripe ()
{
    fputs ("\nThe function \"bnf_scan_act\" is out of date \
with respect to its specification.\n", sxstderr);
    abort ();
}



SXVOID  (*more_scan_act) ();



bnf_scan_act (code, act_no)
    int         code;
    int         act_no;
{
    switch (code) {
    case OPEN:
        coords = (struct span*) sxalloc (rules_no = rule_slice,
                                         sizeof (struct span))
                                - 1;

        if (more_scan_act != NULL) {
            (*more_scan_act) (code, act_no);
        }

        return;

    case CLOSE:
        if (more_scan_act != NULL) {
            (*more_scan_act) (code, act_no);
        }

        if (coords != NULL) {
            sxfree (coords + 1);
        }

        return;

    case INIT:
        if (more_scan_act != NULL) {
            (*more_scan_act) (code, act_no);
        }

        {
            register SHORT      c;

            c = sxsrcmngr.current_char;

            while (c != EOF)
                if (c == '<' && sxsrcmngr.source_coord.column == 1) {
                    coords [xprod = 1].head =
                         sxsrcmngr.source_coord.line;
                    return;
                }
                else
                    c = sxnext_char ();
        }

        fprintf (sxstderr, "\n\tThis text is not a grammar... \
See you later.\n");
        SXEXIT (3);

    case FINAL:
        if (more_scan_act != NULL) {
            (*more_scan_act) (code, act_no);
        }

        return;

    case ACTION:
        switch (act_no) {
            register SHORT      c;

        case 1:
            coords [xprod].tail.line = sxsrcmngr.source_coord.line;
            coords [xprod].tail.column = sxsrcmngr.source_coord.column;

            if (more_scan_act != NULL) {
                (*more_scan_act) (code, act_no);
            }

            c = sxsrcmngr.current_char;

            while (c != EOF)
                if (c == '<' && sxsrcmngr.source_coord.column == 1) {
                    if (++xprod > rules_no) {
                        coords = (struct span*)
                              sxrealloc (coords + 1,
                                         rules_no += rule_slice,
                                         sizeof (struct span))
                              - 1;
                    }

                    coords [xprod].head = sxsrcmngr.source_coord.line;
                    return;
                }
                else
                    c = sxnext_char ();

            return;

        case 2:
            /* \nnn => char */
            {
                register int    val;
                register char   c, *s, *t;

                t = s = sxsvar.lv_s.token_string + sxsvar.lv.mark.index;

                for (val = *s++ - '0'; (c = *s++) != NUL; ) {
                    val = (val << 3) + c - '0';
                }

                *t = val;
                sxsvar.lv.ts_lgth = sxsvar.lv.mark.index + 1;
                sxsvar.lv.mark.index = -1;
            }

            return;
        }

    default:
        gripe ();
    }
}
\end{verbatim}
}


\chapter{Spe'cifications du langage LECL}
	\label{annexe:lecl.spec}

\section{De'finition syntaxique}
	\label{annexe:lecl.bnf}

Ceci est la grammaire de {\LECL} (voir le chapitre~\ref{chap:lecl}).
Les chai^nes de caracte`res suivant une re`gle de grammaire---a` la
droite du~``\verb|;|''---sont une spe'cification d'arbre abstrait
destine'e a` {\SEMAT} (voir en~\ref{sec:semat}).  Les commandes entre
tildes (``\verb|~|'') spe'cifient un paragrapheur du langage {\LECL}
et doivent e^tre ignore'es du point de vue strictement grammatical
(cf~\verb|paradis(1)| et le rapport INRIA N$^\circ$~455, intitule'
{\it Paradis, un Syste`me de Paragraphage Dirige' par la Syntaxe},
Novembre~1985).

{\small
\begin{verbatim}
<LECL_GRAMMAR>  = <CLASSES_LIST_OPTION>


                  <ABBREVIATIONS_LIST_OPTION>


                  <TOKENS_LIST_OPTION>


                  <SYNONYMS_LIST_OPTION>


                  <REPR_SPEC_LIST_OPTION>
                                                ~~; "PROGRAM_ROOT_LECL"
*
*    C L A S S E S
*
<CLASSES_LIST_OPTION>
                = ~INH~                         ~~;
<CLASSES_LIST_OPTION>
                = CLASSES

                ~TAB~   <CLASSES_LIST>  ";"     ~~;

<CLASSES_LIST>  = <CLASSES_LIST>  ";"
                  <CLASS>                       ~~;
<CLASSES_LIST>  = <CLASS>                       ~~; "CLASS_S"

<CLASS>         = <CLASS_NAME> ~
                  COL(24)~ ~SPACE~ "="  <CLASS_EXP> ~
                                                 ~; "CLASS"

<CLASS_NAME>    = %IDENTIFIER                   ~~; "CLASS_NAME"

<CLASS_EXP>     = <CLASS_EXP>  +  <CLASS_TERM>  ~~; "PLUS"
<CLASS_EXP>     = <CLASS_EXP>  -  <CLASS_TERM>  ~~; "MINUS"
<CLASS_EXP>     = <CLASS_TERM>                  ~~;

<CLASS_TERM>    = ( <CLASS_EXP> )               ~~;
<CLASS_TERM>    = <CLASS_REF>                   ~~;

<CLASS_REF>     = <SIMPLE_REF>                  ~~;
<CLASS_REF>     = <SLICE>                       ~~;

<SLICE>         = <SIMPLE_REF> .. <SIMPLE_REF>  ~~; "SLICE"

<SIMPLE_REF>    = %IDENTIFIER                   ~~; "ID"
<SIMPLE_REF>    = %STRING_LITERAL               ~~; "STRING"
<SIMPLE_REF>    = %OCTAL_CODE                   ~~; "OCTAL_CODE"
*
*   A B B R E V I A T I O N S
*
<ABBREVIATIONS_LIST_OPTION>
                = ~INH~                         ~~;
<ABBREVIATIONS_LIST_OPTION>
                = ABBREVIATIONS

                ~TAB~ <ABBREVIATIONS_LIST>  ";" ~~;

<ABBREVIATIONS_LIST>
                = <ABBREVIATIONS_LIST>  ";"
                  <ABBREVIATION>                ~~;
<ABBREVIATIONS_LIST>
                = <ABBREVIATION>                ~~; "ABBREVIATION_S"

<ABBREVIATION>  = <REGULAR_EXPRESSION_NAME> ~
                  COL(24)~ ~SPACE~ "="  <REGULAR_EXPRESSION> ~
                                                 ~; "ABBREVIATION"
<ABBREVIATION>  = <PREDICATE_NAME> ~
                  COL(24)~ ~SPACE~ "="  <&_EXPRESSION> ~
                                                 ~; "ABBREVIATION"

<REGULAR_EXPRESSION_NAME>
                = %IDENTIFIER                   ~~;
                                                  "ABBREVIATION_RE_NAME"

<PREDICATE_NAME>= %PREDICATE_NAME               ~~;
                                               "ABBREVIATION_PRDCT_NAME"

<&_EXPRESSION>  = <&_OR>                        ~~; "PRDCT_EXPRESSION"

<&_OR>          = <&_OR>  |  <&_ET>             ~~; "PRDCT_OR"
<&_OR>          = <&_ET>                        ~~;

<&_ET>          = <&_ET>  <&_TERM>              ~~; "PRDCT_ET"
<&_ET>          = <&_TERM>                      ~~;

<&_TERM>        = ( <&_OR> )                    ~~; "EXPRESSION"
<&_TERM>        = %PREDICATE_NAME               ~~;
<&_TERM>        = <DYNAMIC_PREDICATE>           ~~;
<&_TERM>        = ^ <DYNAMIC_PREDICATE>         ~~; "PRDCT_NOT"
*
*   T O K E N S
*
<TOKENS_LIST_OPTION>
                = ~INH~                         ~~;
<TOKENS_LIST_OPTION>
                = TOKENS

                ~TAB~   <TOKENS_LIST>           ~~;

<TOKENS_LIST>   = <TOKENS_LIST>
                  <TOKEN>                       ~~;
<TOKENS_LIST>   = <TOKEN>                       ~~; "TOKEN_S"

<TOKEN>         = <TOKEN_DEF>  ";" <VOID>       ~~; "TOKEN"
<TOKEN>         = <TOKEN_DEF>  ";"
                  ~COL(27)~ <ENVIRONMENT_LIST>  ~~; "TOKEN"

<TOKEN_DEF>     = <LEXICAL_UNIT_NAME> ~
                  COL(24)~ ~SPACE~ "="  <TOKEN_BODY> ~
                                                 ~; "TOKEN_DEF"

<LEXICAL_UNIT_NAME>
                = %GENERIC_NAME                 ~~; "LEXICAL_UNIT_NAME"
<LEXICAL_UNIT_NAME>
                = %STRING_LITERAL               ~~; "LEXICAL_UNIT_NAME"
<LEXICAL_UNIT_NAME>
                = %IDENTIFIER                   ~~; "LEXICAL_UNIT_NAME"
<LEXICAL_UNIT_NAME>
                = EOF                           ~~; "EOF"
<LEXICAL_UNIT_NAME>
                = COMMENTS                      ~~; "COMMENTS"
<LEXICAL_UNIT_NAME>
                = INCLUDE                       ~~; "INCLUDE"

<TOKEN_BODY>    = <REGULAR_EXPRESSION>          ~~;
<TOKEN_BODY>    =
                  ~COL(14)~ <UNION>             ~~;

<UNION>         = UNION
                     <COMPONENT_LIST>
                  END                           ~~;

<COMPONENT_LIST>= <COMPONENT_LIST>
                  <COMPONENT>                   ~~;
<COMPONENT_LIST>= <COMPONENT>                   ~~; "COMPONENTS_S"

<COMPONENT>     = <COMPONENT_DEF>  ";" <VOID>   ~~; "COMPONENT"
<COMPONENT>     = <COMPONENT_DEF>  ";"
                  ~COL(27)~ <ENVIRONMENT_LIST>  ~~; "COMPONENT"

<COMPONENT_DEF> = <COMPONENT_NAME> ~
                  COL(24)~ ~SPACE~ :  <REGULAR_EXPRESSION> ~
                                                 ~; "COMPONENT_DEF"

<COMPONENT_NAME>= %IDENTIFIER                   ~~; "COMPONENT_NAME_DEF"

<ENVIRONMENT_LIST>
                = <ENVIRONMENT_LIST>
                  <ENVIRONMENT>  ";"            ~~;
<ENVIRONMENT_LIST>
                = <ENVIRONMENT>  ";"            ~~; "ENVIRONMENT_S"

<ENVIRONMENT>	=  %IDENTIFIER &1  %IDENTIFIER	~ ~ ; "NOT_KEYWORD"
* &1 retourne VRAI ssi le premier identificateur est NOT
*                      et le second KEYWORD
<ENVIRONMENT>   =  %ACTION_NO                   ~~; "POST_ACTION"
<ENVIRONMENT>   =  <PRIORITY>                   ~~;
<ENVIRONMENT>   =  <CONTEXT>                    ~~;

<PRIORITY>      = PRIORITY  <PRIORITY_KIND_LIST>~~;

<PRIORITY_KIND_LIST>
                = <PRIORITY_KIND_LIST> ,  <PRIORITY_KIND> ~
                                                 ~;
<PRIORITY_KIND_LIST>
                = <PRIORITY_KIND>               ~~; "PRIORITY_KIND_S"

<PRIORITY_KIND> = REDUCE > REDUCE               ~~; "REDUCE_REDUCE"
<PRIORITY_KIND> = REDUCE > SHIFT                ~~; "REDUCE_SHIFT"
<PRIORITY_KIND> = SHIFT > REDUCE                ~~; "SHIFT_REDUCE"

<VOID>          =                               ~~;

<CONTEXT>       = CONTEXT  <TOKEN_REF_LIST>     ~~; "CONTEXT"
<CONTEXT>       = CONTEXT  ALL  BUT  <TOKEN_REF_LIST> ~
                                                 ~; "RESTRICTED_CONTEXT"
<CONTEXT>       = CONTEXT  ALL <VOID>           ~~; "RESTRICTED_CONTEXT"
<CONTEXT>       = UNBOUNDED  CONTEXT  <TOKEN_REF_LIST> ~
                                                 ~; "UNBOUNDED_CONTEXT"
<CONTEXT>       = UNBOUNDED  CONTEXT  ALL  BUT  <TOKEN_REF_LIST> ~
                                                 ~;
                                          "UNBOUNDED_RESTRICTED_CONTEXT"
<CONTEXT>       = UNBOUNDED  CONTEXT  ALL <VOID>~~;
                                          "UNBOUNDED_RESTRICTED_CONTEXT"

<TOKEN_REF_LIST>= <TOKEN_REF_LIST> ,  <TOKEN_REF> ~
                                                 ~;
<TOKEN_REF_LIST>= <TOKEN_REF>                   ~~; "TOKEN_REF_S"

<TOKEN_REF>     = <TOKEN_NAME> <VOID>           ~~; "COMPONENT_REF"
<TOKEN_REF>     = <TOKEN_NAME> . <COMPONENT_NAME_REF> ~
                                                 ~; "COMPONENT_REF"

<TOKEN_NAME>    = COMMENTS                      ~~; "CONTEXT_COMMENTS"
<TOKEN_NAME>    = EOF                           ~~; "CONTEXT_EOF"
<TOKEN_NAME>    = INCLUDE                       ~~; "CONTEXT_NAME"
<TOKEN_NAME>    = %IDENTIFIER                   ~~; "CONTEXT_NAME"
<TOKEN_NAME>    = %GENERIC_NAME                 ~~; "CONTEXT_NAME"
<TOKEN_NAME>    = %STRING_LITERAL               ~~; "CONTEXT_NAME"

<COMPONENT_NAME_REF>
                = %IDENTIFIER                   ~~; "COMPONENT_NAME_REF"
*
*   R E G U L A R   E X P R E S S I O N S
*
<REGULAR_EXPRESSION>
                = <ALTERNATIVE>                 ~~; "REGULAR_EXPRESSION"

<ALTERNATIVE>   = <ALTERNATIVE>  |  <SEQUENCE>  ~~; "ALTERNATIVE"
<ALTERNATIVE>   = <SEQUENCE>                    ~~;

<SEQUENCE>      = <SEQUENCE>  <TERM>            ~~; "SEQUENCE"
<SEQUENCE>      = <TERM>                        ~~;

<TERM>          = - <ITEM>                      ~~; "ERASE"
<TERM>          = <ITEM>                        ~~;

<ITEM>          = ( <ALTERNATIVE> )             ~~; "EXPRESSION"
<ITEM>          = [ <ALTERNATIVE> ]             ~~; "OPTION"
<ITEM>          = { <ALTERNATIVE> }             ~~; "REF_TRANS_CLOSURE"
<ITEM>          = { <ALTERNATIVE> } *           ~~; "REF_TRANS_CLOSURE"
<ITEM>          = ( <ALTERNATIVE> ) *           ~~; "REF_TRANS_CLOSURE"
<ITEM>          = { <ALTERNATIVE> } +           ~~; "TRANS_CLOSURE"
<ITEM>          = ( <ALTERNATIVE> ) +           ~~; "TRANS_CLOSURE"
<ITEM>          = <EXTENDED_CLASS_REF>          ~~;
<ITEM>          = <ACTION>                      ~~;

<EXTENDED_CLASS_REF>
                = <NOT_CLASS_REF> <PREDICATE>   ~~; "EXTENDED_CLASS_REF"
<EXTENDED_CLASS_REF>
                = <NOT_CLASS_REF>               ~~;

<NOT_CLASS_REF> = ^ <CLASS_REF>                 ~~; "NOT"
<NOT_CLASS_REF> = <CLASS_REF>                   ~~;

<ACTION>        = %ACTION_NO                    ~~;
<ACTION>        = "@UPPER_CASE"                 ~~; "UPPER_CASE"
<ACTION>        = "@LOWER_CASE"                 ~~; "LOWER_CASE"
<ACTION>        = "@LOWER_TO_UPPER"             ~~; "LOWER_TO_UPPER"
<ACTION>        = "@UPPER_TO_LOWER"             ~~; "UPPER_TO_LOWER"
<ACTION>        = "@ERASE"                      ~~; "ACTION_ERASE"
<ACTION>        = "@SET"  ( %INTEGER_NUMBER )   ~~; "SET"
<ACTION>        = "@RESET"  ( %INTEGER_NUMBER ) ~~; "RESET"
<ACTION>        = "@INCR"  ( %INTEGER_NUMBER )  ~~; "INCR"
<ACTION>        = "@DECR"  ( %INTEGER_NUMBER )  ~~; "DECR"
<ACTION>        = "@PUT"  ( <SIMPLE_REF> )      ~~; "PUT"
<ACTION>        = "@MARK"                       ~~; "MARK"
<ACTION>        = "@RELEASE"                    ~~; "RELEASE"

<PREDICATE>     = %PREDICATE_NAME               ~~;
<PREDICATE>     = <STATIC_PREDICATE>            ~~;
<PREDICATE>     = <DYNAMIC_PREDICATE>           ~~;

<STATIC_PREDICATE>
                = "&TRUE"                       ~~; "IS_TRUE"
<STATIC_PREDICATE>
                = "&FALSE"                      ~~; "IS_FALSE"

<DYNAMIC_PREDICATE>
                = %PREDICATE_NO                 ~~;
<DYNAMIC_PREDICATE>
                = "&IS_FIRST_COL"               ~~; "IS_FIRST_COL"
<DYNAMIC_PREDICATE>
                = "&IS_LAST_COL"                ~~; "IS_LAST_COL"
<DYNAMIC_PREDICATE>
                = "&IS_SET"  ( %INTEGER_NUMBER )~~; "IS_SET"
<DYNAMIC_PREDICATE>
                = "&IS_RESET"  ( %INTEGER_NUMBER ) ~
                                                 ~; "IS_RESET"
*
*  S Y N O N Y M S
*
<SYNONYMS_LIST_OPTION>
                = ~INH~                         ~~;
<SYNONYMS_LIST_OPTION>
                = SYNONYMS

                  ~TAB~ <SYNONYMS_LIST>  ";"    ~~;

<SYNONYMS_LIST> = <SYNONYMS_LIST>  ";"
                  <DENOTATION_LIST>             ~~;
<SYNONYMS_LIST> = <DENOTATION_LIST>             ~~; "SYNONYM_S"

<DENOTATION_LIST>
                = <DENOTATION_LIST> ,  <DENOTATION> ~
                                                 ~;
<DENOTATION_LIST>
                = <DENOTATION> ~
                  COL(24)~ ~SPACE~ "="  <DENOTATION> ~
                                                 ~; "DENOTATION_S"

<DENOTATION>    = %IDENTIFIER                   ~~; "ID_DENOTATION"
<DENOTATION>    = %STRING_LITERAL               ~~; "STRING_DENOTATION"
*
*  R E P R E S E N T A T I O N   S P E C I F I C A T I O N
*
<REPR_SPEC_LIST_OPTION>
                = ~INH~                         ~~;
<REPR_SPEC_LIST_OPTION>
                = ~TAB~ <REPR_SPEC_LIST>  ";"   ~~;

<REPR_SPEC_LIST>= <REPR_SPEC_LIST>  ";"
                  <REPR_SPEC>                   ~~;
<REPR_SPEC_LIST>= <REPR_SPEC>                   ~~; "REPR_SPEC_S"

<REPR_SPEC>     = <COLLATING_LIST_REPR>         ~~;
<REPR_SPEC>     = <BYTE_LENGTH_REPR>            ~~;
<REPR_SPEC>     = <WORD_LENGTH_REPR>            ~~;

<COLLATING_LIST_REPR>
                = FOR  INTERNAL  CODE  USE
                        <COLLATING_LIST>        ~~;

<BYTE_LENGTH_REPR>
                = FOR  BYTE  USE  %INTEGER_NUMBER  BITS ~
                                                 ~; "BYTE_LENGTH"

<WORD_LENGTH_REPR>
                = FOR  WORD  USE  %INTEGER_NUMBER  BITS ~
                                                 ~; "WORD_LENGTH"

<COLLATING_LIST>= <COLLATING_LIST>
                ,  <COMPOSANT>                  ~~;
<COLLATING_LIST>= <COMPOSANT>                   ~~; "COLLATING_S"

<COMPOSANT>     = <CLASS_REF>                   ~~;
<COMPOSANT>     = UNUSED                        ~~; "NOT_SPECIFIED"
<COMPOSANT>     = %INTEGER_NUMBER  UNUSED       ~~;
\end{verbatim}
}

\section{De'finition lexicale}
	\label{annexe:lecl.lecl}

{\small
\begin{verbatim}
Classes
        OCTAL           = "0".."7" ;


Abbreviations

        IDENT           = LETTER {["_"] (LETTER | DIGIT)} ;
        DARK_LET        = LETTER -{BS @1 LETTER}+ ;
        BOLD_LET        = LETTER -{BS @1 LETTER} ;
        BOLD_US         = "_" -{BS "_"} ;
        DARK_US         = "_" -{BS "_"}+ ;
        BOLD_COMMERCIAL_AT
                        = "@" -{BS "@"} ;
        DARK_AMPERSAND  = "&" -{BS "&"}+ ;
        BOLD_WORD       = BOLD_LET {[BOLD_US] BOLD_LET} ;
        DARK_WORD       = DARK_LET {[DARK_US] DARK_LET} ;
        NUMBER_NORMAL_FORM
                        = @Mark {"0"&True}+ @Erase {DIGIT}+
                        | "0"&True
                        | {DIGIT}+ ;


Tokens

        Comments        = -({SP | HT | EOL | VT | FF}+ 
                        | "-" "-" {^EOL} EOL) ;
                           Context All But Comments ;
        %IDENTIFIER     = IDENT @Upper_Case ;
                           Context All But %IDENTIFIER, KEYWORD,
                                %INTEGER_NUMBER ;
        %PREDICATE_NAME = "&" IDENT @Upper_Case ;
                           Context All But %IDENTIFIER ;
        %STRING_LITERAL = QUOTE
                            {
                             ^"\"\n" |
                             -"\\"&True
                                  (-EOL&True |
                                   -"n"&True @Put (EOL) |
                                   -"b"&True @Put (BS) |
                                   -"t"&True @Put (HT) |
                                   -"v"&True @Put (VT) |
                                   -"f"&True @Put (FF) |
                                   -"r"&True @Put (CR) |
                                   @Mark OCTAL&True
                                        [OCTAL&True [OCTAL&True]]
                                        @2 |
                                   ANY)
                            }+
                          QUOTE ;
                           Context All But %STRING_LITERAL ;
        %OCTAL_CODE     = "#" {OCTAL}+ ;
        %GENERIC_NAME   = "%" IDENT @Upper_Case ;
        %INTEGER_NUMBER = {DIGIT}+ ;
        %PREDICATE_NO   = "&" NUMBER_NORMAL_FORM ;
        %ACTION_NO      = "@" NUMBER_NORMAL_FORM ;
        KEYWORD         = {DARK_LET}+ @Upper_Case ;
                           Context All But %IDENTIFIER, KEYWORD ;
        ACTION_KEYWORD  = BOLD_COMMERCIAL_AT BOLD_WORD @Upper_Case ;
                           Context All But %IDENTIFIER ;
        PREDICATE_KEYWORD
                        = DARK_AMPERSAND DARK_WORD @Upper_Case ;
                           Context All But %IDENTIFIER ;
        "-"             = -"-" ;
                           Priority Shift>Reduce ;


Synonyms

        "EOF"           = "END_OF_FILE" ;

-- @1 : Is_The_Same_Letter
-- @2 : \nnn => char
\end{verbatim}
}

\section{Actions lexicales}
	\label{annexe:lecl_sact.c}

Ceci est le codage en langage~C des actions (il n'y a pas de
pre'dicat) associe'es a` la description lexicale de {\LECL}.

{\small
\begin{verbatim}
#include "sxunix.h"

VOID    lecl_scan_act (entry, act_no)
    int         entry, act_no;
{
    switch (entry) {
    case OPEN:
    case CLOSE:
    case INIT:
    case FINAL:
        return;

    case ACTION:
        switch (act_no) {
        case 1:
            /* Dark Letter Check */
            if (sxsrcmngr.current_char
                 !=
                 sxsvar.lv_s.token_string [sxsvar.lv.ts_lgth - 1])
                sxput_error
                     (sxsrcmngr.source_coord,
                      "%s\
A dark symbol must be built up with the same character.",
                      sxsvar.sxtables->err_titles [1] /* Warning */ );

            return;

        case 2:
            /* \nnn => char */
            {
                register int    val;
                register char   c, *s, *t;

                t = s = sxsvar.lv_s.token_string + sxsvar.lv.mark.index;

                for (val = *s++ - '0'; (c = *s++) != NUL; ) {
                    val = (val << 3) + c - '0';
                }

                *t = val;
                sxsvar.lv.ts_lgth = sxsvar.lv.mark.index + 1;
                sxsvar.lv.mark.index = -1;
            }

            return;

        default:
            break;
        }

    default:
        fputs ("The function \"lecl_scan_act\" is out of date \
with respect to its specification.\n", sxstderr);
        abort ();
    }
}
\end{verbatim}
}


\section{Pre'dicats syntaxiques}
	\label{annexe:lecl_pact.c}

Ceci est le codage en langage~C des pre'dicats syntaxiques (il n'y a
pas d'action) associe's a` la description syntaxique de {\LECL}.

{\small
\begin{verbatim}
#include "sxunix.h"

static int	NOT_code, KEYWORD_code;

int	lecl_pars_act (entry, action_no)
    int		entry, action_no;
{
    switch (entry) {
    case OPEN:
    case CLOSE:
    case FINAL:
	return;

    case INIT:
	/* The keywords "NOT" and "KEYWORD" are not reserved. */
	NOT_code = sxstrsave ("NOT");
	KEYWORD_code = sxstrsave ("KEYWORD");
	return;

    case PREDICATE:
	switch (action_no) {
	case 1:
	    return sxget_token (sxplocals.ptok_no)->string_table_entry
                == NOT_code && sxget_token (sxplocals.ptok_no +
                1)->string_table_entry == KEYWORD_code;

	default:
	    break;
	}

	break;

    default:
	break;
    }

    fputs ("The function \"lecl_pars_act\" is out of date \
with respect to its specification.\n", sxstderr);
    abort ();
}
\end{verbatim}
}


\chapter{Exemples lie's a` la se'mantique}
	\label{annexe:ex-semantique}

\section{Le programme d'actions se'mantiques}
	\label{annexe:_act.c}

On trouvera ci-dessous la structure que doit respecter le programme
utilisateur codant les actions se'mantiques.

{\small
\begin{verbatim}
#include "sxunix.h"

static  action (action_no)
    int         action_no;
{
    switch (action_no) {
    case 0:
        break;

    case 1:
        ...
        break;

    case 2:
        ...
        break;
    .
    .
    .
    default:
        /* Message d'erreur */
    }
}


L_action (entry, arg)
    int         entry;
    struct sxtables     *arg;
{
    switch (entry) {
    case OPEN:  /* appele avant l'analyse des textes source. On prepare
                   les donnees ne dependant que du langage source et
                   non des textes source */
        ...
        break;

    case INIT:  /* appele avant l'analyse d'un texte */
        ...
        break;

    case ACTION:/* appele a chaque reduction syntaxique */
        action (arg); /* arg == action_no !!!! */
        break;

    case ERROR: /* appele en cas d'erreur de syntaxe non corrigible */
        ...
        break;

    case FINAL: /* appele apres l'analyse syntaxique d'un texte */
        ...
        break;

    case SEMPASS: /* appele apres l'analyse syntaxique d'un texte*/
        ...
        break;

    case CLOSE: /* appele apres l'analyse de tous les textes source */
        ...
        break;

    default:
        /* Message d'erreur */
    }
}
\end{verbatim}
}

\section{Trame de passes se'mantiques}
	\label{annexe:bnf_at.c}

Ceci est la trame de passe se'mantique produite par {\SEMAT} a` partir
de la spe'cification d'arbre abstrait de
l'annexe~\ref{annexe:bnf.bnf}.

{\small
\begin{verbatim}
/* *******************************************************
   *  This program has been generated from bnf.at        *
   *  on Mon Apr 11 15:44:23 1988                        *
   *  by the SYNTAX (*) abstract tree constructor SEMAT  *
   *******************************************************
   *  (*) SYNTAX is a trademark of INRIA.                *
   ******************************************************* */



/*   I N C L U D E S   */
#define NODE struct bnf_node
#include "sxunix.h"

struct bnf_node {
    SXNODE_HEADER_S VOID_NAME;

/*
your attribute declarations...
*/
};

/*
N O D E   N A M E S
*/
#define ERROR_n 1
#define ACTION_n 2
#define BNF_n 3
#define GENERIC_TERMINAL_n 4
#define LHS_NON_TERMINAL_n 5
#define NON_TERMINAL_n 6
#define PREDICATE_n 7
#define RULE_S_n 8
#define TERMINAL_n 9
#define VOCABULARY_S_n 10
#define X_NON_TERMINAL_n 11
#define X_TERMINAL_n 12
/*
E N D   N O D E   N A M E S
*/


static bnf_pi () {

/*
I N H E R I T E D
*/

switch (VISITED->father->name) {
case ERROR_n :
break;

case BNF_n :/* VISITED->name = RULE_S_n */
break;

case RULE_S_n :/* VISITED->name = VOCABULARY_S_n */
break;

case VOCABULARY_S_n :/* VISITED->name = {ACTION_n, GENERIC_TERMINAL_n,
                        LHS_NON_TERMINAL_n, NON_TERMINAL_n,
                        TERMINAL_n, X_NON_TERMINAL_n, X_TERMINAL_n} */
break;

case X_NON_TERMINAL_n :
        switch (VISITED->position) {
        case 1 :/* VISITED->name = NON_TERMINAL_n */
        break;

        case 2 :/* VISITED->name = PREDICATE_n */
        break;
        }
break;

case X_TERMINAL_n :
        switch (VISITED->position) {
        case 1 :/* VISITED->name = {GENERIC_TERMINAL_n, TERMINAL_n} */
        break;

        case 2 :/* VISITED->name = PREDICATE_n */
        break;
        }
break;

/*
Z Z Z Z
*/
}
/* end bnf_pi */
}

static bnf_pd () {

/*
D E R I V E D
*/

switch (VISITED->name) {
case ERROR_n :
break;

case ACTION_n :
break;

case BNF_n :
break;

case GENERIC_TERMINAL_n :
break;

case LHS_NON_TERMINAL_n :
break;

case NON_TERMINAL_n :
break;

case PREDICATE_n :
break;

case RULE_S_n :
break;

case TERMINAL_n :
break;

case VOCABULARY_S_n :
break;

case X_NON_TERMINAL_n :
break;

case X_TERMINAL_n :
break;

/*
Z Z Z Z
*/
}
/* end bnf_pd */
}

static smpopen (sxtables_ptr)
struct sxtables *sxtables_ptr;
{
sxatcvar.atc_lv.node_size = sizeof (struct bnf_node);
}

static smppass ()
{

/*   I N I T I A L I S A T I O N S   */
/* ........... */

/*   A T T R I B U T E S    E V A L U A T I O N   */
sxsmp (sxatcvar.atc_lv.abstract_tree_root, bnf_pi, bnf_pd);

/*   F I N A L I S A T I O N S   */
/* ........... */

}

bnf_smp (what, sxtables_ptr)int what;
struct sxtables *sxtables_ptr;
{
switch (what) {
case OPEN:
smpopen (sxtables_ptr);
break;
case ACTION:
smppass ();
break;
}
}
\end{verbatim}
}


\chapter[Le fichier {\tt standard.recor}]
	{Le fichier {\rm standard.recor}}
	\label{annexe:standard.recor}

{\small
\begin{verbatim}
Titles
    "",
    "Warning:\t",
    "Error:\t";

Scanner
    Local
        1 2 3 4       ; "The invalid character \"" $0
                        "\" is deleted.";
        X 1 2 3 4     ; "The invalid character \"" $0
                        "\" is replaced by \"" %0 "\".";
        X 0 1 2 3     ; "The character \"" %0
                        "\" is inserted before \"" $0 "\".";

        Dont_Delete = {};
        Dont_Insert = {};

    Global
        Detection     : "\"%s\" is deleted.";
             -- parameter: character in error
        Keyword       : "This unknown keyword is erased.";
        Eol           : "End Of Line";
        Eof           : "End Of File";
        Halt          : "Scanning stops on End Of File.";

Parser
    Local
        0 S 2         ; "Misspelling of \"" $1
                        "\" which is replaced by the keyword \""
                        %1 "\".";
        S 1           ; "Misspelling of \"" $0 "\" before \"" $1
                        "\" which is replaced by the keyword \""
                        %0 "\".";
        0 X 1 2 3     ; "\"" %1 "\" is inserted before \"" $1 "\".";
        0 X 2 3 4     ; "\"" $1 "\" is replaced by \"" %1 "\".";
        0 2 3 4       ; "\"" $1 "\" is deleted.";
        0 X X 1 2 3 4 ; "\"" %1 " " %2 "\" is inserted before \"" $1
                        "\".";
        X 0 1 2 3     ; "\"" %0 "\" is inserted before \"" $0 " " $1
                        "\".";
        X 1 2 3 4     ; "\"" $0 "\" before \"" $1
                        "\" is replaced by \"" %0 "\".";
        1 2 3 4       ; "\"" $0 "\" before \"" $1 "\" is deleted.";
        X 2 3 4       ; "\"" $0 " " $1 "\" is replaced by \"" %0 "\".";
        X X 1 2 3     ; "\"" $0 "\" before \"" $1
                        "\" is replaced by \"" %0 " " %1 "\".";

        Dont_Delete = {};
        Dont_Insert = {};

    Forced_Insertion
        "\"" %0 "\" is forced before \"" $1 "\"." ;

    Global
        Key_Terminals = {};
        Validation_Length = 2;
        Followers_Number <= 5
                      : "\"%s\"^(, \"%s\"^) is expected";
             -- parameters: array (1:Followers_Number) of valid
             --             followers at detection point
        Detection     : "Global recovery.";
             -- parameters: none
        Restarting    : "Parsing resumes on \"%s\"";
             -- parameters: array (1:Validation_Length) of valid
             --             followers at restarting point
        Halt          : "Parsing stops on End Of File.";
             -- parameters: none

Abstract
    "%d errors and %d warnings are reported.";
         -- parameters: array (1:Titles_No) of number of messages
\end{verbatim}
}

\chapter{Exemples de grammaires non-LALR(1)}
	\label{annexe:ex-non-lalr(1)}

\section{Une grammaire ambigu"e}
	\label{annexe:ambig.bnf}

On trouvera ci-dessous une grammaire ambigu"e illustrant le proble`me
du ``dangling else'' et les messages de non conformite' e'mis par
{\CSYNT} dans le cas standard (avec les options par de'faut) et dans
le cas ou l'option \verb|-path| est positionne'e.

\subsection{Grammaire}

{\small\tt
 \begin{tabbing}
{*} <Then\_Part>	\==\ if cond <Then\_Part> <Else\_Part>	\=;	\kill
<Stmt>		\>= <If\_Stmt> 				\>;	\\
<Stmt>		\>=  					\>;	\\[5pt]
<If\_Stmt>	\>= if cond <Then\_Part> <Else\_Part> 	\>;	\\[5pt]
<Then\_Part>	\>= then <Stmt> 			\>;	\\[5pt]
<Else\_Part>	\>= 					\>;	\\
<Else\_Part>	\>= else <Stmt> 			\>;
 \end{tabbing}
}

\subsection{Listage des conflits}

\subsubsection{option par de'faut}
	\label{annexe:ambig.conf}

{\small
\begin{verbatim}

    N O T    L A L R (1)
Shift-Reduce conflict in state 6 on "else" between:
        - Shift:
            6: <Else_Part> = . "else" <Stmt>
        - Reduce:
            5: <Else_Part> = .
                derived from:
                    3: <If_Stmt> = "if" "cond" . <Then_Part> <Else_Part>

Using the system disambiguating rules, priority is given to shift.

\end{verbatim}
}

\subsubsection{Option {\tt -path}}
	\label{annexe:ambig.path}

{\small
\begin{verbatim}
SAMPLE PATH from state 1 to 6

"if" "cond" <Then_Part> 


    N O T    L R (1)
Shift-Reduce conflict in state 6 on "else" between:
        - Shift:
            6: <Else_Part> = . "else" <Stmt>
                derivation:
                    <Stmt>
                        =>* "if" "cond" <Then_Part> <Else_Part> ...
                        =>* "if" "cond" <Then_Part> "else" <Stmt> ...
                        =>* "if" "cond" <Then_Part> "else" ....
        - Reduce:
            5: <Else_Part> = .
                derived from:
                    3: <If_Stmt> = "if" "cond" . <Then_Part> <Else_Part>
                       by:
                    <Stmt>
                        =>* <If_Stmt> ...
                        =>* "if" "cond" <Then_Part> <Else_Part> ...
                        =>* "if" "cond" <Then_Part> "else" ....
                        =>* "if" "cond" "then" <Stmt> "else" ....
                        =>* "if" "cond" "then" <If_Stmt> "else" ....
                        =>* "if" "cond" "then" "if" "cond" <Then_Part>
                            <Else_Part> "else" ....
                        =>* "if" "cond" "then" "if" "cond" <Then_Part>
                            "else" ....

    The grammar is AMBIGUOUS

First derivation:
<Stmt>
   =>* <If_Stmt> ...
   =>* "if" "cond" <Then_Part> <Else_Part> ...
   =>* "if" "cond" <Then_Part> "else" ....
   =>* "if" "cond" "then" <Stmt> "else" ....
   =>* "if" "cond" "then" <If_Stmt> "else" ....
   =>* "if" "cond" "then" "if" "cond" <Then_Part> <Else_Part> "else" ....
   =>* "if" "cond" "then" "if" "cond" <Then_Part> "else" ....

Second derivation:
<Stmt>
   =>* <If_Stmt> ...
   =>* "if" "cond" <Then_Part> <Else_Part> ...
   =>* "if" "cond" <Then_Part> ...
   =>* "if" "cond" "then" <Stmt> ...
   =>* "if" "cond" "then" <If_Stmt> ...
   =>* "if" "cond" "then" "if" "cond" <Then_Part> <Else_Part> ...
   =>* "if" "cond" "then" "if" "cond" <Then_Part> "else" ....

Using the system disambiguating rules, priority is given to shift.

\end{verbatim}
}


\section{Une grammaire non LR(1)}
	\label{annexe:nlr1.bnf}

On trouvera ci-dessous une grammaire non LR(1) et les messages de
non-conformite' e'mis par {\CSYNT} dans le cas ou l'option
\verb|-path| est positionne'e.

\subsection{Grammaire}

{\small\tt
 \begin{tabbing}
{*} <Z>	\==\ <C> <X> <T>	\=;	\kill
<Z>	\>= <A> <X> <T>	\>;	\\
<Z>	\>= <B>		\>;	\\[5pt]
<X>	\>=		\>;	\\[5pt]
<T>	\>= t		\>;	\\[5pt]
<B>	\>= a <E>	\>;	\\[5pt]
<E>	\>= <C> <X> <T>	\>;	\\[5pt]
<A>	\>= a <D> <X>	\>;	\\[5pt]
<C>	\>= <X> e	\>;	\\[5pt]
<D>	\>= <X> e	\>;
 \end{tabbing}
}

\subsection{Listage des conflits avec l'option {\tt -path}}

{\small
\begin{verbatim}
SAMPLE PATH from state 1 to 9

"a" <X> "e" 


    N O T    L A L R (1)
Reduce-Reduce conflict in state 9 on "t" between:
        - Reduce:
            8: <C> = <X> "e" .
                derived from:
                    6: <E> = . <C> <X> <T>
                       by:
                    <Z>
                        =>* "a" <E> ...
                        =>* "a" <C> <X> <T> ...
                        =>* "a" <C> "t" ....
                        =>* "a" <X> "e" "t" ....
        - Reduce:
            9: <D> = <X> "e" .
                derived from:
                    1: <Z> = . <A> <X> <T>
                       by:
                    <Z>
                        =>* <A> <X> <T> ...
                        =>* <A> "t" ....
                        =>* "a" <D> <X> "t" ....
                        =>* "a" <D> "t" ....
                        =>* "a" <X> "e" "t" ....

    The grammar is not LR (1)

First derivation:
<Z>
   =>* <A> <X> <T> ...
   =>* <A> "t" ....
   =>* "a" <D> <X> "t" ....
   =>* "a" <D> "t" ....
   =>* "a" <X> "e" "t" ....

Second derivation:
<Z>
   =>* "a" <E> ...
   =>* "a" <C> <X> <T> ...
   =>* "a" <C> "t" ....
   =>* "a" <X> "e" "t" ....

Using the system disambiguating rules, priority is given to reduction
number 8.

\end{verbatim}
}



\section{Spe'cifications d'une grammaire LALR(2)}
	\label{annexe:lalr2}


\subsection{Grammaire}

{\small\tt
 \begin{tabbing}
{*} <A, ca>	\==\ <A, ca> c a	\=;	\kill
{*} Grammaire (d'ecole) non LALR(1) mais LALR(2) du langage \\
{*} $L = \{e{}^n ca | e{}^n cb | e{}^n d | a e{}^n c | a e{}^n d \}
	\qquad n > 0$		\\
{*}					\\
<Z>	\>= <A, ca> c a	\>;	\\
<Z>	\>= <B, cb> c b	\>;	\\
<Z>	\>= <C> d	\>;	\\
<Z>	\>= a <B> c	\>;	\\
<Z>	\>= a <C> d	\>;	\\[5pt]
<A, ca>	\>= <E> \&1	\>;	\\[5pt]
<B, cb>	\>= <E>		\>;	\\[5pt]
<B>	\>= <E>		\>;	\\[5pt]
<C>	\>= <E>		\>;	\\[5pt]
<E>	\>= e		\>;	\\
<E>	\>= e <E>	\>;	\\[5pt]
{*}				\\
{*} \&1 regarde si le contexte droit contient "c" et "a"
 \end{tabbing}
}
\newpage

\subsection{Actions}

{\small
\begin{verbatim}
#include "sxunix.h"
#include "XNT_td.h" /* defines c_code to be 1 and a_code to be 2 */

int     XNT_parsact (entry, action_no)
    int         entry, action_no;
{
    switch (entry) {
    case OPEN:
    case CLOSE:
    case FINAL:
    case INIT:
        return;

    case PREDICATE:
        switch (action_no) {
        case 1:
            if (sxget_token (sxplocals.ptok_no)->lahead == c_code &&
                sxget_token (sxplocals.ptok_no + 1)->lahead == a_code)
                return TRUE;

            return FALSE;

        default:
            break;
        }

        break;

    default:
        break;
    }

    fputs ("The function \"XNT_parsact\" is out of date \
with respect to its specification.\n", sxstderr);
    abort ();
}
\end{verbatim}
}


\section{Un langage non-de'terministe}
	\label{annexe:amb2manbn}

\subsection{Grammaire}

{\small\tt
 \begin{tabbing}
{*} init	\==\ <B> <C> <B'>	\=;	\kill
{*} Langage non-deterministe		\\
{*} $L = \{a{}^m b{}^{2m}  a{}^n b{}^n |
	a{}^m b{}^m a{}^k a{}^n b{}^n \}
	\qquad m, k, n > 0$		\\
{*} Grammaire non LR (k) ni RLR ni LR ($\pi$)\\[5pt]
<Z>	\>= @1 <S>		\>;	\\[5pt]
<S>	\>= <A> <B'>		\>;	\\
<S>	\>= <B> <C> <B'>	\>;	\\[5pt]
<A>	\>= a <A> b b		\>;	\\
<A>	\>= a b b		\>;	\\[5pt]
<B>	\>= a <B> b		\>;	\\
<B>	\>= a b \&1		\>;	\\[5pt]
<B'>	\>= a <B'> b		\>;	\\
<B'>	\>= a b			\>;	\\[5pt]
<C>	\>= @2 a \&2 <C>	\>;	\\
<C>	\>= @2 a 		\>;	\\[5pt]
{*} init\>: a\_number = 1 et a\_s = b\_s = k = 0;		\\
{*} @1	\>: Compte les premiers a et b dans a\_s et b\_s	\\
{*}	\>\ \ Si a\_s == b\_s, compte les a et b de queue	\\
{*}	\>\ \ et calcule k = |a| - |b|				\\
{*} @2	\>: a\_number++ \\
{*}	\\
{*} \&1 \>: return a\_s == b\_s \\
{*} \&2 \>: return a\_number < k
 \end{tabbing}
}

\subsection{Actions}

{\small
\begin{verbatim}
#include "sxunix.h"
#include "NDL_td.h" /* defines a_code to be 1 and b_code 2 */

static int      a_s, b_s, a_number, k;

int     NDL_parsact (entry, action_no)
    int         entry, action_no;
{
    switch (entry) {
    case OPEN:
    case CLOSE:
    case FINAL:
        return;

    case INIT:
        a_number = 1;
        a_s = b_s = k = 0;
        return;

    case PREDICATE:
        switch (action_no) {
        case 1:
            return a_s == b_s;

        case 2:
            return a_number < k;
        }

        break;

    case ACTION:
        switch (action_no) {
        case 1: {
                register int i = sxplocals.atok_no, lahead;

#define GET_LAHEAD()  \
(lahead = sxget_token (i++)->lahead)

                while (GET_LAHEAD () == a_code)
                    a_s++;

                for (; lahead == b_code; GET_LAHEAD ())
                    b_s++;

                if (a_s == b_s) {
                    for (; lahead == a_code; GET_LAHEAD ())
                        k++;

                    for (; lahead == b_code; GET_LAHEAD ())
                        k--;
                }
            }

            return;

        case 2:
            a_number++;
            return;
        }
    }

    fputs ("The function \"NDL_act\" is out of date.\n", sxstderr);
    abort ();
}
\end{verbatim}
}


\chapter{Exemples de de'finitions lexicales}
	\label{annexe:ex-lecl}

\section{De'finition lexicale de PASCAL}
	\label{annexe:pascal.lecl}

\begin{center}
{\small\tt
 \begin{tabbing}
 \ \ \ \ \=\verb|%IDENTIFIER| \== \= -(\=			\kill
 Tokens								\\
 \> Comments \> = \>  -(\verb/{SP|HT|EOL}+ |/			\\
 \>\>\>\>		\verb/"(" "*" {ANY} "*" ")"&True |/	\\
 \>\>\>\>		\verb/"{" {^"}"} "}") ;/		\\
 \> \%IDENTIFIER \>=\>\verb/LETTER {LETTER | DIGIT} @UPPER_CASE ;/ \\
 \>\>\>		      \verb/Context All But %IDENTIFIER, %NATUREL, %REEL ;/ \\
 \> \%NATUREL \> = \> \verb/{DIGIT}+ ;/				\\
 \>\>\>		      \verb/Priority Reduce > Reduce ;/		\\
 \>\>\>		      \verb/Unbounded Context All But %IDENTIFIER ;/	\\
 \> \%REEL \> = \>    \verb/{DIGIT}+ ["." {DIGIT}+] [E ["+" | "-"] {DIGIT}+] ;/ \\
 \>\>\>		      \verb/Context All But %IDENTIFIER ;/	\\
 \> \%STRING \> = \>  \verb/-"'" {^"'" | -"'" "'"}+ -"'" ;/	\\
 \> "<>" \> = \>      \verb/-("<" ">" | "#") ;/			\\
 \> "[" \> = \>	      \verb/-("[" | "(" ".") ;/			\\
 \> "]" \> = \>	      \verb/-("]" | "." ")") ;/			\\
 \> "@" \> = \>	      \verb/-"@^" ;/
 \end{tabbing}
}
\end{center}


\section{De'finition lexicale d'un langage a` commentaires imbrique's}
	\label{annexe:olga-comments-2}

Cette section pre'sente une alternative a` la description des
commentaires du langage OLGA pre'sente'e en
figure~\ref{fig:olga-comments}.

\subsection{Expressions re'gulie`res}

Dans la description du langage principal (de niveau ze'ro)
\verb|llev.lecl|, on se contente de de'tecter le de'but d'un
commentaire (ici~``\verb|{|'') et on appelle l'action
utilisateur~\verb|@0|\,:
\begin{quote}
\begin{verbatim}
Comments        = @0 "{" ;
\end{verbatim}
\end{quote}

Cette action appelle l'analyseur lexical du langage \verb|hlev| qui se
charge de la reconnaissance d'un niveau de commentaire.  A` un niveau
quelconque, la reconnaissance d'une accolade ouvrante~(``\verb|{|'')
induit l'appel du niveau suivant par l'interme'diaire de
l'action~\verb|@1| (essentiellement identique a` l'action~\verb|@0|)
alors que la reconnaissance d'une accolade fermante~(``\verb|}|''),
vue par le niveau courant comme une fin de fichier, entrai^ne le
retour au niveau pre'ce'dent\,:
\begin{quote}
\begin{verbatim}
Comments        = "{" { ^"{}" | @1 "{" } ;
Eof             = "}" ;
\end{verbatim}
\end{quote}

\subsection{Actions lexicales}

{\small
\begin{verbatim}
#include "sxunix.h"

extern struct sxtables	hlev_tables;

/* Structures used to store the local variables of a given scanner */
static struct sxsvar	llev_svar, hlev_svar;


llev_sact (entry, action_no)
    int         entry;
    int         action_no;
{
    switch (entry) {
    case OPEN:
    case CLOSE:
        llev_svar = sxsvar;
        sxsvar = hlev_svar;
        (*(llev_svar.sxtables->analyzers.scanner)) (entry, &hlev_tables);
        hlev_svar = sxsvar;
        sxsvar = llev_svar;
        return;

    case INIT:
    case FINAL:
        return;

    case ACTION:
        switch (action_no) {
            struct sxsource_coord       source_coord;

        case 0 /* Call From Level 0 (llev scanner) */ :
            /* Swap of the scanner local variables sxsvar */
            llev_svar = sxsvar;
            sxsvar = hlev_svar;
            source_coord = sxsrcmngr.source_coord;
            (*(sxplocals.SXP_tables.scanit)) (); /* Quick Scanner Call */
            hlev_svar = sxsvar;
            sxsvar = llev_svar;

            if (sxsrcmngr.current_char != '}')
                sxput_error (source_coord, "%sComment not closed.",
                             sxsvar.sxtables->err_titles [2]);

            return;

        case 1 /* Call From Level Greater Than 0 (hlev scanner) */ :
            /* sxsvar is already correct */
            source_coord = sxsrcmngr.source_coord;
            (*(sxplocals.SXP_tables.scanit)) (); /* Quick Scanner Call */

            if (sxsrcmngr.current_char != '}')
                sxput_error (source_coord, "%sSub-Comment not closed.",
                             sxsvar.sxtables->err_titles [2]);

            return;
        }

    default:
        fputs ("The function \"llev_sact\" is out of date \
with respect to its specification.\n", sxstderr);
        abort ();
    }
}
\end{verbatim}
}

On trouvera ci-dessous le re'sultat de l'exe'cution d'un petit texte
source errone'.
{\small
\begin{tabbing}
\verb|            |\=\verb|{1{2}{2}|\=\verb|{2{3}2|			\\[-3pt]
		\>		\> \ua					\\[-3pt]
\verb|text1.llev, line 1: column 9: Error:    Sub-Comment not closed.|	\\[5pt]
\verb|            {1{2}{2}{2{3}2|					\\[-3pt]
		\> \ua							\\[-3pt]
\verb|text1.llev, line 1: column 1: Error:    Comment not closed.|
\end{tabbing}
}


\section{Actions lexicales re'alisant une inclusion}
	\label{annexe:include-actions}

{\small
\begin{verbatim}
#include "sxunix.h"

VOID    your_scan_act (entry, act_no)
    int         entry, act_no;
{
    switch (entry) {
    case OPEN:
    case CLOSE:
    case INIT:
    case FINAL:
        sxincl_mngr (entry);
        return;

    case ACTION:
        switch (act_no) {
        /* The pathname of the include file is in token_string */
        int ste = sxstrsave (sxsvar.sxlv_s.token_string);
        /* it is saved (permanently) in the string_manager */
        char *path = sxstrget (ste);
        /* and get back. */

        case 1:
            if (sxpush_incl (path))
                /* The source text now comes from the include file */
                return;

            /* something failed (unable to open, recursive call, ...) */
            /* error message: */
            sxput_error (
                 sxsvar.sxlv.terminal_token.source_index
                      /* source coordinates of the include command */,
                 "%sUnable to process the include file \"%s\".",
                 sxsvar.sxtables->err_titles [2]
                      /* severity level: error */,
                 path /* include file name */
                 );
            /* however scanning of the current file is going on: */
            return;

        case 2:
            /* End of include processing */
            if (sxpop_incl ())
                return;

            /* something really wrong */
            /* error message */
            fputs ("Sorry, the include processing garbled, \
nevertheless hope to see you again soon.\n", sxstderr);
            abort () /* panic */ ;
        }

    default:
        fputs ("The function \"your_scan_act\" is out of date \
with respect to its specification.\n", sxstderr);
        abort ();
    }
}
\end{verbatim}
}


\end{document}
%
% Local Variables:
% version-control: yes
% End:
