Notes spécifiques à Vasy pour l'utilisation de Syntax.

Auteur : Romain Lacroix (romain.lacroix@inrialpes.fr)

Date dernière modification : 10 Juillet 2007


I) Récuperer le code source de Syntax :

Il existe une page web pour le projet Syntax sur la forge de l'Inria ici :
	http://gforge.inria.fr/projects/syntax/

On peut y récuperer des archives de différentes releases (dans l'onglet 'Files'). Le jour de la rédaction de cette documentation (04/07/2007), il existe les
releases suivantes: 
  - syntax 6.0b
  - syntax 6.0b2
  - syntax-core 6.0b
  - syntax-core 6.0b2

Le package syntax-core est le plus petit sous-ensemble de syntax comprenant la librairie et ce qu'il faut pour compiler la chaîne de pré-traitement SxPipe, qui est également disponible sur la forge inria (au sein du projet ATOLL linguistic workbench, de nom unix 'lingwb').

On peut aussi récuperer la dernière version avec le gestionnaire de versions Subversion, de manière anonyme :
  'svn  checkout svn://scm.gforge.inria.fr/svn/syntax'


II) Différentes manières de compiler :

Il existe 2 manières de générer les makefiles, puis de compiler Syntax :

  - en utilisant le makefile 'supermake' (ou bien le makefile 'vasymake', qui appelle des cibles de 'supermake')

  - en utilisant les autotools

Vasy a choisi d'utiliser la méthode 'supermake'. Nous pensons que les 2 méthodes sont équivalentes.


III) Compiler avec autotools :

 Voici comment on peut utiliser les autotools pour générer les makefiles de Syntax, puis le compiler :

  - récupérer Syntax avec un checkout subversion
  - cd /le-dossier-où-on-a-recuperé-le-checkout/syntax/trunk
  - aclocal
  - autoconf
  - automake (avec l'option '-af' si c'est la première fois qu'on le fait)

A ce stade, on est dans l'état auquel on arrive après avoir extrait l'archive tgz que l'on peut récupérer ici : http://gforge.inria.fr/frs/?group_id=419 )

  - ./configure  (on peut rajouter des options comme --prefix=... )
  - make
  - make check : cette étape facultative doit vérifier que la compilation s'est
    bien passée. Pour cela, le processus d'autogenèse est lancé 2 fois.
  - make install (éventuellement en changeant d'utilisateur selon le prefix
    d'installation)


IV) Prérequis pour la compilation avec les makefiles 'supermake', 'hypergenese' et 'vasymake' :

Il faut commencer par positionner 2 variables dans le shell qui lancera la compilation :

  IV.1) La variable 'sx' doit pointer sur le dossier contenant le code
	source de syntax. Après l'opération 'svn checkout' dans le dossier
	checkout-dir, la variable 'sx' doit pointer sur
	checkout-dir/syntax/trunk (en chemin absolu)

  IV.2) La variable 'sxV' doit avoir comme valeur le numéro de version de
	Syntax.	Le jour de la rédaction de cette documentation (04/07/2007),
	c'est '6.0'


V) Compilation locale (non-croisée) :

  fichier makefile :			'supermake'
  cible de nettoyage :			'nickel'
  cible de génération des makefiles :	'makefiles'
  cible de compilation :		'runthem'
  cible de génération puis compilation : 'chrome'

  commande à appeler pour nettoyer puis générer les makefiles puis compiler :
	'make -f supermake nickel chrome'


VI) Compilation (éventuellement croisée) et autogenèse pour différentes architectures

  VI.1) Compilation et autogenèse avec le fichier 'vasymake' (méthode de Vasy)

  On peut utiliser le makefile 'vasymake' qui s'occupe de positionner les
variables nécessaires à la cross-compilation et l'autogenèse.

Les différentes cibles qui existent, et les architectures matérielles et
logicielles correspondantes sont :

    VI.1.1) Compilation normale (avec le compilateur le mieux adapté à l'architecture) :

  - vasy-iX86 (ix86, linux, compileur gcc)
  - vasy-sun5 (Sparc 32-bit, Solaris 10, compileur suncc)
  - vasy-win32 (ix86, windows)
  - vasy-macOS (PPC, macOS 10.4)
  - vasy-mac86 (ix86, macOS 10.4)
  - vasy-sun64 (Sparc 64-bit, Solaris 10, compileur suncc)
  - vasy-x64 (x86_64, linux, compilateur gcc)
  - vasy-ia64 (Itanium 64, linux, compilateur gcc)

    VI.1.2) Autogenèse normale

  - bootstrap-sun5 (Sparc 32-bit, Solaris 10, compileur suncc)
  - bootstrap-sun64 (Sparc 64-bit, Solaris 10, compileur suncc)
  - bootstrap-iX86 (ix86, linux, compileur gcc)
  - bootstrap-x64  (x86_64, linux, compilateur gcc)

    VI.1.3) Compilation et autogenèse avec des compilateurs alternatifs :

  - vasy-sun5-gcc (Sparc 32-bit, Solaris 10, compilateur gcc)
  - vasy-sun64-gcc (Sparc 64-bit, Solaris 10, compilateur gcc)
  - vasy-iX86-icc (ix86, linux, compilateur intelcc)
  - bootstrap-sun5-gcc (Sparc 32-bit, Solaris 10, compilateur gcc)
  - bootstrap-sun64-gcc (Sparc 64-bit, Solaris 10, compilateur gcc)
  - bootstrap-iX86-icc (ix86, linux, compilateur intelcc)

    VI.1.4) Plusieurs compilations ou autogenèses à la suite

  - all32 : compilation pour les 5 architectures 32-bits supportées par Vasy 
  - all64 : compilation pour les 3 architectures 64-bits supportées par Vasy
  - all-compiles: toutes les compilations possibles (il y en a 11)
  - all-debug: appelle la cible all-compiles en activant successivement
               les flags de preprocessing (attention: opération longue)
  - bootstrap: toutes les autogenèses possibles
  - all: toutes les autogenèses, puis toutes les compilations pour les
         architectures qui n'ont pas d'autogenèse

Le code de Syntax a été mis à jour pour supporter toutes les architectures citées ci-dessus. Pour compiler pour une de ces architectures, on peut utiliser la commande suivante :
	'make -f vasy/vasymake vasy-$ARCH'

Cette commande crée les dossiers $sx/bin.$ARCH et $sx/lib.$ARCH, qui seront peuplés avec les résultats de la compilation. Les dossiers $sx/bin et $sx/lib ne contiendront PAS les fichiers produits par la compilation.

Pour lancer l'autogenèse de l'architecture 'ARCH', on utilise la commande suivante :
         `make -f vasy/vasymake bootstrap-$ARCH'

  VI.2) Compilation avec le fichier supermake (méthode originale de Atoll)

  On peut choisir quels programmes seront appelés par les makefiles, et ainsi lancer une compilation croisée, avec la commande suivante :

	make -f supermake COMPILER=$ARCH-gcc RANLIB=$ARCH-ranlib AR=$ARCH-ar

Nous n'utilisons pas le nom de variable 'CC' pour choisir le compilateur, car cet identifiant est déjà utilisé par Atoll dans les makefiles. Nous avons donc choisi d'utiliser l'identifiant 'COMPILER' .

En compilant avec le fichier supermake, les dossiers $sx/bin et $sx/lib seront peuplés avec les résultats de la compilation. Le script suivant :
  '$sx/etc/bin/vasy-prepare-directories.sh'
peut faire en sorte que ces dossiers bin/ et lib/ soient des liens vers bin.$ARCH et lib.$ARCH. Il faut l'appeler en lui donnant comme argument un nom d'architecture.

 ex : $sx/etc/bin/vasy-prepare-directories.sh sun5

Après cette commande, le listing des dossiers donne ce résultat : 

      ls -ld bin* lib*
lrwxrwxrwx 1 rlacroix rlacroix    8 Jul 10 14:46 bin -> bin.sun5
drwxr-x--- 2 rlacroix rlacroix 1024 Jul 10 14:46 bin.sun5
lrwxrwxrwx 1 rlacroix rlacroix    8 Jul 10 14:46 lib -> lib.sun5
drwxr-x--- 2 rlacroix rlacroix  512 Jul 10 14:46 lib.sun5


Pour restaurer les dossiers bin et lib à leur état initial (des dossiers gérés par subversion), on peut appeler le script vasy-prepare-directories.sh avec l'argument spécial 'restore' :

 ex : $sx/etc/bin/vasy-prepare-directories.sh restore

  VI.3) Autogenèse avec le fichier hypergenese (méthode originale de Atoll)

Le makefile $sx/hypergenese peut accomplir la tâche suivante :
  (citation des auteurs originaux du logiciel) 

  "On utilise les constructeurs syntax, compilés à partir de programmes sources et de tables, pour générer de nouvelles versions des tables"

Ce processus se lance de cette manière :
  'make -f hypergenese nickel chrome'

Note 1 : Il faut pouvoir éxécuter les outils de syntax, donc être dans un environnement natif pour lancer ce processus d'autogenèse.

Note 2 : l'éxécution de ce processus d'autogenèse est un bon test pour vérifier que tous les outils Syntax fonctionnent comme prévu dans les spécifications.

 Le test complet constitue à :
   - compiler une première fois les outils (avec supermake ou autotools)
   - rajouter ces nouveaux outils dans le path
   - lancer le bootstrap, qui appelera ces outils pour générer du code
   - compiler le code nouvellement généré pour reproduire les outils
   - lancer un nouveau bootstrap (qui appelle la nouvelle version des outils)

Note 3 : Il faut bien penser à rajouter le dossier qui contient les outils Syntax dans le path avant de lancer l'autogenèse. Il s'agit du dossier $sx/bin.$ARCH si on a utilisé le makefile vasymake, ou bien du dossier $sx/bin si on a utilisé le makefile supermake .


VII) Liste des fichiers générés par le processus d'autogenèse
	     
     1  DAG/src/dag_mix.c
     2  DAG/src/dag_t.c
     3  DAG/src/udag_t.c
     4  bnf/src/bnf_dst.c
     5  bnf/src/bnf_mix.c
     6  bnf/src/bnf_t.c
     7  bnf/src/make_proper_t.c
     8  dico/src/dico_t.c
     9  incl/dag_t.h
    10  incl/udag_t.h
    11  lecl/incl/lecl_td.h
    12  lecl/src/lecl_mix.c
    13  lecl/src/lecl_t.c
    14  lecl/src/pplecl_t.c
    15  lfg/src/lfg_lex_mix.c
    16  lfg/src/lfg_lex_t.c
    17  lfg/src/lfg_mix.c
    18  lfg/src/lfg_t.c
    19  paradis/src/paradis_mix.c
    20  paradis/src/paradis_t.c
    21  prio/src/prio_t.c
    22  rcg/incl/rcg_td.h
    23  rcg/src/drcg_mix.c
    24  rcg/src/drcg_t.c
    25  rcg/src/rcg_mix.c
    26  rcg/src/rcg_t.c
    27  recor/src/pprecor_t.c
    28  recor/src/recor_mix.c
    29  recor/src/recor_t.c
    30  semact/src/semact_t.c
    31  semat/src/semat_t.c
    32  tabc/src/dec.c
    33  tabc/src/dec_t.c
    34  tabc/src/def.c
    35  tabc/src/def_t.c
    36  tdef/src/pptdef_t.c
    37  tdef/src/tdef_t.c
    38  xbnf/src/xbnf_mix.c
    39  xbnf/src/xbnf_t.c
    40  yax/src/dec_t.c
    41  yax/src/def_t.c
    42  ysx/src/yaction_t.c
    43  ysx/src/ysx_mix.c
    44  ysx/src/ysx_t.c




VIII) Différences d'implémentation entre les architectures :

Pour la fonction suivante, l'implémentation varie selon les architectures :

  VIII.1) sxcaught_virtual_timeout()

Cette fonction, qui se trouve dans le fichier $sx/src/sxtm_mngr.c, n'a pas pu être implementée de manière identique pour l'architecture win32. Nous n'avons pas trouvé d'équivalence au 'virtual timer' disponible pour les Unix. Nous avons choisi de l'implémenter en utilisant un timer classique (qui compte le temps utilisateur et pas le temps utilisé par le processus), et d'attendre deux fois plus longtemps que la durée passée en paramètre, pour avoir un comportement assez proche des implémentations sous Unix.

