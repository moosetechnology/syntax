
\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[french]{babel}

\newcommand\SYNTAX{\mbox{\sc Syntax}}
\newcommand\BNF{\mbox{\sc Bnf}}
\newcommand\SEMC{\mbox{\sc Semc}}
\newcommand\TABC{\mbox{\sc Tabc}}

\hyphenation{
cha-pi-tre cons-truc-tion cor-res-pon-dan-te impri-mables la-quel-le
lexi-co-gra-phi-ques per-met-tent prin-ci-pa-le-ment sui-vant
syn-ta-xi-que}

\title{
  {\huge S}EMC   \\[10pt]
  PRÉSENTATION SUCCINCTE
}

\author{
		Pascal Bouchon		\\
		3ème année ENSIMAG	\\
		Grenoble, France	\\
		~ \\
		Juin 1988
}

\date{}

\begin{document}

\sloppy

\maketitle

\section{Introduction}

   \SEMC{} est un processeur de \SYNTAX{} écrit par Bernard Lohro
   à l'INRIA Rocquencourt dans les années 1980. Ce processeur s'appelait
   alors \TABC{}~; il a été renommé en \SEMC{} au mois de mai 2023.

   La sémantique effectuée par attributs synthétisés est toujours
   décrite dans un fichier {\tt nom\_du\_langage.semc}.
   Dans ce fichier, le programmeur doit décrire les règles de
   grammaire selon la convention du module \BNF.
   Après chaque règle de grammaire, le programmeur a la possibilité
   de décrire des actions synthétisées programmées en langage C.
   Ces actions sont exécutées pendant l'analyse syntaxique à
   chaque réduction.
   
\section{Actions synthétisées}

   Les actions synthétisées suivant une règle de grammaire sont toujours 
   exécutées lorsque la partie droite de la règle a été reconnue 
   au moment de la réduction de cette règle.

%\begin{example}
    Soit la grammaire suivante :
\begin{verbatim}
    <axiome> = <liste> ;

    <liste>  = <liste> , <identificateur> ;

    <liste>  = <identificateur> ;

    <identificateur> = "ok" ;
               printf("lu");
\end{verbatim}
    Après la reconnaissance du mot "{\tt ok}", au moment de réduire la
    règle
\begin{quote}
    \mbox{\tt <identificateur> = "ok"}
\end{quote}

    \SEMC{} exécutera la 
    séquence C correspondant à l'action associée à cette règle
    c'est-à-dire {\tt printf("lu{}")}. 
%\end{example}

\section{Attributs synthétisés}

   \SEMC{} permet la gestion entièrement transparente pour le 
   programmeur d'attributs synthétisés.

   Ces attributs sont soumis à des conditions d'utilisation
   afin de permettre à \SEMC{} de vérifier la cohérence de
   leurs emplois.

   Ces attributs sont des identificateurs de variables declarés
   en langage C. Tous les identificateurs  d'attribut doivent
   être précédés du caractère ``{\tt \$}''.

   Chaque non-terminal de la grammaire qui utilise un attribut
   doit être préalablement déclaré dans la zone de déclaration
   des attributs.

   Après chaque règle de grammaire, il faut toujours déclarer
   les attributs uti\-li\-sés par le non-terminal qui constitue
   la partie gauche de la règle de grammaire.

\section{Déclaration des attributs synthétisés}

   La déclaration des attributs se décompose en deux parties
\begin{enumerate}
\item
   Avant l'utilisation des attributs, le programmeur doit
   les déclarer globalement en explicitant les non-terminaux qui les
   utilisent ainsi que le type C de l'attribut.

   Cette déclaration doit toujours précéder les règles de la grammaire.

   La grammaire syntaxique des déclarations d'attibuts est :
\begin{verbatim}
   <declaration-globale> = <declaration-attributs> "$"
\end{verbatim}

%\begin{remark}
Le signe ``{\tt \$}'' qui termine la déclaration doit
   forcément se trouver sur la première colonne d'une
   nouvelle ligne.
%\end{remark}

\begin{verbatim}
<declaration-attributs> = <declaration-attribut>

<declaration-attributs> = <declaration-attribut>
                          <declaration-attributs>

<declaration-attribut> = "$" <identificateur-C>   
                         "(" <non-terminal-lotos> 
                         {"," <non-terminal-lotos>} ")"
                         ":" <type-C> ";"
\end{verbatim}

%\begin{remark}
Le signe ``{\tt \$}'' doit toujours se trouver sur la
   première colonne d'une nouvelle ligne. {\tt <identificateur-C>} et
   {\tt <type-C>} correspondent à des identificateurs de variable et de type
   respectant la syntaxe du langage C. 
%\end{remark}

%\begin{example}
   On déclare globalement l'attribut compteur comme un entier. Cet attribut est
   associé au non-terminal {\tt <identificateur>}.
\begin{verbatim}
   $compteur(<identificateur>):int;
\end{verbatim}
%\end{example}


\item
   Après chaque règle de la grammaire syntaxique, le programmeur
   doit déclarer localement  les attributs utilisés par le non-terminal
   qui forme la partie gauche de la règle. 

   La grammaire syntaxique de cette déclaration locale est~:
\begin{verbatim}
<declaration-locale> = <declaration-attribut-ligne> 
                       {<declaration-attribut-ligne>}

<declaration-attribut-ligne> = <declaration-attribut> 
                               {"," <declaration-attribut>} 
				  
<declaration-attribut> = "$" <identificateur-C>   
                         "(" <non-terminal-lotos> ")"
\end{verbatim}

%\begin{remark}
{\tt <non-terminal-lotos>} doit toujours être le non-terminal
   de la partie gauche de la règle de la grammaire.

   De plus, à chaque ligne de déclaration locale d'attributs 
   le signe ``{\tt \$}'' du premier attribut doit être sur la première
   colonne.
%\end{remark}


%\begin{example}
   Soit la règle~: 
\begin{verbatim}
   <identificateur> = <suite-de-lettre> ;
                      $compteur(<identificateur>)
\end{verbatim}
   Cette règle déclare localement l'attribut compteur associé au
   non-terminal {\tt <identificateur>}.
%\end{example}
\end{enumerate}

\section{Description des actions synthétisées}

   Les actions synthétisées sont toujours décrites après
   chaque règle de grammaire à la suite de la
   déclaration locale d'attributs.

   La description des actions ne doit jamais commencer
   sur la première colonne de chaque ligne.

   Pour utiliser un attribut dans la description d'une action
   synthétisée, il suffit de taper~:
\begin{verbatim}
       "$"<identificasteur-C> "("<non-terminal>")"
\end{verbatim}
   où {\tt <non-terminal>} désigne un non-terminal de la règle de
   la grammaire pour laquelle on écrit l'action.
   L'attribut considéré est alors celui associé à ce non-terminal.

   Si il existe plusieurs non-terminaux identiques dans la
   règle de la grammaire, la distinction des attributs
   s'effectue en ajoutant un ou plusieurs caractères {\tt '} après 
   le {\tt <non-terminal>} et la parenthèse ``{\tt )}''.

   soit la règle~:
\begin{verbatim}
   <liste> = <liste> <idf> <liste> ;
\end{verbatim}
    et l'attribut associe exp.
    {\tt \$exp(<liste>)} désigne l'attribut associé au non-terminal
   composant la partie gauche de la règle.


   {\tt \$exp(<liste>')} désigne l'attribut associé au non-terminal
   {\tt <liste>} pré\-cé\-dant le non-terminal {\tt <idf>}.


   {\tt \$exp(<liste>'')} désigne l'attribut associé au non-terminal
   {\tt <liste>} suivant le non-terminal {\tt <idf>}.


%\begin{example}
     Soit une grammaire définissant des listes composées 
     par les mots {\tt idf} séparés par une virgule.
     On désire compter le nombre d'éléments composant cette liste.

     Pour cela, on utilise un attribut entier servant de compteur
     qui représente le nombre d'éléments de chaque liste.

     Le fichier {\it mots.semc} correspondant s'écrit alors~:
\begin{verbatim}
     *declaration locale des attributs
     $compteur(<axiom>, <liste>):int;
     *une declaration se termine toujours par le signe $
     $

     *Description des regles de la grammaire et des actions
     *associees

     <axiome> = <liste> ;
     *declaration locale
     $compteur(<axiome>)
     *action associee a cette regle
	 $compteur(<axiome>) = $compteur(<liste>);
	 printf("nombre d'elements dans la liste %d",$compteur(<axiome>);

     <liste> = <identificateur> ;
     *declaration locale
     $compteur(<liste>)
     *action associee a cette regle
	$compteur(<liste>) = 1;

     <liste> = <liste> , <identificateur> ;
     *declaration locale
     $compteur(<liste>)
     *action associee a cette regle
	$compteur(<liste>) = 1 + $compteur(<liste>');

     <identificateur> = "idf" ;
\end{verbatim}
%\end{example}

\section{Compléments sur l'analyse syntaxique}

   Le programmeur, après la déclaration globale des attributs
   peut déclarer des variables C, inclure des fichiers de suffixe {\it .h},
   appeler des actions (toujours décrites en langage C)
   qui sont effectuées au début de l'analyse syntaxique, ou à la fin 
   de l'analyse.

   Ces déclarations doivent s'effectuer de la manière suivante~:
\begin{verbatim}
   decl=
   * zone de declaration
   * inserer ici la declaration de variable ou les inclusions de 
   * fichiers
   $
   open=
   * actions a effectuer a l'initialisation de l'analyse
   * syntaxique
   $
   close=
   * actions a effectuer a la fin de l'analyse syntaxique
   $
\end{verbatim}
   Il est à noter que si \SYNTAX{} n'arrive pas à rattraper une erreur
   de syntaxe, il continue l'analyse syntaxique, mais n'exécute
   plus les actions lors de la réduction des règles.

\end{document}

